/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.util;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n\r\n\r\n/**\r\n\r\n * Faster, more accurate, portable alternative to {@link Math} and\r\n\r\n * {@link StrictMath} for large scale computation.\r\n\r\n * <p>\r\n\r\n * FastMath is a drop-in replacement for both Math and StrictMath. This\r\n\r\n * means that for any method in Math (say {@code Math.sin(x)} or\r\n\r\n * {@code Math.cbrt(y)}), user can directly change the class and use the\r\n\r\n * methods as is (using {@code std::sin(x)} or {@code std::cbrt(y)}\r\n\r\n * in the previous example).\r\n\r\n * <p>\r\n\r\n * FastMath speed is achieved by relying heavily on optimizing compilers\r\n\r\n * to native code present in many JVMs today and use of large tables.\r\n\r\n * The larger tables are lazily initialized on first use, so that the setup\r\n\r\n * time does not penalize methods that don't need them.\r\n\r\n * <p>\r\n\r\n * Note that FastMath is\r\n\r\n * extensively used inside Hipparchus, so by calling some algorithms, * the overhead when the the tables need to be initialized will occur\r\n\r\n * regardless of the end-user calling FastMath methods directly or not.\r\n\r\n * Performance figures for a specific JVM and hardware can be evaluated by\r\n\r\n * running the FastMathTestPerformance tests in the test directory of the source\r\n\r\n * distribution.\r\n\r\n * <p>\r\n\r\n * FastMath accuracy should be mostly independent of the JVM as it relies only\r\n\r\n * on IEEE-754 basic operations and on embedded tables. Almost all operations\r\n\r\n * are accurate to about 0.5 ulp throughout the domain range. This statement, * of course is only a rough global observed behavior, it is <em>not</em> a\r\n\r\n * guarantee for <em>every</em> double numbers input (see William Kahan's <a\r\n\r\n * href="http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma">Table\r\n\r\n * Maker's Dilemma</a>).\r\n\r\n * <p>\r\n\r\n * FastMath additionally : the following methods not found in Math/StrictMath:\r\n\r\n * <ul>\r\n\r\n * <li>{@link #asinhstatic_cast<double>(}</li>\r\n\r\n * <li>{@link #acoshstatic_cast<double>(}</li>\r\n\r\n * <li>{@link #atanhstatic_cast<double>(}</li>\r\n\r\n * </ul>\r\n\r\n * The following methods are found in Math/StrictMath since 1.6 only, they are provided\r\n\r\n * by FastMath even in 1.5 Java virtual machines\r\n\r\n * <ul>\r\n\r\n * <li>{@link #copy_sign(double, double)}</li>\r\n\r\n * <li>{@link #get_exponentstatic_cast<double>(}</li>\r\n\r\n * <li>{@link #next_after(double,double)}</li>\r\n\r\n * <li>{@link #next_upstatic_cast<double>(}</li>\r\n\r\n * <li>{@link #scalb(double, int)}</li>\r\n\r\n * <li>{@link #copy_sign(float, float)}</li>\r\n\r\n * <li>{@link #get_exponent(float)}</li>\r\n\r\n * <li>{@link #next_after(float,double)}</li>\r\n\r\n * <li>{@link #next_up(float)}</li>\r\n\r\n * <li>{@link #scalb(float, int)}</li>\r\n\r\n * </ul>\r\n\r\n */\r\n\r\nclass FastMath \r\n\r\n{\r\n\r\n    /** Archimede's constant PI, ratio of circle circumference to diameter. */\r\n\r\n    public static const double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\r\n\r\n\r\n\r\n    /** Napier's constant e, base of the natural logarithm. */\r\n\r\n    public static const double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\r\n\r\n\r\n\r\n    /** Index of exp(0) in the array of integer exponentials. */\r\n\r\n    static const int EXP_INT_TABLE_MAX_INDEX = 750;\r\n\r\n    /** Length of the array of integer exponentials. */\r\n\r\n    static const int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\r\n\r\n    /** Logarithm table length. */\r\n\r\n    static const int LN_MANT_LEN = 1024;\r\n\r\n    /** Exponential fractions table length. */\r\n\r\n    static const int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024\r\n\r\n\r\n\r\n    /** StrictMath.log(Double.MAX_VALUE): {@value} */\r\n\r\n    private static const double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\r\n\r\n\r\n\r\n    /** Indicator for tables initialization.\r\n\r\n     * <p>\r\n\r\n     * This compile-time constant should be set to true only if one explicitly\r\n\r\n     * wants to compute the tables at class loading time instead of using the\r\n\r\n     * already computed ones provided as literal arrays below.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    private static const bool RECOMPUTE_TABLES_AT_RUNTIME = false;\r\n\r\n\r\n\r\n    /** log(2) (high bits). */\r\n\r\n    private static const double LN_2_A = 0.693147063255310059;\r\n\r\n\r\n\r\n    /** log(2) (low bits). */\r\n\r\n    private static const double LN_2_B = 1.17304635250823482e-7;\r\n\r\n\r\n\r\n    /** Coefficients for log, when input 0.99 < x < 1.01. */\r\n\r\n    private static const double LN_QUICK_COEF[][] = \r\n\r\n    {\r\n\r\n        {1.0, 5.669184079525E-24}, {-0.25, -0.25}, {0.3333333134651184, 1.986821492305628E-8}, {-0.25, -6.663542893624021E-14}, {0.19999998807907104, 1.1921056801463227E-8}, {-0.1666666567325592, -7.800414592973399E-9}, {0.1428571343421936, 5.650007086920087E-9}, {-0.12502530217170715, -7.44321345601866E-11}, {0.11113807559013367, 9.219544613762692E-9}, };\r\n\r\n\r\n\r\n    /** Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10. */\r\n\r\n    private static const double LN_HI_PREC_COEF[][] = \r\n\r\n    {\r\n\r\n        {1.0, -6.032174644509064E-23}, {-0.25, -0.25}, {0.3333333134651184, 1.9868161777724352E-8}, {-0.2499999701976776, -2.957007209750105E-8}, {0.19999954104423523, 1.5830993332061267E-10}, {-0.16624879837036133, -2.6033824355191673E-8}\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */\r\n\r\n\r\n\r\n    /** Sine table (high bits). */\r\n\r\n    private static const double SINE_TABLE_A[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +0.0, +0.1246747374534607d, +0.24740394949913025d, +0.366272509098053d, +0.4794255495071411d, +0.5850973129272461d, +0.6816387176513672d, +0.7675435543060303d, +0.8414709568023682d, +0.902267575263977d, +0.9489846229553223d, +0.9808930158615112d, +0.9974949359893799d, +0.9985313415527344d, };\r\n\r\n\r\n\r\n    /** Sine table (low bits). */\r\n\r\n    private static const double SINE_TABLE_B[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +0.0, -4.068233003401932E-9d, +9.755392680573412E-9d, +1.9987994582857286E-8d, -1.0902938113007961E-8d, -3.9986783938944604E-8d, +4.23719669792332E-8d, -5.207000323380292E-8d, +2.800552834259E-8d, +1.883511811213715E-8d, -3.5997360512765566E-9d, +4.116164446561962E-8d, +5.0614674548127384E-8d, -1.0129027912496858E-9d, };\r\n\r\n\r\n\r\n    /** Cosine table (high bits). */\r\n\r\n    private static const double COSINE_TABLE_A[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +1.0, +0.9921976327896118d, +0.9689123630523682d, +0.9305076599121094d, +0.8775825500488281d, +0.8109631538391113d, +0.7316888570785522d, +0.6409968137741089d, +0.5403022766113281d, +0.4311765432357788d, +0.3153223395347595d, +0.19454771280288696d, +0.07073719799518585d, -0.05417713522911072d, };\r\n\r\n\r\n\r\n    /** Cosine table (low bits). */\r\n\r\n    private static const double COSINE_TABLE_B[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +0.0, +3.4439717236742845E-8d, +5.865827662008209E-8d, -3.7999795083850525E-8d, +1.184154459111628E-8d, -3.43338934259355E-8d, +1.1795268640216787E-8d, +4.438921624363781E-8d, +2.925681159240093E-8d, -2.6437112632041807E-8d, +2.2860509143963117E-8d, -4.813899778443457E-9d, +3.6725170580355583E-9d, +2.0217439756338078E-10d, };\r\n\r\n\r\n\r\n\r\n\r\n    /** Tangent table, used by atan() (high bits). */\r\n\r\n    private static const double TANGENT_TABLE_A[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +0.0, +0.1256551444530487d, +0.25534194707870483d, +0.3936265707015991d, +0.5463024377822876d, +0.7214844226837158d, +0.9315965175628662d, +1.1974215507507324d, +1.5574076175689697d, +2.092571258544922d, +3.0095696449279785d, +5.041914939880371d, +14.101419448852539d, -18.430862426757812d, };\r\n\r\n\r\n\r\n    /** Tangent table, used by atan() (low bits). */\r\n\r\n    private static const double TANGENT_TABLE_B[] =\r\n\r\n        \r\n\r\n        {\r\n\r\n        +0.0, -7.877917738262007E-9d, -2.5857668567479893E-8d, +5.2240336371356666E-9d, +5.206150291559893E-8d, +1.8307188599677033E-8d, -5.7618793749770706E-8d, +7.848361555046424E-8d, +1.0708593250394448E-7d, +1.7827257129423813E-8d, +2.893485277253286E-8d, +3.1660099222737955E-7d, +4.983191803254889E-7d, -3.356118100840571E-7d, };\r\n\r\n\r\n\r\n    /** Bits of 1/(2*pi), need for reducePayneHanek(). */\r\n\r\n    private static const long RECIP_2PI[] = \r\n\r\n    {\r\n\r\n        (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x01924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32  };\r\n\r\n\r\n\r\n    /** Bits of pi/4, need for reducePayneHanek(). */\r\n\r\n    private static const long PI_O_4_BITS[] = \r\n\r\n    {\r\n\r\n        (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L };\r\n\r\n\r\n\r\n    /** Eighths.\r\n\r\n     * This is used by sinQ, because its faster to do a table lookup than\r\n\r\n     * a multiply in this time-critical routine\r\n\r\n     */\r\n\r\n    private static const double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\r\n\r\n\r\n\r\n    /** Table of 2^((n+2)/3) */\r\n\r\n    private static const double CBRTTWO[] = { 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 };\r\n\r\n\r\n\r\n    /*\r\n\r\n     *  There are 52 bits in the mantissa of a double.\r\n\r\n     *  For additional precision, the code splits double numbers into two parts, *  by clearing the low order 30 bits if possible, and then performs the arithmetic\r\n\r\n     *  on each half separately.\r\n\r\n     */\r\n\r\n\r\n\r\n    /**\r\n\r\n     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\r\n\r\n     * Equivalent to 2^30.\r\n\r\n     */\r\n\r\n    private static const long HEX_40000000 = 0x40000000L; // 1073741824L\r\n\r\n\r\n\r\n    /** Mask used to clear low order 30 bits */\r\n\r\n    private static const long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;\r\n\r\n\r\n\r\n    /** Mask used to clear the non-sign part of an int. */\r\n\r\n    private static const int MASK_NON_SIGN_INT = 0x7fffffff;\r\n\r\n\r\n\r\n    /** Mask used to clear the non-sign part of a long. */\r\n\r\n    private static const long MASK_NON_SIGN_LONG = 0x7fffffffffffffffl;\r\n\r\n\r\n\r\n    /** Mask used to extract exponent from double bits. */\r\n\r\n    private static const long MASK_DOUBLE_EXPONENT = 0x7ff0000000000000L;\r\n\r\n\r\n\r\n    /** Mask used to extract mantissa from double bits. */\r\n\r\n    private static const long MASK_DOUBLE_MANTISSA = 0x000fffffffffffffL;\r\n\r\n\r\n\r\n    /** Mask used to add implicit high order bit for normalized double. */\r\n\r\n    private static const long IMPLICIT_HIGH_BIT = 0x0010000000000000L;\r\n\r\n\r\n\r\n    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\r\n\r\n    private static const double TWO_POWER_52 = 4503599627370496.0;\r\n\r\n\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_3 = 1.0/ 3d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_5 = 1.0/ 5d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_7 = 1.0/ 7d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_9 = 1.0/ 9d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_11 = 1.0/ 11d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_13 = 1.0/ 13d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_15 = 1.0/ 15d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_17 = 1.0/ 17d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_3_4 = 3d / 4d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_15_16 = 15d / 16d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_13_14 = 13d / 14d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_11_12 = 11.0/ 12d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_9_10 = 9d / 10d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_7_8 = 7d / 8d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_5_6 = 5d / 6d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_2 = 1.0/ 2d;\r\n\r\n    /** Constant: {@value}. */\r\n\r\n    private static const double F_1_4 = 1.0/ 4d;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Private Constructor\r\n\r\n     */\r\n\r\n    private FastMath() {}\r\n\r\n\r\n\r\n    // Generic helper methods\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the high order bits from the mantissa.\r\n\r\n     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\r\n\r\n     *\r\n\r\n     * @param d the value to split\r\n\r\n     * @return the high order part of the mantissa\r\n\r\n     */\r\n\r\n    private static double doubleHigh_part(double d) \r\n\r\n    {\r\n\r\n        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN)\r\n\r\n        {\r\n\r\n            return d; // These are un-normalised - don't try to convert\r\n\r\n        }\r\n\r\n        long xl = Double.double_to_raw_long_bits(d); // can take raw bits because just gonna convert it back\r\n\r\n        xl &= MASK_30BITS; // Drop low order bits\r\n\r\n        return Double.long_bits_to_double(xl);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square root of a number.\r\n\r\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return square root of a\r\n\r\n     */\r\n\r\n    public static double sqrt(const double& a) \r\n\r\n    {\r\n\r\n        return Math.sqrt(a);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic cosine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return hyperbolic cosine of x\r\n\r\n     */\r\n\r\n    public static double cosh(double x) \r\n\r\n    {\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      // cosh[z] = (exp(z) + exp(-z))/2\r\n\r\n\r\n\r\n      // for numbers with magnitude 20 or so, // exp(-z) can be ignored in comparison with exp(z)\r\n\r\n\r\n\r\n      if (x > 20) \r\n\r\n      {\r\n\r\n          if (x >= LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(0.5 * x);\r\n\r\n              return (0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              return 0.5 * exp(x);\r\n\r\n          }\r\n\r\n      }\r\n\r\nelse if (x < -20) \r\n\r\n      {\r\n\r\n          if (x <= -LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(-0.5 * x);\r\n\r\n              return (0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              return 0.5 * exp(-x);\r\n\r\n          }\r\n\r\n      }\r\n\r\n\r\n\r\n      const double hiPrec[] = std::vector<double>(2);\r\n\r\n      if (x < 0.0) \r\n\r\n      {\r\n\r\n          x = -x;\r\n\r\n      }\r\n\r\n      exp(x, 0.0, hiPrec);\r\n\r\n\r\n\r\n      double ya = hiPrec[0] + hiPrec[1];\r\n\r\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n      double temp = ya * HEX_40000000;\r\n\r\n      double yaa = ya + temp - temp;\r\n\r\n      double yab = ya - yaa;\r\n\r\n\r\n\r\n      // recip = 1/y\r\n\r\n      double recip = 1.0/ya;\r\n\r\n      temp = recip * HEX_40000000;\r\n\r\n      double recipa = recip + temp - temp;\r\n\r\n      double recipb = recip - recipa;\r\n\r\n\r\n\r\n      // Correct for rounding in division\r\n\r\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\r\n\r\n      // Account for yb\r\n\r\n      recipb += -yb * recip * recip;\r\n\r\n\r\n\r\n      // y = y + 1/y\r\n\r\n      temp = ya + recipa;\r\n\r\n      yb += -(temp - ya - recipa);\r\n\r\n      ya = temp;\r\n\r\n      temp = ya + recipb;\r\n\r\n      yb += -(temp - ya - recipb);\r\n\r\n      ya = temp;\r\n\r\n\r\n\r\n      double result = ya + yb;\r\n\r\n      result *= 0.5;\r\n\r\n      return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic sine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return hyperbolic sine of x\r\n\r\n     */\r\n\r\n    public static double sinh(double x) \r\n\r\n    {\r\n\r\n      bool negate = false;\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      // sinh[z] = (exp(z) - exp(-z) / 2\r\n\r\n\r\n\r\n      // for values of z larger than about 20, // exp(-z) can be ignored in comparison with exp(z)\r\n\r\n\r\n\r\n      if (x > 20) \r\n\r\n      {\r\n\r\n          if (x >= LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(0.5 * x);\r\n\r\n              return (0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              return 0.5 * exp(x);\r\n\r\n          }\r\n\r\n      }\r\n\r\nelse if (x < -20) \r\n\r\n      {\r\n\r\n          if (x <= -LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(-0.5 * x);\r\n\r\n              return (-0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              return -0.5 * exp(-x);\r\n\r\n          }\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 0) \r\n\r\n      {\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x < 0.0) \r\n\r\n      {\r\n\r\n          x = -x;\r\n\r\n          negate = true;\r\n\r\n      }\r\n\r\n\r\n\r\n      double hiPrec[] = std::vector<double>(2);\r\n\r\n      double result;\r\n\r\n\r\n\r\n      if (x > 0.25) \r\n\r\n      {\r\n\r\n          exp(x, 0.0, hiPrec);\r\n\r\n\r\n\r\n          double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          double temp = ya * HEX_40000000;\r\n\r\n          double yaa = ya + temp - temp;\r\n\r\n          double yab = ya - yaa;\r\n\r\n\r\n\r\n          // recip = 1/y\r\n\r\n          double recip = 1.0/ya;\r\n\r\n          temp = recip * HEX_40000000;\r\n\r\n          double recipa = recip + temp - temp;\r\n\r\n          double recipb = recip - recipa;\r\n\r\n\r\n\r\n          // Correct for rounding in division\r\n\r\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\r\n\r\n          // Account for yb\r\n\r\n          recipb += -yb * recip * recip;\r\n\r\n\r\n\r\n          recipa = -recipa;\r\n\r\n          recipb = -recipb;\r\n\r\n\r\n\r\n          // y = y - 1/y\r\n\r\n          temp = ya + recipa;\r\n\r\n          yb += -(temp - ya - recipa);\r\n\r\n          ya = temp;\r\n\r\n          temp = ya + recipb;\r\n\r\n          yb += -(temp - ya - recipb);\r\n\r\n          ya = temp;\r\n\r\n\r\n\r\n          result = ya + yb;\r\n\r\n          result *= 0.5;\r\n\r\n      }\r\n\r\nelse \r\n\r\n      {\r\n\r\n          expm1(x, hiPrec);\r\n\r\n\r\n\r\n          double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\r\n\r\n          double denom = 1.0 + ya;\r\n\r\n          double denomr = 1.0 / denom;\r\n\r\n          double denomb = -(denom - 1.0 - ya) + yb;\r\n\r\n          double ratio = ya * denomr;\r\n\r\n          double temp = ratio * HEX_40000000;\r\n\r\n          double ra = ratio + temp - temp;\r\n\r\n          double rb = ratio - ra;\r\n\r\n\r\n\r\n          temp = denom * HEX_40000000;\r\n\r\n          double za = denom + temp - temp;\r\n\r\n          double zb = denom - za;\r\n\r\n\r\n\r\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\r\n\r\n\r\n\r\n          // Adjust for yb\r\n\r\n          rb += yb*denomr;                        // numerator\r\n\r\n          rb += -ya * denomb * denomr * denomr;   // denominator\r\n\r\n\r\n\r\n          // y = y - 1/y\r\n\r\n          temp = ya + ra;\r\n\r\n          yb += -(temp - ya - ra);\r\n\r\n          ya = temp;\r\n\r\n          temp = ya + rb;\r\n\r\n          yb += -(temp - ya - rb);\r\n\r\n          ya = temp;\r\n\r\n\r\n\r\n          result = ya + yb;\r\n\r\n          result *= 0.5;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (negate) \r\n\r\n      {\r\n\r\n          result = -result;\r\n\r\n      }\r\n\r\n\r\n\r\n      return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Combined hyperbolic sine and hyperbolic cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return [sinh(x), cosh(x)]\r\n\r\n     */\r\n\r\n    public static Sinh_Cosh sinh_cosh(double x) \r\n\r\n    {\r\n\r\n      bool negate = false;\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return Sinh_Cosh(x, x);\r\n\r\n      }\r\n\r\n\r\n\r\n      // sinh[z] = (exp(z) - exp(-z) / 2\r\n\r\n      // cosh[z] = (exp(z) + exp(-z))/2\r\n\r\n\r\n\r\n      // for values of z larger than about 20, // exp(-z) can be ignored in comparison with exp(z)\r\n\r\n\r\n\r\n      if (x > 20) \r\n\r\n      {\r\n\r\n          const double e;\r\n\r\n          if (x >= LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(0.5 * x);\r\n\r\n              e = (0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              e = 0.5 * exp(x);\r\n\r\n          }\r\n\r\n          return Sinh_Cosh(e, e);\r\n\r\n      }\r\n\r\nelse if (x < -20) \r\n\r\n      {\r\n\r\n          const double e;\r\n\r\n          if (x <= -LOG_MAX_VALUE) \r\n\r\n          {\r\n\r\n              // Avoid overflow (MATH-905).\r\n\r\n              const double t = exp(-0.5 * x);\r\n\r\n              e = (-0.5 * t) * t;\r\n\r\n          }\r\n\r\nelse \r\n\r\n          {\r\n\r\n              e = -0.5 * exp(-x);\r\n\r\n          }\r\n\r\n          return Sinh_Cosh(e, -e);\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 0) \r\n\r\n      {\r\n\r\n          return Sinh_Cosh(x, 1.0);\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x < 0.0) \r\n\r\n      {\r\n\r\n          x = -x;\r\n\r\n          negate = true;\r\n\r\n      }\r\n\r\n\r\n\r\n      double hiPrec[] = std::vector<double>(2);\r\n\r\n      double resultM;\r\n\r\n      double resultP;\r\n\r\n\r\n\r\n      if (x > 0.25) \r\n\r\n      {\r\n\r\n          exp(x, 0.0, hiPrec);\r\n\r\n\r\n\r\n          const double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          const double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          double temp = ya * HEX_40000000;\r\n\r\n          double yaa = ya + temp - temp;\r\n\r\n          double yab = ya - yaa;\r\n\r\n\r\n\r\n          // recip = 1/y\r\n\r\n          double recip = 1.0/ya;\r\n\r\n          temp = recip * HEX_40000000;\r\n\r\n          double recipa = recip + temp - temp;\r\n\r\n          double recipb = recip - recipa;\r\n\r\n\r\n\r\n          // Correct for rounding in division\r\n\r\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\r\n\r\n          // Account for yb\r\n\r\n          recipb += -yb * recip * recip;\r\n\r\n\r\n\r\n          // y = y - 1/y\r\n\r\n          temp = ya - recipa;\r\n\r\n          double ybM = yb - (temp - ya + recipa);\r\n\r\n          double ya_m = temp;\r\n\r\n          temp = ya_m - recipb;\r\n\r\n          ybM += -(temp - ya_m + recipb);\r\n\r\n          ya_m = temp;\r\n\r\n          resultM = ya_m + ybM;\r\n\r\n          resultM *= 0.5;\r\n\r\n\r\n\r\n          // y = y + 1/y\r\n\r\n          temp = ya + recipa;\r\n\r\n          double ybP = yb - (temp - ya - recipa);\r\n\r\n          double yaP = temp;\r\n\r\n          temp = yaP + recipb;\r\n\r\n          ybP += -(temp - yaP - recipb);\r\n\r\n          yaP = temp;\r\n\r\n          resultP = yaP + ybP;\r\n\r\n          resultP *= 0.5;\r\n\r\n\r\n\r\n      }\r\n\r\nelse \r\n\r\n      {\r\n\r\n          expm1(x, hiPrec);\r\n\r\n\r\n\r\n          const double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          const double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\r\n\r\n          double denom = 1.0 + ya;\r\n\r\n          double denomr = 1.0 / denom;\r\n\r\n          double denomb = -(denom - 1.0 - ya) + yb;\r\n\r\n          double ratio = ya * denomr;\r\n\r\n          double temp = ratio * HEX_40000000;\r\n\r\n          double ra = ratio + temp - temp;\r\n\r\n          double rb = ratio - ra;\r\n\r\n\r\n\r\n          temp = denom * HEX_40000000;\r\n\r\n          double za = denom + temp - temp;\r\n\r\n          double zb = denom - za;\r\n\r\n\r\n\r\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\r\n\r\n\r\n\r\n          // Adjust for yb\r\n\r\n          rb += yb*denomr;                        // numerator\r\n\r\n          rb += -ya * denomb * denomr * denomr;   // denominator\r\n\r\n\r\n\r\n          // y = y - 1/y\r\n\r\n          temp = ya + ra;\r\n\r\n          double ybM = yb - (temp - ya - ra);\r\n\r\n          double ya_m = temp;\r\n\r\n          temp = ya_m + rb;\r\n\r\n          ybM += -(temp - ya_m - rb);\r\n\r\n          ya_m = temp;\r\n\r\n          resultM = ya_m + ybM;\r\n\r\n          resultM *= 0.5;\r\n\r\n\r\n\r\n          // y = y + 1/y + 2\r\n\r\n          temp = ya - ra;\r\n\r\n          double ybP = yb - (temp - ya + ra);\r\n\r\n          double yaP = temp;\r\n\r\n          temp = yaP - rb;\r\n\r\n          ybP += -(temp - yaP + rb);\r\n\r\n          yaP = temp;\r\n\r\n          resultP = yaP + ybP + 2;\r\n\r\n          resultP *= 0.5;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (negate) \r\n\r\n      {\r\n\r\n          resultM = -resultM;\r\n\r\n      }\r\n\r\n\r\n\r\n      return Sinh_Cosh(resultM, resultP);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Combined hyperbolic sine and hyperbolic cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return [sinh(x), cosh(x)]\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  Field_Sinh_Cosh<T> sinh_cosh(T x) \r\n\r\n    {\r\n\r\n        return x.sinh_cosh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic tangent of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return hyperbolic tangent of x\r\n\r\n     */\r\n\r\n    public static double tanh(double x) \r\n\r\n    {\r\n\r\n      bool negate = false;\r\n\r\n\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      // tanh[z] = sinh[z] / cosh[z]\r\n\r\n      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\r\n\r\n      // = (exp(2x) - 1) / (exp(2x) + 1)\r\n\r\n\r\n\r\n      // for magnitude > 20, sinh[z] == cosh[z] in double precision\r\n\r\n\r\n\r\n      if (x > 20.0) \r\n\r\n      {\r\n\r\n          return 1.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x < -20) \r\n\r\n      {\r\n\r\n          return -1.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 0) \r\n\r\n      {\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x < 0.0) \r\n\r\n      {\r\n\r\n          x = -x;\r\n\r\n          negate = true;\r\n\r\n      }\r\n\r\n\r\n\r\n      double result;\r\n\r\n      if (x >= 0.5) \r\n\r\n      {\r\n\r\n          double hiPrec[] = std::vector<double>(2);\r\n\r\n          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\r\n\r\n          exp(x*2.0, 0.0, hiPrec);\r\n\r\n\r\n\r\n          double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          /* Numerator */\r\n\r\n          double na = -1.0 + ya;\r\n\r\n          double nb = -(na + 1.0 - ya);\r\n\r\n          double temp = na + yb;\r\n\r\n          nb += -(temp - na - yb);\r\n\r\n          na = temp;\r\n\r\n\r\n\r\n          /* Denominator */\r\n\r\n          double da = 1.0 + ya;\r\n\r\n          double db = -(da - 1.0 - ya);\r\n\r\n          temp = da + yb;\r\n\r\n          db += -(temp - da - yb);\r\n\r\n          da = temp;\r\n\r\n\r\n\r\n          temp = da * HEX_40000000;\r\n\r\n          double daa = da + temp - temp;\r\n\r\n          double dab = da - daa;\r\n\r\n\r\n\r\n          // ratio = na/da\r\n\r\n          double ratio = na/da;\r\n\r\n          temp = ratio * HEX_40000000;\r\n\r\n          double ratioa = ratio + temp - temp;\r\n\r\n          double ratiob = ratio - ratioa;\r\n\r\n\r\n\r\n          // Correct for rounding in division\r\n\r\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\r\n\r\n\r\n\r\n          // Account for nb\r\n\r\n          ratiob += nb / da;\r\n\r\n          // Account for db\r\n\r\n          ratiob += -db * na / da / da;\r\n\r\n\r\n\r\n          result = ratioa + ratiob;\r\n\r\n      }\r\n\r\n      else \r\n\r\n      {\r\n\r\n          double hiPrec[] = std::vector<double>(2);\r\n\r\n          // tanh(x) = expm1(2x) / (expm1(2x) + 2)\r\n\r\n          expm1(x*2.0, hiPrec);\r\n\r\n\r\n\r\n          double ya = hiPrec[0] + hiPrec[1];\r\n\r\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\r\n\r\n\r\n\r\n          /* Numerator */\r\n\r\n          double na = ya;\r\n\r\n          double nb = yb;\r\n\r\n\r\n\r\n          /* Denominator */\r\n\r\n          double da = 2.0 + ya;\r\n\r\n          double db = -(da - 2.0 - ya);\r\n\r\n          double temp = da + yb;\r\n\r\n          db += -(temp - da - yb);\r\n\r\n          da = temp;\r\n\r\n\r\n\r\n          temp = da * HEX_40000000;\r\n\r\n          double daa = da + temp - temp;\r\n\r\n          double dab = da - daa;\r\n\r\n\r\n\r\n          // ratio = na/da\r\n\r\n          double ratio = na/da;\r\n\r\n          temp = ratio * HEX_40000000;\r\n\r\n          double ratioa = ratio + temp - temp;\r\n\r\n          double ratiob = ratio - ratioa;\r\n\r\n\r\n\r\n          // Correct for rounding in division\r\n\r\n          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\r\n\r\n\r\n\r\n          // Account for nb\r\n\r\n          ratiob += nb / da;\r\n\r\n          // Account for db\r\n\r\n          ratiob += -db * na / da / da;\r\n\r\n\r\n\r\n          result = ratioa + ratiob;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (negate) \r\n\r\n      {\r\n\r\n          result = -result;\r\n\r\n      }\r\n\r\n\r\n\r\n      return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic cosine of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return inverse hyperbolic cosine of a\r\n\r\n     */\r\n\r\n    public static double acosh(const double& a) \r\n\r\n    {\r\n\r\n        return std::log(a + std::sqrt(a * a - 1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic sine of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return inverse hyperbolic sine of a\r\n\r\n     */\r\n\r\n    public static double asinh(double a) \r\n\r\n    {\r\n\r\n        bool negative = false;\r\n\r\n        if (a < 0) \r\n\r\n        {\r\n\r\n            negative = true;\r\n\r\n            a = -a;\r\n\r\n        }\r\n\r\n\r\n\r\n        double absAsinh;\r\n\r\n        if (a > 0.167) \r\n\r\n        {\r\n\r\n            absAsinh = std::log(std::sqrt(a * a + 1) + a);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const double& a2 = a * a;\r\n\r\n            if (a > 0.097) \r\n\r\n            {\r\n\r\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\r\n\r\n            }\r\n\r\nelse if (a > 0.036) \r\n\r\n            {\r\n\r\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\r\n\r\n            }\r\n\r\nelse if (a > 0.0036) \r\n\r\n            {\r\n\r\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return negative ? -absAsinh : absAsinh;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic tangent of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return inverse hyperbolic tangent of a\r\n\r\n     */\r\n\r\n    public static double atanh(double a) \r\n\r\n    {\r\n\r\n        bool negative = false;\r\n\r\n        if (a < 0) \r\n\r\n        {\r\n\r\n            negative = true;\r\n\r\n            a = -a;\r\n\r\n        }\r\n\r\n\r\n\r\n        double absAtanh;\r\n\r\n        if (a > 0.15) \r\n\r\n        {\r\n\r\n            absAtanh = 0.5 * std::log((1 + a) / (1 - a));\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const double& a2 = a * a;\r\n\r\n            if (a > 0.087) \r\n\r\n            {\r\n\r\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\r\n\r\n            }\r\n\r\nelse if (a > 0.031) \r\n\r\n            {\r\n\r\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\r\n\r\n            }\r\n\r\nelse if (a > 0.003) \r\n\r\n            {\r\n\r\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return negative ? -absAtanh : absAtanh;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the signum of a number.\r\n\r\n     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\r\n\r\n     */\r\n\r\n    public static double signum(const double& a) \r\n\r\n    {\r\n\r\n        return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the signum of a number.\r\n\r\n     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\r\n\r\n     */\r\n\r\n    public static float signum(const float a) \r\n\r\n    {\r\n\r\n        return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute next number towards positive infinity.\r\n\r\n     * @param a number to which neighbor should be computed\r\n\r\n     * @return neighbor of a towards positive infinity\r\n\r\n     */\r\n\r\n    public static double next_up(const double& a) \r\n\r\n    {\r\n\r\n        return next_after(a, INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute next number towards positive infinity.\r\n\r\n     * @param a number to which neighbor should be computed\r\n\r\n     * @return neighbor of a towards positive infinity\r\n\r\n     */\r\n\r\n    public static float next_up(const float a) \r\n\r\n    {\r\n\r\n        return next_after(a, Float.POSITIVE_INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute next number towards negative infinity.\r\n\r\n     * @param a number to which neighbor should be computed\r\n\r\n     * @return neighbor of a towards negative infinity\r\n\r\n     */\r\n\r\n    public static double next_down(const double& a) \r\n\r\n    {\r\n\r\n        return next_after(a, -INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute next number towards negative infinity.\r\n\r\n     * @param a number to which neighbor should be computed\r\n\r\n     * @return neighbor of a towards negative infinity\r\n\r\n     */\r\n\r\n    public static float next_down(const float a) \r\n\r\n    {\r\n\r\n        return next_after(a, Float.NEGATIVE_INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Returns a pseudo-random number between 0.0 and 1.0.\r\n\r\n     * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\r\n\r\n     * @return a random number between 0.0 and 1.0\r\n\r\n     */\r\n\r\n    public static double random() \r\n\r\n    {\r\n\r\n        return Math.random();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Exponential function.\r\n\r\n     *\r\n\r\n     * Computes exp(x), function result is nearly rounded.   It will be correctly\r\n\r\n     * rounded to the theoretical value for 99.9% of input values, otherwise it will\r\n\r\n     * have a 1 ULP error.\r\n\r\n     *\r\n\r\n     * Method:\r\n\r\n     *    Lookup intVal = exp(int(x))\r\n\r\n     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\r\n\r\n     *    Compute z as the exponential of the remaining bits by a polynomial minus one\r\n\r\n     *    exp(x) = intVal * fracVal * (1 + z)\r\n\r\n     *\r\n\r\n     * Accuracy:\r\n\r\n     *    Calculation is done with 63 bits of precision, so result should be correctly\r\n\r\n     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @return double e<sup>x</sup>\r\n\r\n     */\r\n\r\n    public static double exp(double x) \r\n\r\n    {\r\n\r\n        return exp(x, 0.0, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Internal helper method for exponential function.\r\n\r\n     * @param x original argument of the exponential function\r\n\r\n     * @param extra extra bits of precision on input (To Be Confirmed)\r\n\r\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\r\n\r\n     * @return exp(x)\r\n\r\n     */\r\n\r\n    private static double exp(const double& x, double extra, std::vector<double> hiPrec) \r\n\r\n    {\r\n\r\n        double int_part_a;\r\n\r\n        double int_part_b;\r\n\r\n        int intVal = static_cast<int>( x;\r\n\r\n\r\n\r\n        /* Lookup exp(floor(x)).\r\n\r\n         * int_part_a will have the upper 22 bits, int_part_b will have the lower\r\n\r\n         * 52 bits.\r\n\r\n         */\r\n\r\n        if (x < 0.0) \r\n\r\n        {\r\n\r\n\r\n\r\n            // We don't check against intVal here as conversion of large negative double values\r\n\r\n            // may be affected by a JIT bug. Subsequent comparisons can safely use intVal\r\n\r\n            if (x < -746d) \r\n\r\n            {\r\n\r\n                if (hiPrec != null) \r\n\r\n                {\r\n\r\n                    hiPrec[0] = 0.0;\r\n\r\n                    hiPrec[1] = 0.0;\r\n\r\n                }\r\n\r\n                return 0.0;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (intVal < -709) \r\n\r\n            {\r\n\r\n                /* This will produce a subnormal output */\r\n\r\n                const double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\r\n\r\n                if (hiPrec != null) \r\n\r\n                {\r\n\r\n                    hiPrec[0] /= 285040095144011776.0;\r\n\r\n                    hiPrec[1] /= 285040095144011776.0;\r\n\r\n                }\r\n\r\n                return result;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (intVal == -709) \r\n\r\n            {\r\n\r\n                /* exp(1.494140625) is nearly a machine number... */\r\n\r\n                const double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\r\n\r\n                if (hiPrec != null) \r\n\r\n                {\r\n\r\n                    hiPrec[0] /= 4.455505956692756620;\r\n\r\n                    hiPrec[1] /= 4.455505956692756620;\r\n\r\n                }\r\n\r\n                return result;\r\n\r\n            }\r\n\r\n\r\n\r\n            intVal--;\r\n\r\n\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            if (intVal > 709) \r\n\r\n            {\r\n\r\n                if (hiPrec != null) \r\n\r\n                {\r\n\r\n                    hiPrec[0] = INFINITY;\r\n\r\n                    hiPrec[1] = 0.0;\r\n\r\n                }\r\n\r\n                return INFINITY;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        int_part_a = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\r\n\r\n        int_part_b = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\r\n\r\n\r\n\r\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\r\n\r\n         * x and look up the exp function of it.\r\n\r\n         * frac_part_a will have the upper 22 bits, frac_part_b the lower 52 bits.\r\n\r\n         */\r\n\r\n        const int intFrac = static_cast<int>( ((x - intVal) * 1024.0);\r\n\r\n        const double frac_part_a = Exp_fracTable.EXP_FRAC_TABLE_A[intFrac];\r\n\r\n        const double frac_part_b = Exp_fracTable.EXP_FRAC_TABLE_B[intFrac];\r\n\r\n\r\n\r\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\r\n\r\n         * has a value in the range 0 <= epsilon < 2^-10.\r\n\r\n         * Do the subtraction from x as the last step to avoid possible loss of precision.\r\n\r\n         */\r\n\r\n        const double epsilon = x - (intVal + intFrac / 1024.0);\r\n\r\n\r\n\r\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\r\n\r\n       full double precision (52 bits).  sin_ce z < 2^-10, we will have\r\n\r\n       62 bits of precision when combined with the constant 1.  This will be\r\n\r\n       used in the last addition below to get proper rounding. */\r\n\r\n\r\n\r\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\r\n\r\n       is less than 0.5 ULP */\r\n\r\n        double z = 0.04168701738764507;\r\n\r\n        z = z * epsilon + 0.1666666505023083;\r\n\r\n        z = z * epsilon + 0.5000000000042687;\r\n\r\n        z = z * epsilon + 1.0;\r\n\r\n        z = z * epsilon + -3.940510424527919E-20;\r\n\r\n\r\n\r\n        /* Compute (int_part_a+int_part_b) * (frac_part_a+frac_part_b) by binomial\r\n\r\n       expansion.\r\n\r\n       tempA is exact since int_part_a and int_part_b only have 22 bits each.\r\n\r\n       tempB will have 52 bits of precision.\r\n\r\n         */\r\n\r\n        double tempA = int_part_a * frac_part_a;\r\n\r\n        double tempB = int_part_a * frac_part_b + int_part_b * frac_part_a + int_part_b * frac_part_b;\r\n\r\n\r\n\r\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\r\n\r\n       important.  For accuracy add by increasing size.  tempA is exact and\r\n\r\n       much larger than the others.  If there are extra bits specified from the\r\n\r\n       pow() function, use them. */\r\n\r\n        const double tempC = tempB + tempA;\r\n\r\n\r\n\r\n        // If tempC is positive infinite, the evaluation below could result in NaN, // because z could be negative at the same time.\r\n\r\n        if (tempC == INFINITY) \r\n\r\n        {\r\n\r\n            return INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        const double result;\r\n\r\n        if (extra != 0.0) \r\n\r\n        {\r\n\r\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            result = tempC*z + tempB + tempA;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (hiPrec != null) \r\n\r\n        {\r\n\r\n            // If requesting high precision\r\n\r\n            hiPrec[0] = tempA;\r\n\r\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute exp(x) - 1\r\n\r\n     * @param x number to compute shifted exponential\r\n\r\n     * @return exp(x) - 1\r\n\r\n     */\r\n\r\n    public static double expm1(double x) \r\n\r\n    {\r\n\r\n      return expm1(x, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Internal helper method for expm1\r\n\r\n     * @param x number to compute shifted exponential\r\n\r\n     * @param hi_prec_out receive high precision result for -1.0 < x < 1.0\r\n\r\n     * @return exp(x) - 1\r\n\r\n     */\r\n\r\n    private static double expm1(const double& x, double hi_prec_out[]) \r\n\r\n    {\r\n\r\n        if (std::isnan(x) || x == 0.0) { // NaN or zero\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x <= -1.0 || x >= 1.0) \r\n\r\n        {\r\n\r\n            // If not between +/- 1.0\r\n\r\n            //return exp(x) - 1.0;\r\n\r\n            double hiPrec[] = std::vector<double>(2);\r\n\r\n            exp(x, 0.0, hiPrec);\r\n\r\n            if (x > 0.0) \r\n\r\n            {\r\n\r\n                return -1.0 + hiPrec[0] + hiPrec[1];\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                const double ra = -1.0 + hiPrec[0];\r\n\r\n                double rb = -(ra + 1.0 - hiPrec[0]);\r\n\r\n                rb += hiPrec[1];\r\n\r\n                return ra + rb;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        double baseA;\r\n\r\n        double baseB;\r\n\r\n        double epsilon;\r\n\r\n        bool negative = false;\r\n\r\n\r\n\r\n        if (x < 0.0) \r\n\r\n        {\r\n\r\n            x = -x;\r\n\r\n            negative = true;\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n\r\n        {\r\n\r\n            int intFrac = static_cast<int>( (x * 1024.0);\r\n\r\n            double tempA = Exp_fracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\r\n\r\n            double tempB = Exp_fracTable.EXP_FRAC_TABLE_B[intFrac];\r\n\r\n\r\n\r\n            double temp = tempA + tempB;\r\n\r\n            tempB = -(temp - tempA - tempB);\r\n\r\n            tempA = temp;\r\n\r\n\r\n\r\n            temp = tempA * HEX_40000000;\r\n\r\n            baseA = tempA + temp - temp;\r\n\r\n            baseB = tempB + (tempA - baseA);\r\n\r\n\r\n\r\n            epsilon = x - intFrac/1024.0;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        /* Compute expm1(epsilon) */\r\n\r\n        double zb = 0.008336750013465571;\r\n\r\n        zb = zb * epsilon + 0.041666663879186654;\r\n\r\n        zb = zb * epsilon + 0.16666666666745392;\r\n\r\n        zb = zb * epsilon + 0.49999999999999994;\r\n\r\n        zb *= epsilon;\r\n\r\n        zb *= epsilon;\r\n\r\n\r\n\r\n        double za = epsilon;\r\n\r\n        double temp = za + zb;\r\n\r\n        zb = -(temp - za - zb);\r\n\r\n        za = temp;\r\n\r\n\r\n\r\n        temp = za * HEX_40000000;\r\n\r\n        temp = za + temp - temp;\r\n\r\n        zb += za - temp;\r\n\r\n        za = temp;\r\n\r\n\r\n\r\n        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */\r\n\r\n        double ya = za * baseA;\r\n\r\n        //double yb = za*baseB + zb*baseA + zb*baseB;\r\n\r\n        temp = ya + za * baseB;\r\n\r\n        double yb = -(temp - ya - za * baseB);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        temp = ya + zb * baseA;\r\n\r\n        yb += -(temp - ya - zb * baseA);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        temp = ya + zb * baseB;\r\n\r\n        yb += -(temp - ya - zb*baseB);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        //ya = ya + za + baseA;\r\n\r\n        //yb = yb + zb + baseB;\r\n\r\n        temp = ya + baseA;\r\n\r\n        yb += -(temp - baseA - ya);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        temp = ya + za;\r\n\r\n        //yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);\r\n\r\n        yb += -(temp - ya - za);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        temp = ya + baseB;\r\n\r\n        //yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\r\n\r\n        yb += -(temp - ya - baseB);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        temp = ya + zb;\r\n\r\n        //yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);\r\n\r\n        yb += -(temp - ya - zb);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        if (negative) \r\n\r\n        {\r\n\r\n            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\r\n\r\n            double denom = 1.0 + ya;\r\n\r\n            double denomr = 1.0 / denom;\r\n\r\n            double denomb = -(denom - 1.0 - ya) + yb;\r\n\r\n            double ratio = ya * denomr;\r\n\r\n            temp = ratio * HEX_40000000;\r\n\r\n            const double ra = ratio + temp - temp;\r\n\r\n            double rb = ratio - ra;\r\n\r\n\r\n\r\n            temp = denom * HEX_40000000;\r\n\r\n            za = denom + temp - temp;\r\n\r\n            zb = denom - za;\r\n\r\n\r\n\r\n            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\r\n\r\n\r\n\r\n            // f(x) = x/1+x\r\n\r\n            // Compute f'(x)\r\n\r\n            // Product rule:  d(uv) = du*v + u*dv\r\n\r\n            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))\r\n\r\n            // d(1/x) = -1/(x*x)\r\n\r\n            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))\r\n\r\n            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))\r\n\r\n\r\n\r\n            // Adjust for yb\r\n\r\n            rb += yb * denomr;                      // numerator\r\n\r\n            rb += -ya * denomb * denomr * denomr;   // denominator\r\n\r\n\r\n\r\n            // negate\r\n\r\n            ya = -ra;\r\n\r\n            yb = -rb;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (hi_prec_out != null) \r\n\r\n        {\r\n\r\n            hi_prec_out[0] = ya;\r\n\r\n            hi_prec_out[1] = yb;\r\n\r\n        }\r\n\r\n\r\n\r\n        return ya + yb;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Natural logarithm.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @return log(x)\r\n\r\n     */\r\n\r\n    public static double log(const double& x) \r\n\r\n    {\r\n\r\n        return log(x, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Internal helper method for natural logarithm function.\r\n\r\n     * @param x original argument of the natural logarithm function\r\n\r\n     * @param hiPrec extra bits of precision on output (To Be Confirmed)\r\n\r\n     * @return log(x)\r\n\r\n     */\r\n\r\n    private static double log(const double& x, const std::vector<double> hiPrec) \r\n\r\n    {\r\n\r\n        if (x==0) { // Handle special case of +0/-0\r\n\r\n            return -INFINITY;\r\n\r\n        }\r\n\r\n        long bits = Double.double_to_raw_long_bits(x);\r\n\r\n\r\n\r\n        /* Handle special cases of negative input, and NaN */\r\n\r\n        if (((bits & 0x8000000000000000L) != 0 || std::isnan(x)) && x != 0.0) \r\n\r\n        {\r\n\r\n            if (hiPrec != null) \r\n\r\n            {\r\n\r\n                hiPrec[0] = std::numeric_limits<double>::quiet_NaN();\r\n\r\n            }\r\n\r\n\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Handle special cases of Positive infinity. */\r\n\r\n        if (x == INFINITY) \r\n\r\n        {\r\n\r\n            if (hiPrec != null) \r\n\r\n            {\r\n\r\n                hiPrec[0] = INFINITY;\r\n\r\n            }\r\n\r\n\r\n\r\n            return INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Extract the exponent */\r\n\r\n        int exp = static_cast<int>((bits >> 52)-1023;\r\n\r\n\r\n\r\n        if ((bits & 0x7ff0000000000000L) == 0) \r\n\r\n        {\r\n\r\n            // Subnormal!\r\n\r\n            if (x == 0) \r\n\r\n            {\r\n\r\n                // Zero\r\n\r\n                if (hiPrec != null) \r\n\r\n                {\r\n\r\n                    hiPrec[0] = -INFINITY;\r\n\r\n                }\r\n\r\n\r\n\r\n                return -INFINITY;\r\n\r\n            }\r\n\r\n\r\n\r\n            /* Normalize the subnormal number. */\r\n\r\n            bits <<= 1;\r\n\r\n            while ( (bits & 0x0010000000000000L) == 0) \r\n\r\n            {\r\n\r\n                --exp;\r\n\r\n                bits <<= 1;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) \r\n\r\n        {\r\n\r\n            /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\r\n\r\n           polynomial expansion in higer precision. */\r\n\r\n\r\n\r\n            /* Compute x - 1.0 and split it */\r\n\r\n            double xa = x - 1.0;\r\n\r\n            double tmp = xa * HEX_40000000;\r\n\r\n            double aa = xa + tmp - tmp;\r\n\r\n            double ab = xa - aa;\r\n\r\n            xa = aa;\r\n\r\n            double xb = ab;\r\n\r\n\r\n\r\n            const std::vector<double> ln_coef_last = LN_QUICK_COEF[LN_QUICK_COEF.size() - 1];\r\n\r\n            double ya = ln_coef_last[0];\r\n\r\n            double yb = ln_coef_last[1];\r\n\r\n\r\n\r\n            for (int i = LN_QUICK_COEF.size() - 2; i >= 0; i--) \r\n\r\n            {\r\n\r\n                /* Multiply a = y * x */\r\n\r\n                aa = ya * xa;\r\n\r\n                ab = ya * xb + yb * xa + yb * xb;\r\n\r\n                /* split, so now y = a */\r\n\r\n                tmp = aa * HEX_40000000;\r\n\r\n                ya = aa + tmp - tmp;\r\n\r\n                yb = aa - ya + ab;\r\n\r\n\r\n\r\n                /* Add  a = y + lnQuickCoef */\r\n\r\n                const std::vector<double> ln_coef_i = LN_QUICK_COEF[i];\r\n\r\n                aa = ya + ln_coef_i[0];\r\n\r\n                ab = yb + ln_coef_i[1];\r\n\r\n                /* Split y = a */\r\n\r\n                tmp = aa * HEX_40000000;\r\n\r\n                ya = aa + tmp - tmp;\r\n\r\n                yb = aa - ya + ab;\r\n\r\n            }\r\n\r\n\r\n\r\n            /* Multiply a = y * x */\r\n\r\n            aa = ya * xa;\r\n\r\n            ab = ya * xb + yb * xa + yb * xb;\r\n\r\n            /* split, so now y = a */\r\n\r\n            tmp = aa * HEX_40000000;\r\n\r\n            ya = aa + tmp - tmp;\r\n\r\n            yb = aa - ya + ab;\r\n\r\n\r\n\r\n            return ya + yb;\r\n\r\n        }\r\n\r\n\r\n\r\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\r\n\r\n        const std::vector<double> lnm = lnMant.LN_MANT[static_cast<int>(((bits & 0x000ffc0000000000L) >> 42)];\r\n\r\n\r\n\r\n        /*\r\n\r\n    double epsilon = x / Double.long_bits_to_double(bits & 0xfffffc0000000000L);\r\n\r\n\r\n\r\n    epsilon -= 1.0;\r\n\r\n         */\r\n\r\n\r\n\r\n        // y is the most significant 10 bits of the mantissa\r\n\r\n        //double y = Double.long_bits_to_double(bits & 0xfffffc0000000000L);\r\n\r\n        //double epsilon = (x - y) / y;\r\n\r\n        const double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\r\n\r\n\r\n\r\n        double lnza;\r\n\r\n        double lnzb = 0.0;\r\n\r\n\r\n\r\n        if (hiPrec != null) \r\n\r\n        {\r\n\r\n            /* split epsilon -> x */\r\n\r\n            double tmp = epsilon * HEX_40000000;\r\n\r\n            double aa = epsilon + tmp - tmp;\r\n\r\n            double ab = epsilon - aa;\r\n\r\n            double xa = aa;\r\n\r\n            double xb = ab;\r\n\r\n\r\n\r\n            /* Need a more accurate epsilon, so adjust the division. */\r\n\r\n            const double numer = bits & 0x3ffffffffffL;\r\n\r\n            const double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\r\n\r\n            aa = numer - xa*denom - xb * denom;\r\n\r\n            xb += aa / denom;\r\n\r\n\r\n\r\n            /* Remez polynomial evaluation */\r\n\r\n            const std::vector<double> ln_coef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.size()-1];\r\n\r\n            double ya = ln_coef_last[0];\r\n\r\n            double yb = ln_coef_last[1];\r\n\r\n\r\n\r\n            for (int i = LN_HI_PREC_COEF.size() - 2; i >= 0; i--) \r\n\r\n            {\r\n\r\n                /* Multiply a = y * x */\r\n\r\n                aa = ya * xa;\r\n\r\n                ab = ya * xb + yb * xa + yb * xb;\r\n\r\n                /* split, so now y = a */\r\n\r\n                tmp = aa * HEX_40000000;\r\n\r\n                ya = aa + tmp - tmp;\r\n\r\n                yb = aa - ya + ab;\r\n\r\n\r\n\r\n                /* Add  a = y + lnHiPrecCoef */\r\n\r\n                const std::vector<double> ln_coef_i = LN_HI_PREC_COEF[i];\r\n\r\n                aa = ya + ln_coef_i[0];\r\n\r\n                ab = yb + ln_coef_i[1];\r\n\r\n                /* Split y = a */\r\n\r\n                tmp = aa * HEX_40000000;\r\n\r\n                ya = aa + tmp - tmp;\r\n\r\n                yb = aa - ya + ab;\r\n\r\n            }\r\n\r\n\r\n\r\n            /* Multiply a = y * x */\r\n\r\n            aa = ya * xa;\r\n\r\n            ab = ya * xb + yb * xa + yb * xb;\r\n\r\n\r\n\r\n            /* split, so now lnz = a */\r\n\r\n            /*\r\n\r\n      tmp = aa * 1073741824.0;\r\n\r\n      lnza = aa + tmp - tmp;\r\n\r\n      lnzb = aa - lnza + ab;\r\n\r\n             */\r\n\r\n            lnza = aa + ab;\r\n\r\n            lnzb = -(lnza - aa - ab);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            /* High precision not required.  Eval Remez polynomial\r\n\r\n         using standard double precision */\r\n\r\n            lnza = -0.16624882440418567;\r\n\r\n            lnza = lnza * epsilon + 0.19999954120254515;\r\n\r\n            lnza = lnza * epsilon + -0.2499999997677497;\r\n\r\n            lnza = lnza * epsilon + 0.3333333333332802;\r\n\r\n            lnza = lnza * epsilon + -0.5;\r\n\r\n            lnza = lnza * epsilon + 1.0;\r\n\r\n            lnza *= epsilon;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Relative sizes:\r\n\r\n         * lnzb     [0, 2.33E-10]\r\n\r\n         * lnm[1]   [0, 1.17E-7]\r\n\r\n         * ln2B*exp [0, 1.12E-4]\r\n\r\n         * lnza      [0, 9.7E-4]\r\n\r\n         * lnm[0]   [0, 0.692]\r\n\r\n         * ln2A*exp [0, 709]\r\n\r\n         */\r\n\r\n\r\n\r\n        /* Compute the following sum:\r\n\r\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\r\n\r\n         */\r\n\r\n\r\n\r\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\r\n\r\n        double a = LN_2_A*exp;\r\n\r\n        double b = 0.0;\r\n\r\n        double c = a+lnm[0];\r\n\r\n        double d = -(c-a-lnm[0]);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        c = a + lnza;\r\n\r\n        d = -(c - a - lnza);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        c = a + LN_2_B*exp;\r\n\r\n        d = -(c - a - LN_2_B*exp);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        c = a + lnm[1];\r\n\r\n        d = -(c - a - lnm[1]);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        c = a + lnzb;\r\n\r\n        d = -(c - a - lnzb);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        if (hiPrec != null) \r\n\r\n        {\r\n\r\n            hiPrec[0] = a;\r\n\r\n            hiPrec[1] = b;\r\n\r\n        }\r\n\r\n\r\n\r\n        return a + b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes log(1 + x).\r\n\r\n     *\r\n\r\n     * @param x Number.\r\n\r\n     * @return {@code log(1 + x)}.\r\n\r\n     */\r\n\r\n    public static double log1p(const double& x) \r\n\r\n    {\r\n\r\n        if (x == -1) \r\n\r\n        {\r\n\r\n            return -INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x == INFINITY) \r\n\r\n        {\r\n\r\n            return INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x > 1e-6 ||\r\n\r\n            x < -1e-6) \r\n\r\n            {\r\n\r\n            const double xpa = 1 + x;\r\n\r\n            const double xpb = -(xpa - 1 - x);\r\n\r\n\r\n\r\n            const std::vector<double> hiPrec = std::vector<double>(2);\r\n\r\n            const double lores = log(xpa, hiPrec);\r\n\r\n            if (Double.std::isinfinite(lores)) { // Don't allow this to be converted to NaN\r\n\r\n                return lores;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Do a taylor series expansion around xpa:\r\n\r\n            //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\r\n\r\n            const double fx1 = xpb / xpa;\r\n\r\n            const double epsilon = 0.5 * fx1 + 1;\r\n\r\n            return epsilon * fx1 + hiPrec[1] + hiPrec[0];\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // Value is small |x| < 1e6, do a Taylor series centered on 1.\r\n\r\n            const double y = (x * F_1_3 - F_1_2) * x + 1;\r\n\r\n            return y * x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the base 10 logarithm.\r\n\r\n     * @param x a number\r\n\r\n     * @return log10(x)\r\n\r\n     */\r\n\r\n    public static double log10(const double& x) \r\n\r\n    {\r\n\r\n        const double hiPrec[] = std::vector<double>(2);\r\n\r\n\r\n\r\n        const double lores = log(x, hiPrec);\r\n\r\n        if (Double.std::isinfinite(lores)){ // don't allow this to be converted to NaN\r\n\r\n            return lores;\r\n\r\n        }\r\n\r\n\r\n\r\n        const double tmp = hiPrec[0] * HEX_40000000;\r\n\r\n        const double lna = hiPrec[0] + tmp - tmp;\r\n\r\n        const double lnb = hiPrec[0] - lna + hiPrec[1];\r\n\r\n\r\n\r\n        const double rln10a = 0.4342944622039795;\r\n\r\n        const double rln10b = 1.9699272335463627E-8;\r\n\r\n\r\n\r\n        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the <a href="http://mathworld.wolfram.com/Logarithm.html">\r\n\r\n     * logarithm</a> in a given base.\r\n\r\n     *\r\n\r\n     * Returns {@code NaN} if either argument is negative.\r\n\r\n     * If {@code base} is 0 and {@code x} is positive, 0 is returned.\r\n\r\n     * If {@code base} is positive and {@code x} is 0, * {@code -INFINITY} is returned.\r\n\r\n     * If both arguments are 0, the result is {@code NaN}.\r\n\r\n     *\r\n\r\n     * @param base Base of the logarithm, must be greater than 0.\r\n\r\n     * @param x Argument, must be greater than 0.\r\n\r\n     * @return the value of the logarithm, i.e. the number {@code y} such that\r\n\r\n     * <code>base<sup>y</sup> = x</code>.\r\n\r\n     */\r\n\r\n    public static double log(double base, double x) \r\n\r\n    {\r\n\r\n        return log(x) / log(base);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Power function.  Compute x^y.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @param y   a double\r\n\r\n     * @return double\r\n\r\n     */\r\n\r\n    public static double pow(const double& x, const double y) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (y == 0) \r\n\r\n        {\r\n\r\n            // y = -0 or y = +0\r\n\r\n            return 1.0;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            const long yBits        = Double.double_to_raw_long_bits(y);\r\n\r\n            const int  y_raw_exp      = static_cast<int>( ((yBits & MASK_DOUBLE_EXPONENT) >> 52);\r\n\r\n            const long y_raw_mantissa = yBits & MASK_DOUBLE_MANTISSA;\r\n\r\n            const long x_bits        = Double.double_to_raw_long_bits(x);\r\n\r\n            const int  x_raw_exp      = static_cast<int>( ((x_bits & MASK_DOUBLE_EXPONENT) >> 52);\r\n\r\n            const long x_raw_mantissa = x_bits & MASK_DOUBLE_MANTISSA;\r\n\r\n\r\n\r\n            if (y_raw_exp > 1085) \r\n\r\n            {\r\n\r\n                // y is either a very large integral value that does not fit in a long or it is a special number\r\n\r\n\r\n\r\n                if ((y_raw_exp == 2047 && y_raw_mantissa != 0) ||\r\n\r\n                    (x_raw_exp == 2047 && x_raw_mantissa != 0)) \r\n\r\n                    {\r\n\r\n                    // NaN\r\n\r\n                    return std::numeric_limits<double>::quiet_NaN();\r\n\r\n                }\r\n\r\nelse if (x_raw_exp == 1023 && x_raw_mantissa == 0) \r\n\r\n                {\r\n\r\n                    // x = -1.0 or x = +1.0\r\n\r\n                    if (y_raw_exp == 2047) \r\n\r\n                    {\r\n\r\n                        // y is infinite\r\n\r\n                        return std::numeric_limits<double>::quiet_NaN();\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // y is a large even integer\r\n\r\n                        return 1.0;\r\n\r\n                    }\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    // the absolute value of x is either greater or smaller than 1.0\r\n\r\n\r\n\r\n                    // if y_raw_exp == 2047 and mantissa is 0, y = -infinity or y = +infinity\r\n\r\n                    // if 1085 < y_raw_exp < 2047, y is simply a large number, however, due to limited\r\n\r\n                    // accuracy, at this magnitude it behaves just like infinity with regards to x\r\n\r\n                    if ((y > 0) ^ (x_raw_exp < 1023)) \r\n\r\n                    {\r\n\r\n                        // either y = +infinity (or large engouh) and abs(x) > 1.0\r\n\r\n                        // or     y = -infinity (or large engouh) and abs(x) < 1.0\r\n\r\n                        return INFINITY;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // either y = +infinity (or large engouh) and abs(x) < 1.0\r\n\r\n                        // or     y = -infinity (or large engouh) and abs(x) > 1.0\r\n\r\n                        return +0.0;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // y is a regular non-zero number\r\n\r\n\r\n\r\n                if (y_raw_exp >= 1023) \r\n\r\n                {\r\n\r\n                    // y may be an integral value, which should be handled specifically\r\n\r\n                    const long y_full_mantissa = IMPLICIT_HIGH_BIT | y_raw_mantissa;\r\n\r\n                    if (y_raw_exp < 1075) \r\n\r\n                    {\r\n\r\n                        // normal number with negative shift that may have a fractional part\r\n\r\n                        const long integralMask = (-1L) << (1075 - y_raw_exp);\r\n\r\n                        if ((y_full_mantissa & integralMask) == y_full_mantissa) \r\n\r\n                        {\r\n\r\n                            // all fractional bits are 0, the number is really integral\r\n\r\n                            const long l = y_full_mantissa >> (1075 - y_raw_exp);\r\n\r\n                            return std::pow(x, (y < 0) ? -l : l);\r\n\r\n                        }\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // normal number with positive shift, always an integral value\r\n\r\n                        // we know it fits in a primitive long because y_raw_exp > 1085 has been handled above\r\n\r\n                        const long l =  y_full_mantissa << (y_raw_exp - 1075);\r\n\r\n                        return std::pow(x, (y < 0) ? -l : l);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                // y is a non-integral value\r\n\r\n\r\n\r\n                if (x == 0) \r\n\r\n                {\r\n\r\n                    // x = -0 or x = +0\r\n\r\n                    // the integer powers have already been handled above\r\n\r\n                    return y < 0 ? INFINITY : +0.0;\r\n\r\n                }\r\n\r\nelse if (x_raw_exp == 2047) \r\n\r\n                {\r\n\r\n                    if (x_raw_mantissa == 0) \r\n\r\n                    {\r\n\r\n                        // x = -infinity or x = +infinity\r\n\r\n                        return (y < 0) ? +0.0 : INFINITY;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // NaN\r\n\r\n                        return std::numeric_limits<double>::quiet_NaN();\r\n\r\n                    }\r\n\r\n                }\r\n\r\nelse if (x < 0) \r\n\r\n                {\r\n\r\n                    // the integer powers have already been handled above\r\n\r\n                    return std::numeric_limits<double>::quiet_NaN();\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n\r\n\r\n                    // this is the general case, for regular fractional numbers x and y\r\n\r\n\r\n\r\n                    // Split y into ya and yb such that y = ya+yb\r\n\r\n                    const double tmp = y * HEX_40000000;\r\n\r\n                    const double ya = (y + tmp) - tmp;\r\n\r\n                    const double yb = y - ya;\r\n\r\n\r\n\r\n                    /* Compute ln(x) */\r\n\r\n                    const double lns[] = std::vector<double>(2);\r\n\r\n                    const double lores = log(x, lns);\r\n\r\n                    if (Double.std::isinfinite(lores)) { // don't allow this to be converted to NaN\r\n\r\n                        return lores;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    double lna = lns[0];\r\n\r\n                    double lnb = lns[1];\r\n\r\n\r\n\r\n                    /* resplit lns */\r\n\r\n                    const double tmp1 = lna * HEX_40000000;\r\n\r\n                    const double tmp2 = (lna + tmp1) - tmp1;\r\n\r\n                    lnb += lna - tmp2;\r\n\r\n                    lna = tmp2;\r\n\r\n\r\n\r\n                    // y*ln(x) = (aa+ab)\r\n\r\n                    const double& aa = lna * ya;\r\n\r\n                    const double& ab = lna * yb + lnb * ya + lnb * yb;\r\n\r\n\r\n\r\n                    lna = aa+ab;\r\n\r\n                    lnb = -(lna - aa - ab);\r\n\r\n\r\n\r\n                    double z = 1.0 / 120.0;\r\n\r\n                    z = z * lnb + (1.0 / 24.0);\r\n\r\n                    z = z * lnb + (1.0 / 6.0);\r\n\r\n                    z = z * lnb + 0.5;\r\n\r\n                    z = z * lnb + 1.0;\r\n\r\n                    z *= lnb;\r\n\r\n\r\n\r\n                    return exp(lna, z, null);\r\n\r\n\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Raise a double to an int power.\r\n\r\n     *\r\n\r\n     * @param d Number to raise.\r\n\r\n     * @param e Exponent.\r\n\r\n     * @return d<sup>e</sup>\r\n\r\n     */\r\n\r\n    public static double pow(double d, int e) \r\n\r\n    {\r\n\r\n        return pow(d, static_cast<long>( e);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Raise a double to a long power.\r\n\r\n     *\r\n\r\n     * @param d Number to raise.\r\n\r\n     * @param e Exponent.\r\n\r\n     * @return d<sup>e</sup>\r\n\r\n     */\r\n\r\n    public static double pow(double d, long e) \r\n\r\n    {\r\n\r\n        if (e == 0) \r\n\r\n        {\r\n\r\n            return 1.0;\r\n\r\n        }\r\n\r\nelse if (e > 0) \r\n\r\n        {\r\n\r\n            return Split(d).pow(e).full;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return Split(d).reciprocal().pow(-e).full;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Class operator on double numbers split into one 26 bits number and one 27 bits number. */\r\n\r\n    private static class Split \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Split version of NaN. */\r\n\r\n        public static const Split NAN = Split(Double.NaN, 0);\r\n\r\n\r\n\r\n        /** Split version of positive infinity. */\r\n\r\n        public static const Split POSITIVE_INFINITY = Split(INFINITY, 0);\r\n\r\n\r\n\r\n        /** Split version of negative infinity. */\r\n\r\n        public static const Split NEGATIVE_INFINITY = Split(-INFINITY, 0);\r\n\r\n\r\n\r\n        /** Full number. */\r\n\r\n        private const double full;\r\n\r\n\r\n\r\n        /** High order bits. */\r\n\r\n        private const double high;\r\n\r\n\r\n\r\n        /** Low order bits. */\r\n\r\n        private const double low;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param x number to split\r\n\r\n         */\r\n\r\n        Split(const double& x) \r\n\r\n        {\r\n\r\n            full = x;\r\n\r\n            high = Double.long_bits_to_double(Double.double_to_raw_long_bits(x) & ((-1L) << 27));\r\n\r\n            low  = x - high;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param high high order bits\r\n\r\n         * @param low low order bits\r\n\r\n         */\r\n\r\n        Split(const double high, const double low) \r\n\r\n        {\r\n\r\n            this(high == 0.0 ? (low == 0.0 && Double.double_to_raw_long_bits(high) == long.MIN_VALUE /* negative zero */ ? -0.0 : low) : high + low, high, low);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param full full number\r\n\r\n         * @param high high order bits\r\n\r\n         * @param low low order bits\r\n\r\n         */\r\n\r\n        Split(const double full, const double high, const double low) \r\n\r\n        {\r\n\r\n            this.full = full;\r\n\r\n            this.high = high;\r\n\r\n            this.low  = low;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Multiply the instance by another one.\r\n\r\n         * @param b other instance to multiply by\r\n\r\n         * @return product\r\n\r\n         */\r\n\r\n        public Split multiply(const Split b) \r\n\r\n        {\r\n\r\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\r\n\r\n            const Split  mulBasic  = Split(full * b.full);\r\n\r\n            const double mulError  = low * b.low - (((mulBasic.full - high * b.high) - low * b.high) - high * b.low);\r\n\r\n            return Split(mulBasic.high, mulBasic.low + mulError);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute the reciprocal of the instance.\r\n\r\n         * @return reciprocal of the instance\r\n\r\n         */\r\n\r\n        public Split reciprocal() \r\n\r\n        {\r\n\r\n\r\n\r\n            const double& approximateInv = 1.0 / full;\r\n\r\n            const Split  splitInv       = Split(approximateInv);\r\n\r\n\r\n\r\n            // if 1.0/d were computed perfectly, remultiplying it by d should give 1.0\r\n\r\n            // we want to estimate the error so we can fix the low order bits of approximateInvLow\r\n\r\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\r\n\r\n            const Split product = multiply(splitInv);\r\n\r\n            const double error  = (product.high - 1) + product.low;\r\n\r\n\r\n\r\n            // better accuracy estimate of reciprocal\r\n\r\n            return std::isnan(error) ? splitInv : Split(splitInv.high, splitInv.low - error / full);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Computes this^e.\r\n\r\n         * @param e exponent (beware, here it MUST be > 0; the only exclusion is long.MIN_VALUE)\r\n\r\n         * @return d^e, split in high and low bits\r\n\r\n         */\r\n\r\n        private Split pow(const long e) \r\n\r\n        {\r\n\r\n\r\n\r\n            // prepare result\r\n\r\n            Split result = Split(1);\r\n\r\n\r\n\r\n            // d^(2p)\r\n\r\n            Split d2p = Split(full, high, low);\r\n\r\n\r\n\r\n            for (long p = e; p != 0; p >>>= 1) \r\n\r\n            {\r\n\r\n\r\n\r\n                if ((p & 0x1) != 0) \r\n\r\n                {\r\n\r\n                    // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\r\n\r\n                    result = result.multiply(d2p);\r\n\r\n                }\r\n\r\n\r\n\r\n                // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\r\n\r\n                d2p = d2p.multiply(d2p);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            if (std::isnan(result.full)) \r\n\r\n            {\r\n\r\n                if (std::isnan(full)) \r\n\r\n                {\r\n\r\n                    return Split.NAN;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    // some intermediate numbers exceeded capacity, // and the low order bits became NaN (because infinity - infinity = NaN)\r\n\r\n                    if (std::abs(full) < 1) \r\n\r\n                    {\r\n\r\n                        return Split(std::copysign(0.0, full), 0.0);\r\n\r\n                    }\r\n\r\nelse if (full < 0 && (e & 0x1) == 1) \r\n\r\n                    {\r\n\r\n                        return Split.NEGATIVE_INFINITY;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        return Split.POSITIVE_INFINITY;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return result;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Computes sin(x) - x, where |x| < 1/16.\r\n\r\n     *  Use a Remez polynomial approximation.\r\n\r\n     *  @param x a number smaller than 1/16\r\n\r\n     *  @return sin(x) - x\r\n\r\n     */\r\n\r\n    private static double polySine(const double& x)\r\n\r\n    \r\n\r\n    {\r\n\r\n        double x2 = x*x;\r\n\r\n\r\n\r\n        double p = 2.7553817452272217E-6;\r\n\r\n        p = p * x2 + -1.9841269659586505E-4;\r\n\r\n        p = p * x2 + 0.008333333333329196;\r\n\r\n        p = p * x2 + -0.16666666666666666;\r\n\r\n        //p *= x2;\r\n\r\n        //p *= x;\r\n\r\n        p = p * x2 * x;\r\n\r\n\r\n\r\n        return p;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Computes cos(x) - 1, where |x| < 1/16.\r\n\r\n     *  Use a Remez polynomial approximation.\r\n\r\n     *  @param x a number smaller than 1/16\r\n\r\n     *  @return cos(x) - 1\r\n\r\n     */\r\n\r\n    private static double polyCosine(double x) \r\n\r\n    {\r\n\r\n        double x2 = x*x;\r\n\r\n\r\n\r\n        double p = 2.479773539153719E-5;\r\n\r\n        p = p * x2 + -0.0013888888689039883;\r\n\r\n        p = p * x2 + 0.041666666666621166;\r\n\r\n        p = p * x2 + -0.49999999999999994;\r\n\r\n        p *= x2;\r\n\r\n\r\n\r\n        return p;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Compute sine over the first quadrant (0 < x < pi/2).\r\n\r\n     *  Use combination of table lookup and rational polynomial expansion.\r\n\r\n     *  @param xa number from which sine is requested\r\n\r\n     *  @param xb extra bits for x (may be 0.0)\r\n\r\n     *  @return sin(xa + xb)\r\n\r\n     */\r\n\r\n    private static double sinQ(double xa, double xb) \r\n\r\n    {\r\n\r\n        int idx = static_cast<int>( ((xa * 8.0) + 0.5);\r\n\r\n        const double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\r\n\r\n\r\n\r\n        // Table lookups\r\n\r\n        const double sintA = SINE_TABLE_A[idx];\r\n\r\n        const double sintB = SINE_TABLE_B[idx];\r\n\r\n        const double costA = COSINE_TABLE_A[idx];\r\n\r\n        const double costB = COSINE_TABLE_B[idx];\r\n\r\n\r\n\r\n        // Polynomial eval of sin(epsilon), cos(epsilon)\r\n\r\n        double sinEpsA = epsilon;\r\n\r\n        double sin_eps_b = polySine(epsilon);\r\n\r\n        const double cos_eps_a = 1.0;\r\n\r\n        const double cos_eps_b = polyCosine(epsilon);\r\n\r\n\r\n\r\n        // Split epsilon   xa + xb = x\r\n\r\n        const double temp = sinEpsA * HEX_40000000;\r\n\r\n        double temp2 = (sinEpsA + temp) - temp;\r\n\r\n        sin_eps_b +=  sinEpsA - temp2;\r\n\r\n        sinEpsA = temp2;\r\n\r\n\r\n\r\n        /* Compute sin(x) by angle addition formula */\r\n\r\n        double result;\r\n\r\n\r\n\r\n        /* Compute the following sum:\r\n\r\n         *\r\n\r\n         * result = sintA + costA*sinEpsA + sintA*cos_eps_b + costA*sin_eps_b +\r\n\r\n         *          sintB + costB*sinEpsA + sintB*cos_eps_b + costB*sin_eps_b;\r\n\r\n         *\r\n\r\n         * Ranges of elements\r\n\r\n         *\r\n\r\n         * xxxtA   0            PI/2\r\n\r\n         * xxxtB   -1.5e-9      1.5e-9\r\n\r\n         * sinEpsA -0.0625      0.0625\r\n\r\n         * sin_eps_b -6e-11       6e-11\r\n\r\n         * cos_eps_a  1.0\r\n\r\n         * cos_eps_b  0           -0.0625\r\n\r\n         *\r\n\r\n         */\r\n\r\n\r\n\r\n        //result = sintA + costA*sinEpsA + sintA*cos_eps_b + costA*sin_eps_b +\r\n\r\n        //          sintB + costB*sinEpsA + sintB*cos_eps_b + costB*sin_eps_b;\r\n\r\n\r\n\r\n        //result = sintA + sintA*cos_eps_b + sintB + sintB * cos_eps_b;\r\n\r\n        //result += costA*sinEpsA + costA*sin_eps_b + costB*sinEpsA + costB * sin_eps_b;\r\n\r\n        double a = 0;\r\n\r\n        double b = 0;\r\n\r\n\r\n\r\n        double t = sintA;\r\n\r\n        double c = a + t;\r\n\r\n        double d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        t = costA * sinEpsA;\r\n\r\n        c = a + t;\r\n\r\n        d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        b = b + sintA * cos_eps_b + costA * sin_eps_b;\r\n\r\n        /*\r\n\r\n    t = sintA*cos_eps_b;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n\r\n\r\n    t = costA*sin_eps_b;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n         */\r\n\r\n\r\n\r\n        b = b + sintB + costB * sinEpsA + sintB * cos_eps_b + costB * sin_eps_b;\r\n\r\n        /*\r\n\r\n    t = sintB;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n\r\n\r\n    t = costB*sinEpsA;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n\r\n\r\n    t = sintB*cos_eps_b;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n\r\n\r\n    t = costB*sin_eps_b;\r\n\r\n    c = a + t;\r\n\r\n    d = -(c - a - t);\r\n\r\n    a = c;\r\n\r\n    b = b + d;\r\n\r\n         */\r\n\r\n\r\n\r\n        if (xb != 0.0) \r\n\r\n        {\r\n\r\n            t = ((costA + costB) * (cos_eps_a + cos_eps_b) -\r\n\r\n                 (sintA + sintB) * (sinEpsA + sin_eps_b)) * xb;  // approximate cosine*xb\r\n\r\n            c = a + t;\r\n\r\n            d = -(c - a - t);\r\n\r\n            a = c;\r\n\r\n            b += d;\r\n\r\n        }\r\n\r\n\r\n\r\n        result = a + b;\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute cosine in the first quadrant by subtracting input from PI/2 and\r\n\r\n     * then calling sinQ.  This is more accurate as the input approaches PI/2.\r\n\r\n     *  @param xa number from which cosine is requested\r\n\r\n     *  @param xb extra bits for x (may be 0.0)\r\n\r\n     *  @return cos(xa + xb)\r\n\r\n     */\r\n\r\n    private static double cosQ(double xa, double xb) \r\n\r\n    {\r\n\r\n        const double pi2a = 1.5707963267948966;\r\n\r\n        const double pi2b = 6.123233995736766E-17;\r\n\r\n\r\n\r\n        const double& a = pi2a - xa;\r\n\r\n        double b = -(a - pi2a + xa);\r\n\r\n        b += pi2b - xb;\r\n\r\n\r\n\r\n        return sinQ(a, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Compute tangent (or cotangent) over the first quadrant.   0 < x < pi/2\r\n\r\n     *  Use combination of table lookup and rational polynomial expansion.\r\n\r\n     *  @param xa number from which sine is requested\r\n\r\n     *  @param xb extra bits for x (may be 0.0)\r\n\r\n     *  @param cotanFlag if true, compute the cotangent instead of the tangent\r\n\r\n     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)\r\n\r\n     */\r\n\r\n    private static double tanQ(double xa, double xb, bool cotanFlag) \r\n\r\n    {\r\n\r\n\r\n\r\n        int idx = static_cast<int>( ((xa * 8.0) + 0.5);\r\n\r\n        const double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\r\n\r\n\r\n\r\n        // Table lookups\r\n\r\n        const double sintA = SINE_TABLE_A[idx];\r\n\r\n        const double sintB = SINE_TABLE_B[idx];\r\n\r\n        const double costA = COSINE_TABLE_A[idx];\r\n\r\n        const double costB = COSINE_TABLE_B[idx];\r\n\r\n\r\n\r\n        // Polynomial eval of sin(epsilon), cos(epsilon)\r\n\r\n        double sinEpsA = epsilon;\r\n\r\n        double sin_eps_b = polySine(epsilon);\r\n\r\n        const double cos_eps_a = 1.0;\r\n\r\n        const double cos_eps_b = polyCosine(epsilon);\r\n\r\n\r\n\r\n        // Split epsilon   xa + xb = x\r\n\r\n        double temp = sinEpsA * HEX_40000000;\r\n\r\n        double temp2 = (sinEpsA + temp) - temp;\r\n\r\n        sin_eps_b +=  sinEpsA - temp2;\r\n\r\n        sinEpsA = temp2;\r\n\r\n\r\n\r\n        /* Compute sin(x) by angle addition formula */\r\n\r\n\r\n\r\n        /* Compute the following sum:\r\n\r\n         *\r\n\r\n         * result = sintA + costA*sinEpsA + sintA*cos_eps_b + costA*sin_eps_b +\r\n\r\n         *          sintB + costB*sinEpsA + sintB*cos_eps_b + costB*sin_eps_b;\r\n\r\n         *\r\n\r\n         * Ranges of elements\r\n\r\n         *\r\n\r\n         * xxxtA   0            PI/2\r\n\r\n         * xxxtB   -1.5e-9      1.5e-9\r\n\r\n         * sinEpsA -0.0625      0.0625\r\n\r\n         * sin_eps_b -6e-11       6e-11\r\n\r\n         * cos_eps_a  1.0\r\n\r\n         * cos_eps_b  0           -0.0625\r\n\r\n         *\r\n\r\n         */\r\n\r\n\r\n\r\n        //result = sintA + costA*sinEpsA + sintA*cos_eps_b + costA*sin_eps_b +\r\n\r\n        //          sintB + costB*sinEpsA + sintB*cos_eps_b + costB*sin_eps_b;\r\n\r\n\r\n\r\n        //result = sintA + sintA*cos_eps_b + sintB + sintB * cos_eps_b;\r\n\r\n        //result += costA*sinEpsA + costA*sin_eps_b + costB*sinEpsA + costB * sin_eps_b;\r\n\r\n        double a = 0;\r\n\r\n        double b = 0;\r\n\r\n\r\n\r\n        // Compute sine\r\n\r\n        double t = sintA;\r\n\r\n        double c = a + t;\r\n\r\n        double d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        t = costA*sinEpsA;\r\n\r\n        c = a + t;\r\n\r\n        d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        b += sintA*cos_eps_b + costA*sin_eps_b;\r\n\r\n        b += sintB + costB*sinEpsA + sintB*cos_eps_b + costB*sin_eps_b;\r\n\r\n\r\n\r\n        double sina = a + b;\r\n\r\n        double sinb = -(sina - a - b);\r\n\r\n\r\n\r\n        // Compute cosine\r\n\r\n\r\n\r\n        a = 0.0;\r\n\r\n        b = 0.0;\r\n\r\n\r\n\r\n        t = costA*cos_eps_a;\r\n\r\n        c = a + t;\r\n\r\n        d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        t = -sintA*sinEpsA;\r\n\r\n        c = a + t;\r\n\r\n        d = -(c - a - t);\r\n\r\n        a = c;\r\n\r\n        b += d;\r\n\r\n\r\n\r\n        b += costB*cos_eps_a + costA*cos_eps_b + costB*cos_eps_b;\r\n\r\n        b -= sintB*sinEpsA + sintA*sin_eps_b + sintB*sin_eps_b;\r\n\r\n\r\n\r\n        double cosa = a + b;\r\n\r\n        double cosb = -(cosa - a - b);\r\n\r\n\r\n\r\n        if (cotanFlag) \r\n\r\n        {\r\n\r\n            double tmp;\r\n\r\n            tmp = cosa; cosa = sina; sina = tmp;\r\n\r\n            tmp = cosb; cosb = sinb; sinb = tmp;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\r\n\r\n        /*\r\n\r\n    double est = (sina+sinb)/(cosa+cosb);\r\n\r\n    double err = (sina - cosa*est) + (sinb - cosb*est);\r\n\r\n    est += err/(cosa+cosb);\r\n\r\n    err = (sina - cosa*est) + (sinb - cosb*est);\r\n\r\n         */\r\n\r\n\r\n\r\n        // f(x) = 1/x,   f'(x) = -1/x^2\r\n\r\n\r\n\r\n        double est = sina/cosa;\r\n\r\n\r\n\r\n        /* Split the estimate to get more accurate read on division rounding */\r\n\r\n        temp = est * HEX_40000000;\r\n\r\n        double esta = (est + temp) - temp;\r\n\r\n        double estb =  est - esta;\r\n\r\n\r\n\r\n        temp = cosa * HEX_40000000;\r\n\r\n        double cosaa = (cosa + temp) - temp;\r\n\r\n        double cosab =  cosa - cosaa;\r\n\r\n\r\n\r\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\r\n\r\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\r\n\r\n        err += sinb/cosa;                     // Change in est due to sinb\r\n\r\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\r\n\r\n\r\n\r\n        if (xb != 0.0) \r\n\r\n        {\r\n\r\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\r\n\r\n            // Approximate impact of xb\r\n\r\n            double xbadj = xb + est*est*xb;\r\n\r\n            if (cotanFlag) \r\n\r\n            {\r\n\r\n                xbadj = -xbadj;\r\n\r\n            }\r\n\r\n\r\n\r\n            err += xbadj;\r\n\r\n        }\r\n\r\n\r\n\r\n        return est+err;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Reduce the input argument using the Payne and Hanek method.\r\n\r\n     *  This is good for all inputs 0.0 < x < inf\r\n\r\n     *  Output is remainder after dividing by PI/2\r\n\r\n     *  The result array should contain 3 numbers.\r\n\r\n     *  result[0] is the integer portion, so mod 4 this gives the quadrant.\r\n\r\n     *  result[1] is the upper bits of the remainder\r\n\r\n     *  result[2] is the lower bits of the remainder\r\n\r\n     *\r\n\r\n     * @param x number to reduce\r\n\r\n     * @param result placeholder where to put the result\r\n\r\n     */\r\n\r\n    private static void reducePayneHanek(const double& x, double result[])\r\n\r\n    \r\n\r\n    {\r\n\r\n        /* Convert input double to bits */\r\n\r\n        long inbits = Double.double_to_raw_long_bits(x);\r\n\r\n        int exponent = static_cast<int>( ((inbits >> 52) & 0x7ff) - 1023;\r\n\r\n\r\n\r\n        /* Convert to fixed point representation */\r\n\r\n        inbits &= 0x000fffffffffffffL;\r\n\r\n        inbits |= 0x0010000000000000L;\r\n\r\n\r\n\r\n        /* Normalize input to be between 0.5 and 1.0 */\r\n\r\n        exponent++;\r\n\r\n        inbits <<= 11;\r\n\r\n\r\n\r\n        /* Based on the exponent, get a shifted copy of recip2pi */\r\n\r\n        long shpi0;\r\n\r\n        long shpiA;\r\n\r\n        long shpiB;\r\n\r\n        int idx = exponent >> 6;\r\n\r\n        int shift = exponent - (idx << 6);\r\n\r\n\r\n\r\n        if (shift != 0) \r\n\r\n        {\r\n\r\n            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\r\n\r\n            shpi0 |= RECIP_2PI[idx] >>> (64-shift);\r\n\r\n            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\r\n\r\n            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\r\n\r\n            shpiA = RECIP_2PI[idx];\r\n\r\n            shpiB = RECIP_2PI[idx+1];\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Multiply input by shpiA */\r\n\r\n        long a = inbits >>> 32;\r\n\r\n        long b = inbits & 0xffffffffL;\r\n\r\n\r\n\r\n        long c = shpiA >>> 32;\r\n\r\n        long d = shpiA & 0xffffffffL;\r\n\r\n\r\n\r\n        long ac = a * c;\r\n\r\n        long bd = b * d;\r\n\r\n        long bc = b * c;\r\n\r\n        long ad = a * d;\r\n\r\n\r\n\r\n        long prodB = bd + (ad << 32);\r\n\r\n        long prodA = ac + (ad >>> 32);\r\n\r\n\r\n\r\n        bool bita = (bd & 0x8000000000000000L) != 0;\r\n\r\n        bool bitb = (ad & 0x80000000L ) != 0;\r\n\r\n        bool bitsum = (prodB & 0x8000000000000000L) != 0;\r\n\r\n\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prodA++;\r\n\r\n        }\r\n\r\n\r\n\r\n        bita = (prodB & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (bc & 0x80000000L ) != 0;\r\n\r\n\r\n\r\n        prodB += bc << 32;\r\n\r\n        prodA += bc >>> 32;\r\n\r\n\r\n\r\n        bitsum = (prodB & 0x8000000000000000L) != 0;\r\n\r\n\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prodA++;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Multiply input by shpiB */\r\n\r\n        c = shpiB >>> 32;\r\n\r\n        d = shpiB & 0xffffffffL;\r\n\r\n        ac = a * c;\r\n\r\n        bc = b * c;\r\n\r\n        ad = a * d;\r\n\r\n\r\n\r\n        /* Collect terms */\r\n\r\n        ac += (bc + ad) >>> 32;\r\n\r\n\r\n\r\n        bita = (prodB & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (ac & 0x8000000000000000L ) != 0;\r\n\r\n        prodB += ac;\r\n\r\n        bitsum = (prodB & 0x8000000000000000L) != 0;\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prodA++;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Multiply by shpi0 */\r\n\r\n        c = shpi0 >>> 32;\r\n\r\n        d = shpi0 & 0xffffffffL;\r\n\r\n\r\n\r\n        bd = b * d;\r\n\r\n        bc = b * c;\r\n\r\n        ad = a * d;\r\n\r\n\r\n\r\n        prodA += bd + ((bc + ad) << 32);\r\n\r\n\r\n\r\n        /*\r\n\r\n         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\r\n\r\n         * PI/2, so use the following steps:\r\n\r\n         * 1.) multiply by 4.\r\n\r\n         * 2.) do a fixed point muliply by PI/4.\r\n\r\n         * 3.) Convert to floating point.\r\n\r\n         * 4.) Multiply by 2\r\n\r\n         */\r\n\r\n\r\n\r\n        /* This identifies the quadrant */\r\n\r\n        int intPart = static_cast<int>((prodA >>> 62);\r\n\r\n\r\n\r\n        /* Multiply by 4 */\r\n\r\n        prodA <<= 2;\r\n\r\n        prodA |= prodB >>> 62;\r\n\r\n        prodB <<= 2;\r\n\r\n\r\n\r\n        /* Multiply by PI/4 */\r\n\r\n        a = prodA >>> 32;\r\n\r\n        b = prodA & 0xffffffffL;\r\n\r\n\r\n\r\n        c = PI_O_4_BITS[0] >>> 32;\r\n\r\n        d = PI_O_4_BITS[0] & 0xffffffffL;\r\n\r\n\r\n\r\n        ac = a * c;\r\n\r\n        bd = b * d;\r\n\r\n        bc = b * c;\r\n\r\n        ad = a * d;\r\n\r\n\r\n\r\n        long prod2B = bd + (ad << 32);\r\n\r\n        long prod2A = ac + (ad >>> 32);\r\n\r\n\r\n\r\n        bita = (bd & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (ad & 0x80000000L ) != 0;\r\n\r\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prod2A++;\r\n\r\n        }\r\n\r\n\r\n\r\n        bita = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (bc & 0x80000000L ) != 0;\r\n\r\n\r\n\r\n        prod2B += bc << 32;\r\n\r\n        prod2A += bc >>> 32;\r\n\r\n\r\n\r\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prod2A++;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Multiply input by pio4bits[1] */\r\n\r\n        c = PI_O_4_BITS[1] >>> 32;\r\n\r\n        d = PI_O_4_BITS[1] & 0xffffffffL;\r\n\r\n        ac = a * c;\r\n\r\n        bc = b * c;\r\n\r\n        ad = a * d;\r\n\r\n\r\n\r\n        /* Collect terms */\r\n\r\n        ac += (bc + ad) >>> 32;\r\n\r\n\r\n\r\n        bita = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (ac & 0x8000000000000000L ) != 0;\r\n\r\n        prod2B += ac;\r\n\r\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prod2A++;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Multiply inputB by pio4bits[0] */\r\n\r\n        a = prodB >>> 32;\r\n\r\n        b = prodB & 0xffffffffL;\r\n\r\n        c = PI_O_4_BITS[0] >>> 32;\r\n\r\n        d = PI_O_4_BITS[0] & 0xffffffffL;\r\n\r\n        ac = a * c;\r\n\r\n        bc = b * c;\r\n\r\n        ad = a * d;\r\n\r\n\r\n\r\n        /* Collect terms */\r\n\r\n        ac += (bc + ad) >>> 32;\r\n\r\n\r\n\r\n        bita = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n        bitb = (ac & 0x8000000000000000L ) != 0;\r\n\r\n        prod2B += ac;\r\n\r\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\r\n\r\n        /* Carry */\r\n\r\n        if ( (bita && bitb) ||\r\n\r\n                ((bita || bitb) && !bitsum) ) \r\n\r\n                {\r\n\r\n            prod2A++;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Convert to double */\r\n\r\n        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\r\n\r\n        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\r\n\r\n\r\n\r\n        double sumA = tmpA + tmpB;\r\n\r\n        double sum_b = -(sumA - tmpA - tmpB);\r\n\r\n\r\n\r\n        /* Multiply by PI/2 and return */\r\n\r\n        result[0] = intPart;\r\n\r\n        result[1] = sumA * 2.0;\r\n\r\n        result[2] = sum_b * 2.0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Sine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return sin(x)\r\n\r\n     */\r\n\r\n    public static double sin(double x) \r\n\r\n    {\r\n\r\n        bool negative = false;\r\n\r\n        int quadrant = 0;\r\n\r\n        double xa;\r\n\r\n        double xb = 0.0;\r\n\r\n\r\n\r\n        /* Take absolute value of the input */\r\n\r\n        xa = x;\r\n\r\n        if (x < 0) \r\n\r\n        {\r\n\r\n            negative = true;\r\n\r\n            xa = -xa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Check for zero and negative zero */\r\n\r\n        if (xa == 0.0) \r\n\r\n        {\r\n\r\n            long bits = Double.double_to_raw_long_bits(x);\r\n\r\n            if (bits < 0) \r\n\r\n            {\r\n\r\n                return -0.0;\r\n\r\n            }\r\n\r\n            return 0.0;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa != xa || xa == INFINITY) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Perform any argument reduction */\r\n\r\n        if (xa > 3294198.0) \r\n\r\n        {\r\n\r\n            // PI * (2**20)\r\n\r\n            // Argument too big for CodyWaite reduction.  Must use\r\n\r\n            // PayneHanek.\r\n\r\n            double reduceResults[] = std::vector<double>(3];\r\n\r\n            reducePayneHanek(xa, reduceResults);\r\n\r\n            quadrant = (static_cast<int>( reduceResults[0]) & 3;\r\n\r\n            xa = reduceResults[1];\r\n\r\n            xb = reduceResults[2];\r\n\r\n        }\r\n\r\nelse if (xa > 1.5707963267948966) \r\n\r\n        {\r\n\r\n            const CodyWaite cw = CodyWaite(xa);\r\n\r\n            quadrant = cw.get_k() & 3;\r\n\r\n            xa = cw.get_remA();\r\n\r\n            xb = cw.get_remB();\r\n\r\n        }\r\n\r\n\r\n\r\n        if (negative) \r\n\r\n        {\r\n\r\n            quadrant ^= 2;  // Flip bit 1\r\n\r\n        }\r\n\r\n\r\n\r\n        switch (quadrant) \r\n\r\n        {\r\n\r\n            case 0:\r\n\r\n                return sinQ(xa, xb);\r\n\r\n            case 1:\r\n\r\n                return cosQ(xa, xb);\r\n\r\n            case 2:\r\n\r\n                return -sinQ(xa, xb);\r\n\r\n            case 3:\r\n\r\n                return -cosQ(xa, xb);\r\n\r\n            default:\r\n\r\n                return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return cos(x)\r\n\r\n     */\r\n\r\n    public static double cos(double x) \r\n\r\n    {\r\n\r\n        int quadrant = 0;\r\n\r\n\r\n\r\n        /* Take absolute value of the input */\r\n\r\n        double xa = x;\r\n\r\n        if (x < 0) \r\n\r\n        {\r\n\r\n            xa = -xa;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa != xa || xa == INFINITY) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Perform any argument reduction */\r\n\r\n        double xb = 0;\r\n\r\n        if (xa > 3294198.0) \r\n\r\n        {\r\n\r\n            // PI * (2**20)\r\n\r\n            // Argument too big for CodyWaite reduction.  Must use\r\n\r\n            // PayneHanek.\r\n\r\n            double reduceResults[] = std::vector<double>(3];\r\n\r\n            reducePayneHanek(xa, reduceResults);\r\n\r\n            quadrant = (static_cast<int>( reduceResults[0]) & 3;\r\n\r\n            xa = reduceResults[1];\r\n\r\n            xb = reduceResults[2];\r\n\r\n        }\r\n\r\nelse if (xa > 1.5707963267948966) \r\n\r\n        {\r\n\r\n            const CodyWaite cw = CodyWaite(xa);\r\n\r\n            quadrant = cw.get_k() & 3;\r\n\r\n            xa = cw.get_remA();\r\n\r\n            xb = cw.get_remB();\r\n\r\n        }\r\n\r\n\r\n\r\n        //if (negative)\r\n\r\n        //  quadrant = (quadrant + 2) % 4;\r\n\r\n\r\n\r\n        switch (quadrant) \r\n\r\n        {\r\n\r\n            case 0:\r\n\r\n                return cosQ(xa, xb);\r\n\r\n            case 1:\r\n\r\n                return -sinQ(xa, xb);\r\n\r\n            case 2:\r\n\r\n                return -cosQ(xa, xb);\r\n\r\n            case 3:\r\n\r\n                return sinQ(xa, xb);\r\n\r\n            default:\r\n\r\n                return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Combined Sine and Cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return [sin(x), cos(x)]\r\n\r\n     */\r\n\r\n    public static Sin_Cos sin_cos(double x) \r\n\r\n    {\r\n\r\n        bool negative = false;\r\n\r\n        int quadrant = 0;\r\n\r\n        double xa;\r\n\r\n        double xb = 0.0;\r\n\r\n\r\n\r\n        /* Take absolute value of the input */\r\n\r\n        xa = x;\r\n\r\n        if (x < 0) \r\n\r\n        {\r\n\r\n            negative = true;\r\n\r\n            xa = -xa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Check for zero and negative zero */\r\n\r\n        if (xa == 0.0) \r\n\r\n        {\r\n\r\n            long bits = Double.double_to_raw_long_bits(x);\r\n\r\n            if (bits < 0) \r\n\r\n            {\r\n\r\n                return Sin_Cos(-0.0, 1.0);\r\n\r\n            }\r\n\r\n            return Sin_Cos(0.0, 1.0);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa != xa || xa == INFINITY) \r\n\r\n        {\r\n\r\n            return Sin_Cos(Double.NaN,NAN);\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Perform any argument reduction */\r\n\r\n        if (xa > 3294198.0) \r\n\r\n        {\r\n\r\n            // PI * (2**20)\r\n\r\n            // Argument too big for CodyWaite reduction.  Must use\r\n\r\n            // PayneHanek.\r\n\r\n            double reduceResults[] = std::vector<double>(3];\r\n\r\n            reducePayneHanek(xa, reduceResults);\r\n\r\n            quadrant = (static_cast<int>( reduceResults[0]) & 3;\r\n\r\n            xa = reduceResults[1];\r\n\r\n            xb = reduceResults[2];\r\n\r\n        }\r\n\r\nelse if (xa > 1.5707963267948966) \r\n\r\n        {\r\n\r\n            const CodyWaite cw = CodyWaite(xa);\r\n\r\n            quadrant = cw.get_k() & 3;\r\n\r\n            xa = cw.get_remA();\r\n\r\n            xb = cw.get_remB();\r\n\r\n        }\r\n\r\n\r\n\r\n        switch (quadrant) \r\n\r\n        {\r\n\r\n            case 0:\r\n\r\n                return Sin_Cos(negative ? -sinQ(xa, xb) :  sinQ(xa, xb),  cosQ(xa, xb));\r\n\r\n            case 1:\r\n\r\n                return Sin_Cos(negative ? -cosQ(xa, xb) :  cosQ(xa, xb), -sinQ(xa, xb));\r\n\r\n            case 2:\r\n\r\n                return Sin_Cos(negative ?  sinQ(xa, xb) : -sinQ(xa, xb), -cosQ(xa, xb));\r\n\r\n            case 3:\r\n\r\n                return Sin_Cos(negative ?  cosQ(xa, xb) : -cosQ(xa, xb),  sinQ(xa, xb));\r\n\r\n            default:\r\n\r\n                return Sin_Cos(Double.NaN,NAN);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Combined Sine and Cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return [sin(x), cos(x)]\r\n\r\n     * @since 1.4\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  Field_Sin_Cos<T> sin_cos(T x) \r\n\r\n    {\r\n\r\n        return x.sin_cos();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Tangent function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return tan(x)\r\n\r\n     */\r\n\r\n    public static double tan(double x) \r\n\r\n    {\r\n\r\n        bool negative = false;\r\n\r\n        int quadrant = 0;\r\n\r\n\r\n\r\n        /* Take absolute value of the input */\r\n\r\n        double xa = x;\r\n\r\n        if (x < 0) \r\n\r\n        {\r\n\r\n            negative = true;\r\n\r\n            xa = -xa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Check for zero and negative zero */\r\n\r\n        if (xa == 0.0) \r\n\r\n        {\r\n\r\n            long bits = Double.double_to_raw_long_bits(x);\r\n\r\n            if (bits < 0) \r\n\r\n            {\r\n\r\n                return -0.0;\r\n\r\n            }\r\n\r\n            return 0.0;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa != xa || xa == INFINITY) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Perform any argument reduction */\r\n\r\n        double xb = 0;\r\n\r\n        if (xa > 3294198.0) \r\n\r\n        {\r\n\r\n            // PI * (2**20)\r\n\r\n            // Argument too big for CodyWaite reduction.  Must use\r\n\r\n            // PayneHanek.\r\n\r\n            double reduceResults[] = std::vector<double>(3];\r\n\r\n            reducePayneHanek(xa, reduceResults);\r\n\r\n            quadrant = (static_cast<int>( reduceResults[0]) & 3;\r\n\r\n            xa = reduceResults[1];\r\n\r\n            xb = reduceResults[2];\r\n\r\n        }\r\n\r\nelse if (xa > 1.5707963267948966) \r\n\r\n        {\r\n\r\n            const CodyWaite cw = CodyWaite(xa);\r\n\r\n            quadrant = cw.get_k() & 3;\r\n\r\n            xa = cw.get_remA();\r\n\r\n            xb = cw.get_remB();\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa > 1.5) \r\n\r\n        {\r\n\r\n            // Accuracy suffers between 1.5 and PI/2\r\n\r\n            const double pi2a = 1.5707963267948966;\r\n\r\n            const double pi2b = 6.123233995736766E-17;\r\n\r\n\r\n\r\n            const double& a = pi2a - xa;\r\n\r\n            double b = -(a - pi2a + xa);\r\n\r\n            b += pi2b - xb;\r\n\r\n\r\n\r\n            xa = a + b;\r\n\r\n            xb = -(xa - a - b);\r\n\r\n            quadrant ^= 1;\r\n\r\n            negative ^= true;\r\n\r\n        }\r\n\r\n\r\n\r\n        double result;\r\n\r\n        if ((quadrant & 1) == 0) \r\n\r\n        {\r\n\r\n            result = tanQ(xa, xb, false);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            result = -tanQ(xa, xb, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (negative) \r\n\r\n        {\r\n\r\n            result = -result;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Arctangent function\r\n\r\n     *  @param x a number\r\n\r\n     *  @return atan(x)\r\n\r\n     */\r\n\r\n    public static double atan(double x) \r\n\r\n    {\r\n\r\n        return atan(x, 0.0, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Internal helper function to compute arctangent.\r\n\r\n     * @param xa number from which arctangent is requested\r\n\r\n     * @param xb extra bits for x (may be 0.0)\r\n\r\n     * @param left_plane if true, result angle must be put in the left half plane\r\n\r\n     * @return atan(xa + xb) (or angle shifted by {@code PI} if left_plane is true)\r\n\r\n     */\r\n\r\n    private static double atan(double xa, double xb, bool left_plane) \r\n\r\n    {\r\n\r\n        if (xa == 0.0) { // Matches +/- 0.0; return correct sign\r\n\r\n            return left_plane ? copy_sign(std::numbers::pi, xa) : xa;\r\n\r\n        }\r\n\r\n\r\n\r\n        const bool negate;\r\n\r\n        if (xa < 0) \r\n\r\n        {\r\n\r\n            // negative\r\n\r\n            xa = -xa;\r\n\r\n            xb = -xb;\r\n\r\n            negate = true;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            negate = false;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (xa > 1.633123935319537E16) { // Very large input\r\n\r\n            return (negate ^ left_plane) ? (-std::numbers::pi * F_1_2) : (std::numbers::pi * F_1_2);\r\n\r\n        }\r\n\r\n\r\n\r\n        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\r\n\r\n        const int idx;\r\n\r\n        if (xa < 1) \r\n\r\n        {\r\n\r\n            idx = static_cast<int>( (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const double one_over_xa = 1 / xa;\r\n\r\n            idx = static_cast<int>( (-((-1.7168146928204136 * one_over_xa * one_over_xa + 8.0) * one_over_xa) + 13.07);\r\n\r\n        }\r\n\r\n\r\n\r\n        const double ttA = TANGENT_TABLE_A[idx];\r\n\r\n        const double ttB = TANGENT_TABLE_B[idx];\r\n\r\n\r\n\r\n        double epsA = xa - ttA;\r\n\r\n        double epsB = -(epsA - xa + ttA);\r\n\r\n        epsB += xb - ttB;\r\n\r\n\r\n\r\n        double temp = epsA + epsB;\r\n\r\n        epsB = -(temp - epsA - epsB);\r\n\r\n        epsA = temp;\r\n\r\n\r\n\r\n        /* Compute eps = eps / (1.0 + xa*tangent) */\r\n\r\n        temp = xa * HEX_40000000;\r\n\r\n        double ya = xa + temp - temp;\r\n\r\n        double yb = xb + xa - ya;\r\n\r\n        xa = ya;\r\n\r\n        xb += yb;\r\n\r\n\r\n\r\n        //if (idx > 8 || idx == 0)\r\n\r\n        if (idx == 0) \r\n\r\n        {\r\n\r\n            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\r\n\r\n            //double denom = 1.0 / (1.0 + xa*tangent_Table_A[idx] + xb*tangent_Table_A[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\r\n\r\n            const double denom = 1.0/ (1.0+ (xa + xb) * (ttA + ttB));\r\n\r\n            //double denom = 1.0 / (1.0 + xa*tangent_Table_A[idx]);\r\n\r\n            ya = epsA * denom;\r\n\r\n            yb = epsB * denom;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            double temp2 = xa * ttA;\r\n\r\n            double za = 1.0+ temp2;\r\n\r\n            double zb = -(za - 1.0- temp2);\r\n\r\n            temp2 = xb * ttA + xa * ttB;\r\n\r\n            temp = za + temp2;\r\n\r\n            zb += -(temp - za - temp2);\r\n\r\n            za = temp;\r\n\r\n\r\n\r\n            zb += xb * ttB;\r\n\r\n            ya = epsA / za;\r\n\r\n\r\n\r\n            temp = ya * HEX_40000000;\r\n\r\n            const double yaa = (ya + temp) - temp;\r\n\r\n            const double yab = ya - yaa;\r\n\r\n\r\n\r\n            temp = za * HEX_40000000;\r\n\r\n            const double zaa = (za + temp) - temp;\r\n\r\n            const double zab = za - zaa;\r\n\r\n\r\n\r\n            /* Correct for rounding in division */\r\n\r\n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\r\n\r\n\r\n\r\n            yb += -epsA * zb / za / za;\r\n\r\n            yb += epsB / za;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        epsA = ya;\r\n\r\n        epsB = yb;\r\n\r\n\r\n\r\n        /* Evaluate polynomial */\r\n\r\n        const double epsA2 = epsA * epsA;\r\n\r\n\r\n\r\n        /*\r\n\r\n    yb = -0.09001346640161823;\r\n\r\n    yb = yb * epsA2 + 0.11110718400605211;\r\n\r\n    yb = yb * epsA2 + -0.1428571349122913;\r\n\r\n    yb = yb * epsA2 + 0.19999999999273194;\r\n\r\n    yb = yb * epsA2 + -0.33333333333333093;\r\n\r\n    yb = yb * epsA2 * epsA;\r\n\r\n         */\r\n\r\n\r\n\r\n        yb = 0.07490822288864472;\r\n\r\n        yb = yb * epsA2 - 0.09088450866185192;\r\n\r\n        yb = yb * epsA2 + 0.11111095942313305;\r\n\r\n        yb = yb * epsA2 - 0.1428571423679182;\r\n\r\n        yb = yb * epsA2 + 0.19999999999923582;\r\n\r\n        yb = yb * epsA2 - 0.33333333333333287;\r\n\r\n        yb = yb * epsA2 * epsA;\r\n\r\n\r\n\r\n\r\n\r\n        ya = epsA;\r\n\r\n\r\n\r\n        temp = ya + yb;\r\n\r\n        yb = -(temp - ya - yb);\r\n\r\n        ya = temp;\r\n\r\n\r\n\r\n        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\r\n\r\n        yb += epsB / (1.0+ epsA * epsA);\r\n\r\n\r\n\r\n        const double eighths = EIGHTHS[idx];\r\n\r\n\r\n\r\n        //result = yb + eighths[idx] + ya;\r\n\r\n        double za = eighths + ya;\r\n\r\n        double zb = -(za - eighths - ya);\r\n\r\n        temp = za + yb;\r\n\r\n        zb += -(temp - za - yb);\r\n\r\n        za = temp;\r\n\r\n\r\n\r\n        double result = za + zb;\r\n\r\n\r\n\r\n        if (left_plane) \r\n\r\n        {\r\n\r\n            // Result is in the left plane\r\n\r\n            const double resultb = -(result - za - zb);\r\n\r\n            const double pia = 1.5707963267948966 * 2;\r\n\r\n            const double pib = 6.123233995736766E-17 * 2;\r\n\r\n\r\n\r\n            za = pia - result;\r\n\r\n            zb = -(za - pia + result);\r\n\r\n            zb += pib - resultb;\r\n\r\n\r\n\r\n            result = za + zb;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        if (negate ^ left_plane) \r\n\r\n        {\r\n\r\n            result = -result;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Two arguments arctangent function\r\n\r\n     * @param y ordinate\r\n\r\n     * @param x abscissa\r\n\r\n     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\r\n\r\n     */\r\n\r\n    public static double atan2(const double& y, double x) \r\n\r\n    {\r\n\r\n        if (std::isnan(x) || std::isnan(y)) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n\r\n\r\n        if (y == 0) \r\n\r\n        {\r\n\r\n            const double result = x * y;\r\n\r\n            const double invx = 1.0/ x;\r\n\r\n\r\n\r\n            if (invx == 0) { // X is infinite\r\n\r\n                if (x > 0) \r\n\r\n                {\r\n\r\n                    return y; // return +/- 0.0\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    return copy_sign(std::numbers::pi, y);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            if (x < 0 || invx < 0) \r\n\r\n            {\r\n\r\n                return copy_sign(std::numbers::pi, y);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return result;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // y cannot now be zero\r\n\r\n\r\n\r\n        if (y == INFINITY) \r\n\r\n        {\r\n\r\n            if (x == INFINITY) \r\n\r\n            {\r\n\r\n                return std::numbers::pi * F_1_4;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (x == -INFINITY) \r\n\r\n            {\r\n\r\n                return std::numbers::pi * F_3_4;\r\n\r\n            }\r\n\r\n\r\n\r\n            return std::numbers::pi * F_1_2;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (y == -INFINITY) \r\n\r\n        {\r\n\r\n            if (x == INFINITY) \r\n\r\n            {\r\n\r\n                return -std::numbers::pi * F_1_4;\r\n\r\n            }\r\n\r\n\r\n\r\n            if (x == -INFINITY) \r\n\r\n            {\r\n\r\n                return -std::numbers::pi * F_3_4;\r\n\r\n            }\r\n\r\n\r\n\r\n            return -std::numbers::pi * F_1_2;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x == INFINITY) \r\n\r\n        {\r\n\r\n            return copy_sign(0d, y);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x == -INFINITY)\r\n\r\n        \r\n\r\n        {\r\n\r\n            return copy_sign(std::numbers::pi, y);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Neither y nor x can be infinite or NAN here\r\n\r\n\r\n\r\n        if (x == 0) \r\n\r\n        {\r\n\r\n            return copy_sign(std::numbers::pi * F_1_2, y);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Compute ratio r = y/x\r\n\r\n        const double r = y / x;\r\n\r\n        if (Double.std::isinfinite(r)) { // bypass calculations that can create NaN\r\n\r\n            return atan(r, 0, x < 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        double ra = doubleHigh_part(r);\r\n\r\n        double rb = r - ra;\r\n\r\n\r\n\r\n        // Split x\r\n\r\n        const double xa = doubleHigh_part(x);\r\n\r\n        const double xb = x - xa;\r\n\r\n\r\n\r\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\r\n\r\n\r\n\r\n        const double temp = ra + rb;\r\n\r\n        rb = -(temp - ra - rb);\r\n\r\n        ra = temp;\r\n\r\n\r\n\r\n        if (ra == 0) { // Fix up the sign so atan works correctly\r\n\r\n            ra = copy_sign(0d, y);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Call atan\r\n\r\n        return atan(ra, rb, x < 0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the arc sine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return arc sine of x\r\n\r\n     */\r\n\r\n    public static double asin(double x) \r\n\r\n    {\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return std::numeric_limits<double>::quiet_NaN();\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x > 1.0 || x < -1.0) \r\n\r\n      {\r\n\r\n          return std::numeric_limits<double>::quiet_NaN();\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 1.0) \r\n\r\n      {\r\n\r\n          return std::numbers::pi/2.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == -1.0) \r\n\r\n      {\r\n\r\n          return -std::numbers::pi/2.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 0.0) { // Matches +/- 0.0; return correct sign\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\r\n\r\n\r\n\r\n      /* Split x */\r\n\r\n      double temp = x * HEX_40000000;\r\n\r\n      const double xa = x + temp - temp;\r\n\r\n      const double xb = x - xa;\r\n\r\n\r\n\r\n      /* Square it */\r\n\r\n      double ya = xa*xa;\r\n\r\n      double yb = xa*xb*2.0 + xb*xb;\r\n\r\n\r\n\r\n      /* Subtract from 1 */\r\n\r\n      ya = -ya;\r\n\r\n      yb = -yb;\r\n\r\n\r\n\r\n      double za = 1.0 + ya;\r\n\r\n      double zb = -(za - 1.0 - ya);\r\n\r\n\r\n\r\n      temp = za + yb;\r\n\r\n      zb += -(temp - za - yb);\r\n\r\n      za = temp;\r\n\r\n\r\n\r\n      /* Square root */\r\n\r\n      double y;\r\n\r\n      y = sqrt(za);\r\n\r\n      temp = y * HEX_40000000;\r\n\r\n      ya = y + temp - temp;\r\n\r\n      yb = y - ya;\r\n\r\n\r\n\r\n      /* Extend precision of sqrt */\r\n\r\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\r\n\r\n\r\n\r\n      /* Contribution of zb to sqrt */\r\n\r\n      double dx = zb / (2.0*y);\r\n\r\n\r\n\r\n      // Compute ratio r = x/y\r\n\r\n      double r = x/y;\r\n\r\n      temp = r * HEX_40000000;\r\n\r\n      double ra = r + temp - temp;\r\n\r\n      double rb = r - ra;\r\n\r\n\r\n\r\n      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\r\n\r\n      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\r\n\r\n\r\n\r\n      temp = ra + rb;\r\n\r\n      rb = -(temp - ra - rb);\r\n\r\n      ra = temp;\r\n\r\n\r\n\r\n      return atan(ra, rb, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the arc cosine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return arc cosine of x\r\n\r\n     */\r\n\r\n    public static double acos(double x) \r\n\r\n    {\r\n\r\n      if (std::isnan(x)) \r\n\r\n      {\r\n\r\n          return std::numeric_limits<double>::quiet_NaN();\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x > 1.0 || x < -1.0) \r\n\r\n      {\r\n\r\n          return std::numeric_limits<double>::quiet_NaN();\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == -1.0) \r\n\r\n      {\r\n\r\n          return std::numbers::pi;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 1.0) \r\n\r\n      {\r\n\r\n          return 0.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (x == 0) \r\n\r\n      {\r\n\r\n          return std::numbers::pi/2.0;\r\n\r\n      }\r\n\r\n\r\n\r\n      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\r\n\r\n\r\n\r\n      /* Split x */\r\n\r\n      double temp = x * HEX_40000000;\r\n\r\n      const double xa = x + temp - temp;\r\n\r\n      const double xb = x - xa;\r\n\r\n\r\n\r\n      /* Square it */\r\n\r\n      double ya = xa*xa;\r\n\r\n      double yb = xa*xb*2.0 + xb*xb;\r\n\r\n\r\n\r\n      /* Subtract from 1 */\r\n\r\n      ya = -ya;\r\n\r\n      yb = -yb;\r\n\r\n\r\n\r\n      double za = 1.0 + ya;\r\n\r\n      double zb = -(za - 1.0 - ya);\r\n\r\n\r\n\r\n      temp = za + yb;\r\n\r\n      zb += -(temp - za - yb);\r\n\r\n      za = temp;\r\n\r\n\r\n\r\n      /* Square root */\r\n\r\n      double y = sqrt(za);\r\n\r\n      temp = y * HEX_40000000;\r\n\r\n      ya = y + temp - temp;\r\n\r\n      yb = y - ya;\r\n\r\n\r\n\r\n      /* Extend precision of sqrt */\r\n\r\n      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\r\n\r\n\r\n\r\n      /* Contribution of zb to sqrt */\r\n\r\n      yb += zb / (2.0*y);\r\n\r\n      y = ya+yb;\r\n\r\n      yb = -(y - ya - yb);\r\n\r\n\r\n\r\n      // Compute ratio r = y/x\r\n\r\n      double r = y/x;\r\n\r\n\r\n\r\n      // Did r overflow?\r\n\r\n      if (Double.std::isinfinite(r)) { // x is effectively zero\r\n\r\n          return std::numbers::pi/2; // so return the appropriate value\r\n\r\n      }\r\n\r\n\r\n\r\n      double ra = doubleHigh_part(r);\r\n\r\n      double rb = r - ra;\r\n\r\n\r\n\r\n      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\r\n\r\n      rb += yb / x;  // Add in effect additional bits of sqrt.\r\n\r\n\r\n\r\n      temp = ra + rb;\r\n\r\n      rb = -(temp - ra - rb);\r\n\r\n      ra = temp;\r\n\r\n\r\n\r\n      return atan(ra, rb, x<0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cubic root of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @return cubic root of x\r\n\r\n     */\r\n\r\n    public static double cbrt(double x) \r\n\r\n    {\r\n\r\n      /* Convert input double to bits */\r\n\r\n      long inbits = Double.double_to_raw_long_bits(x);\r\n\r\n      int exponent = static_cast<int>( ((inbits >> 52) & 0x7ff) - 1023;\r\n\r\n      bool subnormal = false;\r\n\r\n\r\n\r\n      if (exponent == -1023) \r\n\r\n      {\r\n\r\n          if (x == 0) \r\n\r\n          {\r\n\r\n              return x;\r\n\r\n          }\r\n\r\n\r\n\r\n          /* Subnormal, so normalize */\r\n\r\n          subnormal = true;\r\n\r\n          x *= 1.8014398509481984E16;  // 2^54\r\n\r\n          inbits = Double.double_to_raw_long_bits(x);\r\n\r\n          exponent = static_cast<int>( ((inbits >> 52) & 0x7ff) - 1023;\r\n\r\n      }\r\n\r\n\r\n\r\n      if (exponent == 1024) \r\n\r\n      {\r\n\r\n          // Nan or infinity.  Don't care which.\r\n\r\n          return x;\r\n\r\n      }\r\n\r\n\r\n\r\n      /* Divide the exponent by 3 */\r\n\r\n      int exp3 = exponent / 3;\r\n\r\n\r\n\r\n      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\r\n\r\n      double p2 = Double.long_bits_to_double((inbits & 0x8000000000000000L) |\r\n\r\n                                          static_cast<long>((((exp3 + 1023) & 0x7ff)) << 52);\r\n\r\n\r\n\r\n      /* This will be a number between 1 and 2 */\r\n\r\n      const double mant = Double.long_bits_to_double((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\r\n\r\n\r\n\r\n      /* Estimate the cube root of mant by polynomial */\r\n\r\n      double est = -0.010714690733195933;\r\n\r\n      est = est * mant + 0.0875862700108075;\r\n\r\n      est = est * mant + -0.3058015757857271;\r\n\r\n      est = est * mant + 0.7249995199969751;\r\n\r\n      est = est * mant + 0.5039018405998233;\r\n\r\n\r\n\r\n      est *= CBRTTWO[exponent % 3 + 2];\r\n\r\n\r\n\r\n      // est should now be good to about 15 bits of precision.   Do 2 rounds of\r\n\r\n      // Newton's method to get closer,  this should get us full double precision\r\n\r\n      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\r\n\r\n      const double xs = x / (p2*p2*p2);\r\n\r\n      est += (xs - est*est*est) / (3*est*est);\r\n\r\n      est += (xs - est*est*est) / (3*est*est);\r\n\r\n\r\n\r\n      // Do one round of Newton's method in extended precision to get the last bit right.\r\n\r\n      double temp = est * HEX_40000000;\r\n\r\n      double ya = est + temp - temp;\r\n\r\n      double yb = est - ya;\r\n\r\n\r\n\r\n      double za = ya * ya;\r\n\r\n      double zb = ya * yb * 2.0 + yb * yb;\r\n\r\n      temp = za * HEX_40000000;\r\n\r\n      double temp2 = za + temp - temp;\r\n\r\n      zb += za - temp2;\r\n\r\n      za = temp2;\r\n\r\n\r\n\r\n      zb = za * yb + ya * zb + zb * yb;\r\n\r\n      za *= ya;\r\n\r\n\r\n\r\n      double na = xs - za;\r\n\r\n      double nb = -(na - xs + za);\r\n\r\n      nb -= zb;\r\n\r\n\r\n\r\n      est += (na+nb)/(3*est*est);\r\n\r\n\r\n\r\n      /* Scale by a power of two, so this is exact. */\r\n\r\n      est *= p2;\r\n\r\n\r\n\r\n      if (subnormal) \r\n\r\n      {\r\n\r\n          est *= 3.814697265625E-6;  // 2^-18\r\n\r\n      }\r\n\r\n\r\n\r\n      return est;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Convert degrees to radians, with error of less than 0.5 ULP\r\n\r\n     *  @param x angle in degrees\r\n\r\n     *  @return x converted into radians\r\n\r\n     */\r\n\r\n    public static double to_radians(double x)\r\n\r\n    \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        // These are PI/180 split into high and low order bits\r\n\r\n        const double facta = 0.01745329052209854;\r\n\r\n        const double factb = 1.997844754509471E-9;\r\n\r\n\r\n\r\n        double xa = doubleHigh_part(x);\r\n\r\n        double xb = x - xa;\r\n\r\n\r\n\r\n        double result = xb * factb + xb * facta + xa * factb + xa * facta;\r\n\r\n        if (result == 0) \r\n\r\n        {\r\n\r\n            result *= x; // ensure correct sign if calculation underflows\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Convert radians to degrees, with error of less than 0.5 ULP\r\n\r\n     *  @param x angle in radians\r\n\r\n     *  @return x converted into degrees\r\n\r\n     */\r\n\r\n    public static double to_degrees(double x)\r\n\r\n    \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        // These are 180/PI split into high and low order bits\r\n\r\n        const double facta = 57.2957763671875;\r\n\r\n        const double factb = 3.145894820876798E-6;\r\n\r\n\r\n\r\n        double xa = doubleHigh_part(x);\r\n\r\n        double xb = x - xa;\r\n\r\n\r\n\r\n        return xb * factb + xb * facta + xa * factb + xa * facta;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x)\r\n\r\n     */\r\n\r\n    public static int abs(const int x) \r\n\r\n    {\r\n\r\n        const int i = x >>> 31;\r\n\r\n        return (x ^ (~i + 1)) + i;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x)\r\n\r\n     */\r\n\r\n    public static long abs(const long x) \r\n\r\n    {\r\n\r\n        const long l = x >>> 63;\r\n\r\n        // l is one if x negative zero else\r\n\r\n        // ~l+1 is zero if x is positive, -1 if x is negative\r\n\r\n        // x^(~l+1) is x is x is positive, ~x if x is negative\r\n\r\n        // add around\r\n\r\n        return (x ^ (~l + 1)) + l;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x), or an exception for {@code Integer.MIN_VALUE}\r\n\r\n     */\r\n\r\n    public static int absExact(const int x) \r\n\r\n    {\r\n\r\n        if (x == Integer.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Arithmetic_Exception();\r\n\r\n        }\r\n\r\n        return abs(x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x), or an exception for {@code long.MIN_VALUE}\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    public static long absExact(const long x) \r\n\r\n    {\r\n\r\n        if (x == long.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Arithmetic_Exception();\r\n\r\n        }\r\n\r\n        return abs(x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x)\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    public static float abs(const float x) \r\n\r\n    {\r\n\r\n        return Float.int_bits_to_float(MASK_NON_SIGN_INT & Float.float_to_raw_int_bits(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @return abs(x)\r\n\r\n     */\r\n\r\n    public static double abs(double x) \r\n\r\n    {\r\n\r\n        return Double.long_bits_to_double(MASK_NON_SIGN_LONG & Double.double_to_raw_long_bits(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Negates the argument.\r\n\r\n     * @param x number from which opposite value is requested\r\n\r\n     * @return -x, or an exception for {@code Integer.MIN_VALUE}\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    public static int negateExact(const int x) \r\n\r\n    {\r\n\r\n        if (x == Integer.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Arithmetic_Exception();\r\n\r\n        }\r\n\r\n        return -x;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Negates the argument.\r\n\r\n     * @param x number from which opposite value is requested\r\n\r\n     * @return -x, or an exception for {@code long.MIN_VALUE}\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    public static long negateExact(const long x) \r\n\r\n    {\r\n\r\n        if (x == long.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Arithmetic_Exception();\r\n\r\n        }\r\n\r\n        return -x;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute least significant bit (Unit in Last Position) for a number.\r\n\r\n     * @param x number from which ulp is requested\r\n\r\n     * @return ulp(x)\r\n\r\n     */\r\n\r\n    public static double ulp(double x) \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(x)) \r\n\r\n        {\r\n\r\n            return INFINITY;\r\n\r\n        }\r\n\r\n        return abs(x - Double.long_bits_to_double(Double.double_to_raw_long_bits(x) ^ 1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute least significant bit (Unit in Last Position) for a number.\r\n\r\n     * @param x number from which ulp is requested\r\n\r\n     * @return ulp(x)\r\n\r\n     */\r\n\r\n    public static float ulp(float x) \r\n\r\n    {\r\n\r\n        if (Float.std::isinfinite(x)) \r\n\r\n        {\r\n\r\n            return Float.POSITIVE_INFINITY;\r\n\r\n        }\r\n\r\n        return abs(x - Float.int_bits_to_float(Float.float_to_raw_int_bits(x) ^ 1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply a double number by a power of 2.\r\n\r\n     * @param d number to multiply\r\n\r\n     * @param n power of 2\r\n\r\n     * @return d &times; 2<sup>n</sup>\r\n\r\n     */\r\n\r\n    public static double scalb(const double d, const int& n) \r\n\r\n    {\r\n\r\n\r\n\r\n        // first simple and fast handling when 2^n can be represented using normal numbers\r\n\r\n        if ((n > -1023) && (n < 1024)) \r\n\r\n        {\r\n\r\n            return d * Double.long_bits_to_double((static_cast<long>( (n + 1023)) << 52);\r\n\r\n        }\r\n\r\n\r\n\r\n        // handle special cases\r\n\r\n        if (std::isnan(d) || Double.std::isinfinite(d) || (d == 0)) \r\n\r\n        {\r\n\r\n            return d;\r\n\r\n        }\r\n\r\n        if (n < -2098) \r\n\r\n        {\r\n\r\n            return (d > 0) ? 0.0 : -0.0;\r\n\r\n        }\r\n\r\n        if (n > 2097) \r\n\r\n        {\r\n\r\n            return (d > 0) ? INFINITY : -INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        // decompose d\r\n\r\n        const long bits = Double.double_to_raw_long_bits(d);\r\n\r\n        const long sign = bits & 0x8000000000000000L;\r\n\r\n        int  exponent   = (static_cast<int>( (bits >>> 52)) & 0x7ff;\r\n\r\n        long mantissa   = bits & 0x000fffffffffffffL;\r\n\r\n\r\n\r\n        // compute scaled exponent\r\n\r\n        int scaledExponent = exponent + n;\r\n\r\n\r\n\r\n        if (n < 0) \r\n\r\n        {\r\n\r\n            // we are really in the case n <= -1023\r\n\r\n            if (scaledExponent > 0) \r\n\r\n            {\r\n\r\n                // both the input and the result are normal numbers, we only adjust the exponent\r\n\r\n                return Double.long_bits_to_double(sign | ((static_cast<long>( scaledExponent) << 52) | mantissa);\r\n\r\n            }\r\n\r\nelse if (scaledExponent > -53) \r\n\r\n            {\r\n\r\n                // the input is a normal number and the result is a subnormal number\r\n\r\n\r\n\r\n                // recover the hidden mantissa bit\r\n\r\n                mantissa |= 1L << 52;\r\n\r\n\r\n\r\n                // scales down complete mantissa, hence losing least significant bits\r\n\r\n                const long most_significant_lost_bit = mantissa & (1L << (-scaledExponent));\r\n\r\n                mantissa >>>= 1 - scaledExponent;\r\n\r\n                if (most_significant_lost_bit != 0) \r\n\r\n                {\r\n\r\n                    // we need to add 1 bit to round up the result\r\n\r\n                    mantissa++;\r\n\r\n                }\r\n\r\n                return Double.long_bits_to_double(sign | mantissa);\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // no need to compute the mantissa, the number scales down to 0\r\n\r\n                return (sign == 0L) ? 0.0 : -0.0;\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // we are really in the case n >= 1024\r\n\r\n            if (exponent == 0) \r\n\r\n            {\r\n\r\n\r\n\r\n                // the input number is subnormal, normalize it\r\n\r\n                while ((mantissa >>> 52) != 1) \r\n\r\n                {\r\n\r\n                    mantissa <<= 1;\r\n\r\n                    --scaledExponent;\r\n\r\n                }\r\n\r\n                ++scaledExponent;\r\n\r\n                mantissa &= 0x000fffffffffffffL;\r\n\r\n\r\n\r\n                if (scaledExponent < 2047) \r\n\r\n                {\r\n\r\n                    return Double.long_bits_to_double(sign | ((static_cast<long>( scaledExponent) << 52) | mantissa);\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    return (sign == 0L) ? INFINITY : -INFINITY;\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\nelse if (scaledExponent < 2047) \r\n\r\n            {\r\n\r\n                return Double.long_bits_to_double(sign | ((static_cast<long>( scaledExponent) << 52) | mantissa);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return (sign == 0L) ? INFINITY : -INFINITY;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply a float number by a power of 2.\r\n\r\n     * @param f number to multiply\r\n\r\n     * @param n power of 2\r\n\r\n     * @return f &times; 2<sup>n</sup>\r\n\r\n     */\r\n\r\n    public static float scalb(const float f, const int& n) \r\n\r\n    {\r\n\r\n\r\n\r\n        // first simple and fast handling when 2^n can be represented using normal numbers\r\n\r\n        if ((n > -127) && (n < 128)) \r\n\r\n        {\r\n\r\n            return f * Float.int_bits_to_float((n + 127) << 23);\r\n\r\n        }\r\n\r\n\r\n\r\n        // handle special cases\r\n\r\n        if (Float.is_nan(f) || Float.std::isinfinite(f) || (f == 0f)) \r\n\r\n        {\r\n\r\n            return f;\r\n\r\n        }\r\n\r\n        if (n < -277) \r\n\r\n        {\r\n\r\n            return (f > 0) ? 0.0f : -0.0f;\r\n\r\n        }\r\n\r\n        if (n > 276) \r\n\r\n        {\r\n\r\n            return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\r\n\r\n        }\r\n\r\n\r\n\r\n        // decompose f\r\n\r\n        const int bits = Float.floatToIntBits(f);\r\n\r\n        const int sign = bits & 0x80000000;\r\n\r\n        int  exponent  = (bits >>> 23) & 0xff;\r\n\r\n        int mantissa   = bits & 0x007fffff;\r\n\r\n\r\n\r\n        // compute scaled exponent\r\n\r\n        int scaledExponent = exponent + n;\r\n\r\n\r\n\r\n        if (n < 0) \r\n\r\n        {\r\n\r\n            // we are really in the case n <= -127\r\n\r\n            if (scaledExponent > 0) \r\n\r\n            {\r\n\r\n                // both the input and the result are normal numbers, we only adjust the exponent\r\n\r\n                return Float.int_bits_to_float(sign | (scaledExponent << 23) | mantissa);\r\n\r\n            }\r\n\r\nelse if (scaledExponent > -24) \r\n\r\n            {\r\n\r\n                // the input is a normal number and the result is a subnormal number\r\n\r\n\r\n\r\n                // recover the hidden mantissa bit\r\n\r\n                mantissa |= 1 << 23;\r\n\r\n\r\n\r\n                // scales down complete mantissa, hence losing least significant bits\r\n\r\n                const int most_significant_lost_bit = mantissa & (1 << (-scaledExponent));\r\n\r\n                mantissa >>>= 1 - scaledExponent;\r\n\r\n                if (most_significant_lost_bit != 0) \r\n\r\n                {\r\n\r\n                    // we need to add 1 bit to round up the result\r\n\r\n                    mantissa++;\r\n\r\n                }\r\n\r\n                return Float.int_bits_to_float(sign | mantissa);\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // no need to compute the mantissa, the number scales down to 0\r\n\r\n                return (sign == 0) ? 0.0f : -0.0f;\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // we are really in the case n >= 128\r\n\r\n            if (exponent == 0) \r\n\r\n            {\r\n\r\n\r\n\r\n                // the input number is subnormal, normalize it\r\n\r\n                while ((mantissa >>> 23) != 1) \r\n\r\n                {\r\n\r\n                    mantissa <<= 1;\r\n\r\n                    --scaledExponent;\r\n\r\n                }\r\n\r\n                ++scaledExponent;\r\n\r\n                mantissa &= 0x007fffff;\r\n\r\n\r\n\r\n                if (scaledExponent < 255) \r\n\r\n                {\r\n\r\n                    return Float.int_bits_to_float(sign | (scaledExponent << 23) | mantissa);\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\nelse if (scaledExponent < 255) \r\n\r\n            {\r\n\r\n                return Float.int_bits_to_float(sign | (scaledExponent << 23) | mantissa);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the next machine representable number after a number, moving\r\n\r\n     * in the direction of another number.\r\n\r\n     * <p>\r\n\r\n     * The ordering is as follows (increasing):\r\n\r\n     * <ul>\r\n\r\n     * <li>-INFINITY</li>\r\n\r\n     * <li>-MAX_VALUE</li>\r\n\r\n     * <li>-MIN_VALUE</li>\r\n\r\n     * <li>-0.0</li>\r\n\r\n     * <li>+0.0</li>\r\n\r\n     * <li>+MIN_VALUE</li>\r\n\r\n     * <li>+MAX_VALUE</li>\r\n\r\n     * <li>+INFINITY</li>\r\n\r\n     * <li></li>\r\n\r\n     * <p>\r\n\r\n     * If arguments compare equal, then the second argument is returned.\r\n\r\n     * <p>\r\n\r\n     * If {@code direction} is greater than {@code d}, * the smallest machine representable number strictly greater than\r\n\r\n     * {@code d} is returned; if less, then the largest representable number\r\n\r\n     * strictly less than {@code d} is returned.</p>\r\n\r\n     * <p>\r\n\r\n     * If {@code d} is infinite and direction does not\r\n\r\n     * bring it back to finite numbers, it is returned unchanged.</p>\r\n\r\n     *\r\n\r\n     * @param d base number\r\n\r\n     * @param direction (the only important thing is whether\r\n\r\n     * {@code direction} is greater or smaller than {@code d})\r\n\r\n     * @return the next machine representable number in the specified direction\r\n\r\n     */\r\n\r\n    public static double next_after(double d, double direction) \r\n\r\n    {\r\n\r\n\r\n\r\n        // handling of some important special cases\r\n\r\n        if (std::isnan(d) || std::isnan(direction)) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\nelse if (d == direction) \r\n\r\n        {\r\n\r\n            return direction;\r\n\r\n        }\r\n\r\nelse if (Double.std::isinfinite(d)) \r\n\r\n        {\r\n\r\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\r\n\r\n        }\r\n\r\nelse if (d == 0) \r\n\r\n        {\r\n\r\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\r\n\r\n        }\r\n\r\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\r\n\r\n        // are handled just as normal numbers\r\n\r\n        // can use raw bits since already dealt with infinity and NaN\r\n\r\n        const long bits = Double.double_to_raw_long_bits(d);\r\n\r\n        const long sign = bits & 0x8000000000000000L;\r\n\r\n        if ((direction < d) ^ (sign == 0L)) \r\n\r\n        {\r\n\r\n            return Double.long_bits_to_double(sign | ((bits & 0x7fffffffffffffffL) + 1));\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return Double.long_bits_to_double(sign | ((bits & 0x7fffffffffffffffL) - 1));\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the next machine representable number after a number, moving\r\n\r\n     * in the direction of another number.\r\n\r\n     * <p>\r\n\r\n     * The ordering is as follows (increasing):\r\n\r\n     * <ul>\r\n\r\n     * <li>-INFINITY</li>\r\n\r\n     * <li>-MAX_VALUE</li>\r\n\r\n     * <li>-MIN_VALUE</li>\r\n\r\n     * <li>-0.0</li>\r\n\r\n     * <li>+0.0</li>\r\n\r\n     * <li>+MIN_VALUE</li>\r\n\r\n     * <li>+MAX_VALUE</li>\r\n\r\n     * <li>+INFINITY</li>\r\n\r\n     * <li></li>\r\n\r\n     * <p>\r\n\r\n     * If arguments compare equal, then the second argument is returned.\r\n\r\n     * <p>\r\n\r\n     * If {@code direction} is greater than {@code f}, * the smallest machine representable number strictly greater than\r\n\r\n     * {@code f} is returned; if less, then the largest representable number\r\n\r\n     * strictly less than {@code f} is returned.</p>\r\n\r\n     * <p>\r\n\r\n     * If {@code f} is infinite and direction does not\r\n\r\n     * bring it back to finite numbers, it is returned unchanged.</p>\r\n\r\n     *\r\n\r\n     * @param f base number\r\n\r\n     * @param direction (the only important thing is whether\r\n\r\n     * {@code direction} is greater or smaller than {@code f})\r\n\r\n     * @return the next machine representable number in the specified direction\r\n\r\n     */\r\n\r\n    public static float next_after(const float f, const double direction) \r\n\r\n    {\r\n\r\n\r\n\r\n        // handling of some important special cases\r\n\r\n        if (std::isnan(f) || std::isnan(direction)) \r\n\r\n        {\r\n\r\n            return Float.NaN;\r\n\r\n        }\r\n\r\nelse if (f == direction) \r\n\r\n        {\r\n\r\n            return (float) direction;\r\n\r\n        }\r\n\r\nelse if (Float.std::isinfinite(f)) \r\n\r\n        {\r\n\r\n            return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\r\n\r\n        }\r\n\r\nelse if (f == 0f) \r\n\r\n        {\r\n\r\n            return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\r\n\r\n        }\r\n\r\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\r\n\r\n        // are handled just as normal numbers\r\n\r\n\r\n\r\n        const int bits = Float.floatToIntBits(f);\r\n\r\n        const int sign = bits & 0x80000000;\r\n\r\n        if ((direction < f) ^ (sign == 0)) \r\n\r\n        {\r\n\r\n            return Float.int_bits_to_float(sign | ((bits & 0x7fffffff) + 1));\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return Float.int_bits_to_float(sign | ((bits & 0x7fffffff) - 1));\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the largest whole number smaller than x.\r\n\r\n     * @param x number from which floor is requested\r\n\r\n     * @return a double number f such that f is an integer f &lt;= x &lt; f + 1.0\r\n\r\n     */\r\n\r\n    public static double floor(double x) \r\n\r\n    {\r\n\r\n        long y;\r\n\r\n\r\n\r\n        if (std::isnan(x)) \r\n\r\n        {\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) \r\n\r\n        {\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        y = static_cast<long>( x;\r\n\r\n        if (x < 0 && y != x) \r\n\r\n        {\r\n\r\n            y--;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (y == 0) \r\n\r\n        {\r\n\r\n            return x*y;\r\n\r\n        }\r\n\r\n\r\n\r\n        return y;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the smallest whole number larger than x.\r\n\r\n     * @param x number from which ceil is requested\r\n\r\n     * @return a double number c such that c is an integer c - 1.0 &lt; x &lt;= c\r\n\r\n     */\r\n\r\n    public static double ceil(double x) \r\n\r\n    {\r\n\r\n        double y;\r\n\r\n\r\n\r\n        if (std::isnan(x)) \r\n\r\n        {\r\n\r\n            return x;\r\n\r\n        }\r\n\r\n\r\n\r\n        y = floor(x);\r\n\r\n        if (y == x) \r\n\r\n        {\r\n\r\n            return y;\r\n\r\n        }\r\n\r\n\r\n\r\n        y += 1.0;\r\n\r\n\r\n\r\n        if (y == 0) \r\n\r\n        {\r\n\r\n            return x*y;\r\n\r\n        }\r\n\r\n\r\n\r\n        return y;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\r\n\r\n     * @param x number from which nearest whole number is requested\r\n\r\n     * @return a double number r such that r is an integer r - 0.5 &lt;= x &lt;= r + 0.5\r\n\r\n     */\r\n\r\n    public static double rint(double x) \r\n\r\n    {\r\n\r\n        double y = floor(x);\r\n\r\n        double d = x - y;\r\n\r\n\r\n\r\n        if (d > 0.5) \r\n\r\n        {\r\n\r\n            if (y == -1.0) \r\n\r\n            {\r\n\r\n                return -0.0; // Preserve sign of operand\r\n\r\n            }\r\n\r\n            return y+1.0;\r\n\r\n        }\r\n\r\n        if (d < 0.5) \r\n\r\n        {\r\n\r\n            return y;\r\n\r\n        }\r\n\r\n\r\n\r\n        /* half way, round to even */\r\n\r\n        long z = static_cast<long>( y;\r\n\r\n        return (z & 1) == 0 ? y : y + 1.0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the closest long to x.\r\n\r\n     * @param x number from which closest long is requested\r\n\r\n     * @return closest long to x\r\n\r\n     */\r\n\r\n    public static long round(double x) \r\n\r\n    {\r\n\r\n        const long bits = Double.double_to_raw_long_bits(x);\r\n\r\n        const int biasedExp = (static_cast<int>((bits>>52)) & 0x7ff;\r\n\r\n        // Shift to get rid of bits past comma except first one: will need to\r\n\r\n        // 1-shift to the right to end up with correct magnitude.\r\n\r\n        const int shift = (52 - 1 + Double.MAX_EXPONENT) - biasedExp;\r\n\r\n        if ((shift & -64) == 0) \r\n\r\n        {\r\n\r\n            // shift in [0,63], so unbiased exp in [-12,51].\r\n\r\n            long extendedMantissa = 0x0010000000000000L | (bits & 0x000fffffffffffffL);\r\n\r\n            if (bits < 0) \r\n\r\n            {\r\n\r\n                extendedMantissa = -extendedMantissa;\r\n\r\n            }\r\n\r\n            // If value is positive and first bit past comma is 0, rounding\r\n\r\n            // to lower integer, else to upper one, which is what "+1" and\r\n\r\n            // then ">>1" do.\r\n\r\n            return ((extendedMantissa >> shift) + 1L) >> 1;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // +-Infinity, NaN, or a mathematical integer.\r\n\r\n            return static_cast<long>( x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the closest int to x.\r\n\r\n     * @param x number from which closest int is requested\r\n\r\n     * @return closest int to x\r\n\r\n     */\r\n\r\n    public static int round(const float x) \r\n\r\n    {\r\n\r\n        const int bits = Float.float_to_raw_int_bits(x);\r\n\r\n        const int biasedExp = (bits>>23) & 0xff;\r\n\r\n        // Shift to get rid of bits past comma except first one: will need to\r\n\r\n        // 1-shift to the right to end up with correct magnitude.\r\n\r\n        const int shift = (23 - 1 + Float.MAX_EXPONENT) - biasedExp;\r\n\r\n        if ((shift & -32) == 0) \r\n\r\n        {\r\n\r\n            // shift in [0,31], so unbiased exp in [-9,22].\r\n\r\n            int extendedMantissa = 0x00800000 | (bits & 0x007fffff);\r\n\r\n            if (bits < 0) \r\n\r\n            {\r\n\r\n                extendedMantissa = -extendedMantissa;\r\n\r\n            }\r\n\r\n            // If value is positive and first bit past comma is 0, rounding\r\n\r\n            // to lower integer, else to upper one, which is what "+1" and\r\n\r\n            // then ">>1" do.\r\n\r\n            return ((extendedMantissa >> shift) + 1) >> 1;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // +-Infinity, NaN, or a mathematical integer.\r\n\r\n            return static_cast<int>( x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     */\r\n\r\n    public static int min(const int a, const int b) \r\n\r\n    {\r\n\r\n        return (a <= b) ? a : b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     */\r\n\r\n    public static long min(const long a, const long b) \r\n\r\n    {\r\n\r\n        return (a <= b) ? a : b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     */\r\n\r\n    public static float min(const float a, const float b) \r\n\r\n    {\r\n\r\n        if (a > b) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        if (a < b) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        /* if either arg is NaN, return NaN */\r\n\r\n        if (a != b) \r\n\r\n        {\r\n\r\n            return Float.NaN;\r\n\r\n        }\r\n\r\n        /* min(+0.0,-0.0) == -0.0 */\r\n\r\n        /* 0x80000000 == Float.float_to_raw_int_bits(-0.0) */\r\n\r\n        int bits = Float.float_to_raw_int_bits(a);\r\n\r\n        if (bits == 0x80000000) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        return b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     */\r\n\r\n    public static double min(const double& a, const double& b) \r\n\r\n    {\r\n\r\n        if (a > b) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        if (a < b) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        /* if either arg is NaN, return NaN */\r\n\r\n        if (a != b) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n        /* min(+0.0,-0.0) == -0.0 */\r\n\r\n        /* 0x8000000000000000L == Double.double_to_raw_long_bits(-0.0) */\r\n\r\n        long bits = Double.double_to_raw_long_bits(a);\r\n\r\n        if (bits == 0x8000000000000000L) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        return b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     */\r\n\r\n    public static int max(const int a, const int b) \r\n\r\n    {\r\n\r\n        return (a <= b) ? b : a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     */\r\n\r\n    public static long max(const long a, const long b) \r\n\r\n    {\r\n\r\n        return (a <= b) ? b : a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     */\r\n\r\n    public static float max(const float a, const float b) \r\n\r\n    {\r\n\r\n        if (a > b) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        if (a < b) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        /* if either arg is NaN, return NaN */\r\n\r\n        if (a != b) \r\n\r\n        {\r\n\r\n            return Float.NaN;\r\n\r\n        }\r\n\r\n        /* min(+0.0,-0.0) == -0.0 */\r\n\r\n        /* 0x80000000 == Float.float_to_raw_int_bits(-0.0) */\r\n\r\n        int bits = Float.float_to_raw_int_bits(a);\r\n\r\n        if (bits == 0x80000000) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     */\r\n\r\n    public static double max(const double& a, const double& b) \r\n\r\n    {\r\n\r\n        if (a > b) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\n        if (a < b) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        /* if either arg is NaN, return NaN */\r\n\r\n        if (a != b) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\n        /* min(+0.0,-0.0) == -0.0 */\r\n\r\n        /* 0x8000000000000000L == Double.double_to_raw_long_bits(-0.0) */\r\n\r\n        long bits = Double.double_to_raw_long_bits(a);\r\n\r\n        if (bits == 0x8000000000000000L) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\r\n\r\n     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\r\n\r\n     * avoiding intermediate overflow or underflow.\r\n\r\n     *\r\n\r\n     * <ul>\r\n\r\n     * <li> If either argument is infinite, then the result is positive infinity.</li>\r\n\r\n     * <li> else, if either argument is NaN then the result is NaN.</li>\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param x a value\r\n\r\n     * @param y a value\r\n\r\n     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\r\n\r\n     */\r\n\r\n    public static double hypot(const double& x, const double y) \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(x) || Double.std::isinfinite(y)) \r\n\r\n        {\r\n\r\n            return INFINITY;\r\n\r\n        }\r\n\r\nelse if (std::isnan(x) || std::isnan(y)) \r\n\r\n        {\r\n\r\n            return std::numeric_limits<double>::quiet_NaN();\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            const int exp_x = get_exponent(x);\r\n\r\n            const int exp_y = get_exponent(y);\r\n\r\n            if (exp_x > exp_y + 27) \r\n\r\n            {\r\n\r\n                // y is neglectible with respect to x\r\n\r\n                return abs(x);\r\n\r\n            }\r\n\r\nelse if (exp_y > exp_x + 27) \r\n\r\n            {\r\n\r\n                // x is neglectible with respect to y\r\n\r\n                return abs(y);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n\r\n\r\n                // find an intermediate scale to avoid both overflow and underflow\r\n\r\n                const int middle_exp = (exp_x + exp_y) / 2;\r\n\r\n\r\n\r\n                // scale parameters without losing precision\r\n\r\n                const double scaled_x = scalb(x, -middle_exp);\r\n\r\n                const double scaled_y = scalb(y, -middle_exp);\r\n\r\n\r\n\r\n                // compute scaled hypotenuse\r\n\r\n                const double scaled_h = sqrt(scaled_x * scaled_x + scaled_y * scaled_y);\r\n\r\n\r\n\r\n                // remove scaling\r\n\r\n                return scalb(scaled_h, middle_exp);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the remainder as prescribed by the IEEE 754 standard.\r\n\r\n     * The remainder value is mathematically equal to {@code x - y*n}\r\n\r\n     * where {@code n} is the mathematical integer closest to the exact mathematical value\r\n\r\n     * of the quotient {@code x/y}.\r\n\r\n     * If two mathematical integers are equally close to {@code x/y} then\r\n\r\n     * {@code n} is the integer that is even.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>If either operand is NaN, the result is NaN.</li>\r\n\r\n     * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\r\n\r\n     * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\r\n\r\n     * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\r\n\r\n     * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\r\n\r\n     * </ul>\r\n\r\n     * @param dividend the number to be divided\r\n\r\n     * @param divisor the number by which to divide\r\n\r\n     * @return the remainder, rounded\r\n\r\n     */\r\n\r\n    public static double IEE_Eremainder(const double dividend, const double divisor) \r\n\r\n    {\r\n\r\n        if (get_exponent(dividend) == 1024 || get_exponent(divisor) == 1024 || divisor == 0.0) \r\n\r\n        {\r\n\r\n            // we are in one of the special cases\r\n\r\n            if (Double.std::isinfinite(divisor) && !Double.std::isinfinite(dividend)) \r\n\r\n            {\r\n\r\n                return dividend;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return std::numeric_limits<double>::quiet_NaN();\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // we are in the general case\r\n\r\n            const double n         = FastMath.rint(dividend / divisor);\r\n\r\n            const double remainder = Double.std::isinfinite(n) ? 0.0 : dividend - divisor * n;\r\n\r\n            return (remainder == 0) ? std::copysign(remainder, dividend) : remainder;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Convert a long to interger, detecting overflows\r\n\r\n     * @param n number to convert to int\r\n\r\n     * @return integer with same valie as n if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if n cannot fit into an int\r\n\r\n     */\r\n\r\n    public static int toIntExact(const long n) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n        if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW);\r\n\r\n        }\r\n\r\n        return static_cast<int>( n;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Increment a number, detecting overflows.\r\n\r\n     * @param n number to increment\r\n\r\n     * @return n+1 if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static int incrementExact(const int& n) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == Integer.MAX_VALUE) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_ADDITION, n, 1);\r\n\r\n        }\r\n\r\n\r\n\r\n        return n + 1;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Increment a number, detecting overflows.\r\n\r\n     * @param n number to increment\r\n\r\n     * @return n+1 if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static long incrementExact(const long n) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == long.MAX_VALUE) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_ADDITION, n, 1);\r\n\r\n        }\r\n\r\n\r\n\r\n        return n + 1;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Decrement a number, detecting overflows.\r\n\r\n     * @param n number to decrement\r\n\r\n     * @return n-1 if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static int decrementExact(const int& n) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == Integer.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_SUBTRACTION, n, 1);\r\n\r\n        }\r\n\r\n\r\n\r\n        return n - 1;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Decrement a number, detecting overflows.\r\n\r\n     * @param n number to decrement\r\n\r\n     * @return n-1 if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static long decrementExact(const long n) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == long.MIN_VALUE) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_SUBTRACTION, n, 1);\r\n\r\n        }\r\n\r\n\r\n\r\n        return n - 1;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add two numbers, detecting overflows.\r\n\r\n     * @param a first number to add\r\n\r\n     * @param b second number to add\r\n\r\n     * @return a+b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static int add_exact(const int a, const int b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute sum\r\n\r\n        const int sum = a + b;\r\n\r\n\r\n\r\n        // check for overflow\r\n\r\n        if ((a ^ b) >= 0 && (sum ^ b) < 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_ADDITION, a, b);\r\n\r\n        }\r\n\r\n\r\n\r\n        return sum;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add two numbers, detecting overflows.\r\n\r\n     * @param a first number to add\r\n\r\n     * @param b second number to add\r\n\r\n     * @return a+b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static long add_exact(const long a, const long b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute sum\r\n\r\n        const long sum = a + b;\r\n\r\n\r\n\r\n        // check for overflow\r\n\r\n        if ((a ^ b) >= 0 && (sum ^ b) < 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_ADDITION, a, b);\r\n\r\n        }\r\n\r\n\r\n\r\n        return sum;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract two numbers, detecting overflows.\r\n\r\n     * @param a first number\r\n\r\n     * @param b second number to subtract from a\r\n\r\n     * @return a-b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static int subtractExact(const int a, const int b) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute subtraction\r\n\r\n        const int sub = a - b;\r\n\r\n\r\n\r\n        // check for overflow\r\n\r\n        if ((a ^ b) < 0 && (sub ^ b) >= 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_SUBTRACTION, a, b);\r\n\r\n        }\r\n\r\n\r\n\r\n        return sub;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract two numbers, detecting overflows.\r\n\r\n     * @param a first number\r\n\r\n     * @param b second number to subtract from a\r\n\r\n     * @return a-b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static long subtractExact(const long a, const long b) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute subtraction\r\n\r\n        const long sub = a - b;\r\n\r\n\r\n\r\n        // check for overflow\r\n\r\n        if ((a ^ b) < 0 && (sub ^ b) >= 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_SUBTRACTION, a, b);\r\n\r\n        }\r\n\r\n\r\n\r\n        return sub;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply two numbers, detecting overflows.\r\n\r\n     * @param a first number to multiply\r\n\r\n     * @param b second number to multiply\r\n\r\n     * @return a*b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static int multiply_exact(const int a, const int b) \r\n\r\n    {\r\n\r\n        if (((b  >  0)  && (a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b)) ||\r\n\r\n            ((b  < -1)  && (a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b)) ||\r\n\r\n            ((b == -1)  && (a == Integer.MIN_VALUE))) \r\n\r\n            {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_MULTIPLICATION, a, b);\r\n\r\n        }\r\n\r\n        return a * b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply two numbers, detecting overflows.\r\n\r\n     * @param a first number to multiply\r\n\r\n     * @param b second number to multiply\r\n\r\n     * @return a*b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static long multiply_exact(const long a, const int b) \r\n\r\n    {\r\n\r\n        return multiply_exact(a, static_cast<long>( b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply two numbers, detecting overflows.\r\n\r\n     * @param a first number to multiply\r\n\r\n     * @param b second number to multiply\r\n\r\n     * @return a*b if no overflows occur\r\n\r\n     * @exception Math_Runtime_Exception if an overflow occurs\r\n\r\n     */\r\n\r\n    public static long multiply_exact(const long a, const long b) \r\n\r\n    {\r\n\r\n        if (((b  >  0l)  && (a > long.MAX_VALUE / b || a < long.MIN_VALUE / b)) ||\r\n\r\n            ((b  < -1l)  && (a > long.MIN_VALUE / b || a < long.MAX_VALUE / b)) ||\r\n\r\n            ((b == -1l)  && (a == long.MIN_VALUE))) \r\n\r\n            {\r\n\r\n                throw Math_Runtime_Exception(Localized_Core_Formats.OVERFLOW_IN_MULTIPLICATION, a, b);\r\n\r\n            }\r\n\r\n            return a * b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply two integers and give an exact result without overflow.\r\n\r\n     * @param a first factor\r\n\r\n     * @param b second factor\r\n\r\n     * @return a * b exactly\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static long multiplyFull(const int a, const int b) \r\n\r\n    {\r\n\r\n        return (static_cast<long>( a) * (static_cast<long>( b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply two long integers and give the 64 most significant bits of the result.\r\n\r\n     * <p>\r\n\r\n     * Beware that as Java primitive long are always considered to be signed, there are some\r\n\r\n     * intermediate values {@code a} and {@code b} for which {@code a * b} exceeds {@code long.MAX_VALUE}\r\n\r\n     * but this method will still return 0l. This happens for example for {@code a = 2\xc2\xb3\xc2\xb9} and\r\n\r\n     * {@code b = 2\xc2\xb3\xc2\xb2} as {@code a * b = 2\xe2\x81\xb6\xc2\xb3 = long.MAX_VALUE + 1}, so it exceeds the max value\r\n\r\n     * for a long, but still fits in 64 bits, so this method correctly returns 0l in this case, * but multiplication result would be considered negative (and in fact equal to {@code long.MIN_VALUE}\r\n\r\n     * </p>\r\n\r\n     * @param a first factor\r\n\r\n     * @param b second factor\r\n\r\n     * @return a * b / 2<sup>64</sup>\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static long multiplyHigh(const long a, const long b) \r\n\r\n    {\r\n\r\n\r\n\r\n        // all computations below are performed on unsigned numbers because we start\r\n\r\n        // by using logical shifts (and not arithmetic shifts). We will therefore\r\n\r\n        // need to take care of sign before returning\r\n\r\n        // a negative long n between -2\xe2\x81\xb6\xc2\xb3 and -1, interpreted as an unsigned long\r\n\r\n        // corresponds to 2\xe2\x81\xb6\xe2\x81\xb4 + n (which is between 2\xe2\x81\xb6\xc2\xb3 and 2\xe2\x81\xb6\xe2\x81\xb4-1)\r\n\r\n        // so if this number is multiplied by p, what we really compute\r\n\r\n        // is (2\xe2\x81\xb6\xe2\x81\xb4 + n) * p = 2\xe2\x81\xb6\xe2\x81\xb4 * p + n * p, therefore the part above 64 bits\r\n\r\n        // will have an extra term p that we will need to remove\r\n\r\n        const long tobeRemoved = ((a < 0) ? b : 0) + ((b < 0) ? a : 0);\r\n\r\n\r\n\r\n        // split numbers in two 32 bits parts\r\n\r\n        const long a_high  = a >>> 32;\r\n\r\n        const long a_low   = a & 0xFFFFFFFFl;\r\n\r\n        const long b_high  = b >>> 32;\r\n\r\n        const long b_low   = b & 0xFFFFFFFFl;\r\n\r\n\r\n\r\n        // ab = a_high * b_high * 2\xe2\x81\xb6\xe2\x81\xb4 + (a_high * b_low + a_low * b_high) * 2\xc2\xb3\xc2\xb2 + a_low * b_low\r\n\r\n        const long hh     = a_high * b_high;\r\n\r\n        const long hl1    = a_high * b_low;\r\n\r\n        const long hl2    = a_low  * b_high;\r\n\r\n        const long ll     = a_low  * b_low;\r\n\r\n\r\n\r\n        // adds up everything in the above 64 bit part, taking care to avoid overflow\r\n\r\n        const long hlHigh = (hl1 >>> 32) + (hl2 >>> 32);\r\n\r\n        const long hlLow  = (hl1 & 0xFFFFFFFFl) + (hl2 & 0xFFFFFFFFl);\r\n\r\n        const long carry  = (hlLow + (ll >>> 32)) >>> 32;\r\n\r\n        const long unsignedResult = hh + hlHigh + carry;\r\n\r\n\r\n\r\n        return unsignedResult - tobeRemoved;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code  b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer division when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     *\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code  b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorMod(int, int)\r\n\r\n     */\r\n\r\n    public static int floorDiv(const int a, const int b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (b == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n        }\r\n\r\n\r\n\r\n        const int m = a % b;\r\n\r\n        if ((a ^ b) >= 0 || m == 0) \r\n\r\n        {\r\n\r\n            // a an b have same sign, or division is exact\r\n\r\n            return a / b;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // a and b have opposite signs and division is not exact\r\n\r\n            return (a / b) - 1;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer division when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     *\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorMod(long, int)\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static long floorDiv(const long a, const int b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n        return floorDiv(a, static_cast<long>( b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer division when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     *\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return q such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorMod(long, long)\r\n\r\n     */\r\n\r\n    public static long floorDiv(const long a, const long b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (b == 0l) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n        }\r\n\r\n\r\n\r\n        const long m = a % b;\r\n\r\n        if ((a ^ b) >= 0l || m == 0l) \r\n\r\n        {\r\n\r\n            // a an b have same sign, or division is exact\r\n\r\n            return a / b;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // a and b have opposite signs and division is not exact\r\n\r\n            return (a / b) - 1l;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer modulo when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     * </p>\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorDiv(int, int)\r\n\r\n     */\r\n\r\n    public static int floorMod(const int a, const int b) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        if (b == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n        }\r\n\r\n\r\n\r\n        const int m = a % b;\r\n\r\n        if ((a ^ b) >= 0 || m == 0) \r\n\r\n        {\r\n\r\n            // a an b have same sign, or division is exact\r\n\r\n            return m;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // a and b have opposite signs and division is not exact\r\n\r\n            return b + m;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer modulo when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     * </p>\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorDiv(long, int)\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static int floorMod(const long a, const int b) \r\n\r\n    {\r\n\r\n        return static_cast<int>( floorMod(a, static_cast<long>( b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Finds r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}.\r\n\r\n     * <p>\r\n\r\n     * This methods returns the same value as integer modulo when\r\n\r\n     * a and b are same signs, but returns a different value when\r\n\r\n     * they are opposite (i.e. q is negative).\r\n\r\n     * </p>\r\n\r\n     * @param a dividend\r\n\r\n     * @param b divisor\r\n\r\n     * @return r such that {@code a = q b + r} with {@code 0 <= r < b} if {@code b > 0} and {@code b < r <= 0} if {@code b < 0}\r\n\r\n     * @exception Math_Runtime_Exception if b == 0\r\n\r\n     * @see #floorDiv(long, long)\r\n\r\n     */\r\n\r\n    public static long floorMod(const long a, const long b) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (b == 0l) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n        }\r\n\r\n\r\n\r\n        const long m = a % b;\r\n\r\n        if ((a ^ b) >= 0l || m == 0l) \r\n\r\n        {\r\n\r\n            // a an b have same sign, or division is exact\r\n\r\n            return m;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // a and b have opposite signs and division is not exact\r\n\r\n            return b + m;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the first argument with the sign of the second argument.\r\n\r\n     * A NaN {@code sign} argument is treated as positive.\r\n\r\n     *\r\n\r\n     * @param magnitude the value to return\r\n\r\n     * @param sign the sign for the returned value\r\n\r\n     * @return the magnitude with the same sign as the {@code sign} argument\r\n\r\n     */\r\n\r\n    public static double copy_sign(double magnitude, double sign)\r\n\r\n    {\r\n\r\n        // The highest order bit is going to be zero if the\r\n\r\n        // highest order bit of m and s is the same and one otherwise.\r\n\r\n        // So (m^s) will be positive if both m and s have the same sign\r\n\r\n        // and negative otherwise.\r\n\r\n        const long m = Double.double_to_raw_long_bits(magnitude); // don't care about NaN\r\n\r\n        const long s = Double.double_to_raw_long_bits(sign);\r\n\r\n        if ((m^s) >= 0) \r\n\r\n        {\r\n\r\n            return magnitude;\r\n\r\n        }\r\n\r\n        return -magnitude; // flip sign\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the first argument with the sign of the second argument.\r\n\r\n     * A NaN {@code sign} argument is treated as positive.\r\n\r\n     *\r\n\r\n     * @param magnitude the value to return\r\n\r\n     * @param sign the sign for the returned value\r\n\r\n     * @return the magnitude with the same sign as the {@code sign} argument\r\n\r\n     */\r\n\r\n    public static float copy_sign(float magnitude, float sign)\r\n\r\n    {\r\n\r\n        // The highest order bit is going to be zero if the\r\n\r\n        // highest order bit of m and s is the same and one otherwise.\r\n\r\n        // So (m^s) will be positive if both m and s have the same sign\r\n\r\n        // and negative otherwise.\r\n\r\n        const int m = Float.float_to_raw_int_bits(magnitude);\r\n\r\n        const int s = Float.float_to_raw_int_bits(sign);\r\n\r\n        if ((m^s) >= 0) \r\n\r\n        {\r\n\r\n            return magnitude;\r\n\r\n        }\r\n\r\n        return -magnitude; // flip sign\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the exponent of a double number, removing the bias.\r\n\r\n     * <p>\r\n\r\n     * For double numbers of the form 2<sup>x</sup>, the unbiased\r\n\r\n     * exponent is exactly x.\r\n\r\n     * </p>\r\n\r\n     * @param d number from which exponent is requested\r\n\r\n     * @return exponent for d in IEEE754 representation, without bias\r\n\r\n     */\r\n\r\n    public static int get_exponent(const double d) \r\n\r\n    {\r\n\r\n        // NaN and Infinite will return 1024 anyhow so can use raw bits\r\n\r\n        return static_cast<int>( ((Double.double_to_raw_long_bits(d) >>> 52) & 0x7ff) - 1023;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the exponent of a float number, removing the bias.\r\n\r\n     * <p>\r\n\r\n     * For float numbers of the form 2<sup>x</sup>, the unbiased\r\n\r\n     * exponent is exactly x.\r\n\r\n     * </p>\r\n\r\n     * @param f number from which exponent is requested\r\n\r\n     * @return exponent for d in IEEE754 representation, without bias\r\n\r\n     */\r\n\r\n    public static int get_exponent(const float f) \r\n\r\n    {\r\n\r\n        // NaN and Infinite will return the same exponent anyhow so can use raw bits\r\n\r\n        return ((Float.float_to_raw_int_bits(f) >>> 23) & 0xff) - 127;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute Fused-multiply-add operation a * b + c.\r\n\r\n     * <p>\r\n\r\n     * This method was introduced in the regular {@code Math} and {@code StrictMath}\r\n\r\n     * methods with Java 9, and then added to Hipparchus for consistency. However, * a more general method was available in Hipparchus that also allow to repeat\r\n\r\n     * this computation across several terms: {@link Math_Arrays#linear_combination(std::vector<double>, std::vector<double>)}.\r\n\r\n     * The linear combination method should probably be preferred in most cases.\r\n\r\n     * </p>\r\n\r\n     * @param a first factor\r\n\r\n     * @param b second factor\r\n\r\n     * @param c additive term\r\n\r\n     * @return a * b + c, using extended precision in the multiplication\r\n\r\n     * @see Math_Arrays#linear_combination(std::vector<double>, std::vector<double>)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double, double, double)\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    public static double fma(const double& a, const double b, const double& c) \r\n\r\n    {\r\n\r\n        return Math_Arrays::linear_combination(a, b, 1.0, c);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute Fused-multiply-add operation a * b + c.\r\n\r\n     * <p>\r\n\r\n     * This method was introduced in the regular {@code Math} and {@code StrictMath}\r\n\r\n     * methods with Java 9, and then added to Hipparchus for consistency. However, * a more general method was available in Hipparchus that also allow to repeat\r\n\r\n     * this computation across several terms: {@link Math_Arrays#linear_combination(std::vector<double>, std::vector<double>)}.\r\n\r\n     * The linear combination method should probably be preferred in most cases.\r\n\r\n     * </p>\r\n\r\n     * @param a first factor\r\n\r\n     * @param b second factor\r\n\r\n     * @param c additive term\r\n\r\n     * @return a * b + c, using extended precision in the multiplication\r\n\r\n     * @see Math_Arrays#linear_combination(std::vector<double>, std::vector<double>)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double)\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double, double, double)\r\n\r\n     */\r\n\r\n    public static float fma(const float a, const float b, const float c) \r\n\r\n    {\r\n\r\n        return (float) Math_Arrays::linear_combination(a, b, 1.0, c);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square root of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return square root of a\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T sqrt(const T a) \r\n\r\n    {\r\n\r\n        return a.sqrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic cosine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return hyperbolic cosine of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T cosh(const T x) \r\n\r\n    {\r\n\r\n        return x.cosh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic sine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return hyperbolic sine of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T sinh(const T x) \r\n\r\n    {\r\n\r\n        return x.sinh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the hyperbolic tangent of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return hyperbolic tangent of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T tanh(const T x) \r\n\r\n    {\r\n\r\n        return x.tanh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic cosine of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return inverse hyperbolic cosine of a\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T acosh(const T a) \r\n\r\n    {\r\n\r\n        return a.acosh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic sine of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return inverse hyperbolic sine of a\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T asinh(const T a) \r\n\r\n    {\r\n\r\n        return a.asinh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the inverse hyperbolic tangent of a number.\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return inverse hyperbolic tangent of a\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T atanh(const T a) \r\n\r\n    {\r\n\r\n        return a.atanh();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the sign of a number.\r\n\r\n     * The sign is -1 for negative numbers, +1 for positive numbers and 0 otherwise, * for std::complex<double> number, it is extended on the unit circle (equivalent to z/|z|, * with special handling for 0 and NaN)\r\n\r\n     * @param a number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\r\n\r\n     * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T sign(const T a) \r\n\r\n    {\r\n\r\n        return a.sign();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Exponential function.\r\n\r\n     *\r\n\r\n     * Computes exp(x), function result is nearly rounded.   It will be correctly\r\n\r\n     * rounded to the theoretical value for 99.9% of input values, otherwise it will\r\n\r\n     * have a 1 ULP error.\r\n\r\n     *\r\n\r\n     * Method:\r\n\r\n     *    Lookup intVal = exp(int(x))\r\n\r\n     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\r\n\r\n     *    Compute z as the exponential of the remaining bits by a polynomial minus one\r\n\r\n     *    exp(x) = intVal * fracVal * (1 + z)\r\n\r\n     *\r\n\r\n     * Accuracy:\r\n\r\n     *    Calculation is done with 63 bits of precision, so result should be correctly\r\n\r\n     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return double e<sup>x</sup>\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T exp(const T x) \r\n\r\n    {\r\n\r\n        return x.exp();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute exp(x) - 1\r\n\r\n     * @param x number to compute shifted exponential\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return exp(x) - 1\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T expm1(const T x) \r\n\r\n    {\r\n\r\n        return x.expm1();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Natural logarithm.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return log(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T log(const T x) \r\n\r\n    {\r\n\r\n        return x.log();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes log(1 + x).\r\n\r\n     *\r\n\r\n     * @param x Number.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return {@code log(1 + x)}.\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T log1p(const T x) \r\n\r\n    {\r\n\r\n        return x.log1p();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the base 10 logarithm.\r\n\r\n     * @param x a number\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return log10(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T log10(const T x) \r\n\r\n    {\r\n\r\n        return x.log10();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Power function.  Compute x<sup>y</sup>.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @param y   a double\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return x<sup>y</sup>\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T pow(const T& x, const T& y) \r\n\r\n    {\r\n\r\n        return x.pow(y);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Power function.  Compute x<sup>y</sup>.\r\n\r\n     *\r\n\r\n     * @param x   a double\r\n\r\n     * @param y   a double\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return x<sup>y</sup>\r\n\r\n     * @since 1.7\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T pow(const T& x, const double y) \r\n\r\n    {\r\n\r\n        return x.pow(y);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Raise a double to an int power.\r\n\r\n     *\r\n\r\n     * @param d Number to raise.\r\n\r\n     * @param e Exponent.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return d<sup>e</sup>\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T pow(T d, int e) \r\n\r\n    {\r\n\r\n        return d.pow(e);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Sine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return sin(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T sin(const T x) \r\n\r\n    {\r\n\r\n        return x.sin();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Cosine function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return cos(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T cos(const T x) \r\n\r\n    {\r\n\r\n        return x.cos();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Tangent function.\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return tan(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T tan(const T x) \r\n\r\n    {\r\n\r\n        return x.tan();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Arctangent function\r\n\r\n     *  @param x a number\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     *  @return atan(x)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T atan(const T x) \r\n\r\n    {\r\n\r\n        return x.atan();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Two arguments arctangent function\r\n\r\n     * @param y ordinate\r\n\r\n     * @param x abscissa\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T atan2(const T y, const T x) \r\n\r\n    {\r\n\r\n        return y.atan2(x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the arc sine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return arc sine of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T asin(const T x) \r\n\r\n    {\r\n\r\n        return x.asin();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the arc cosine of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return arc cosine of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T acos(const T x) \r\n\r\n    {\r\n\r\n        return x.acos();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cubic root of a number.\r\n\r\n     * @param x number on which evaluation is done\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return cubic root of x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T cbrt(const T x) \r\n\r\n    {\r\n\r\n        return x.cbrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Norm.\r\n\r\n     * @param x number from which norm is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return norm(x)\r\n\r\n     * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  double norm(const T x) \r\n\r\n    {\r\n\r\n        return x.norm();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Absolute value.\r\n\r\n     * @param x number from which absolute value is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return abs(x)\r\n\r\n     * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T abs(const T x) \r\n\r\n    {\r\n\r\n        return x.abs();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Convert degrees to radians, with error of less than 0.5 ULP\r\n\r\n     *  @param x angle in degrees\r\n\r\n     *  @param <T> the type of the field element\r\n\r\n     *  @return x converted into radians\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T to_radians(T x) \r\n\r\n    {\r\n\r\n        return x.to_radians();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     *  Convert radians to degrees, with error of less than 0.5 ULP\r\n\r\n     *  @param x angle in radians\r\n\r\n     *  @param <T> the type of the field element\r\n\r\n     *  @return x converted into degrees\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T to_degrees(T x) \r\n\r\n    {\r\n\r\n        return x.to_degrees();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply a double number by a power of 2.\r\n\r\n     * @param d number to multiply\r\n\r\n     * @param n power of 2\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return d &times; 2<sup>n</sup>\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T scalb(const T d, const int& n) \r\n\r\n    {\r\n\r\n        return d.scalb(n);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute least significant bit (Unit in Last Position) for a number.\r\n\r\n     * @param x number from which ulp is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return ulp(x)\r\n\r\n     * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T ulp(const T x) \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(x.get_real())) \r\n\r\n        {\r\n\r\n            return x.new_instance(INFINITY);\r\n\r\n        }\r\n\r\n        return x.ulp();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the largest whole number smaller than x.\r\n\r\n     * @param x number from which floor is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return a double number f such that f is an integer f &lt;= x &lt; f + 1.0\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T floor(const T x) \r\n\r\n    {\r\n\r\n        return x.floor();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the smallest whole number larger than x.\r\n\r\n     * @param x number from which ceil is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return a double number c such that c is an integer c - 1.0 &lt; x &lt;= c\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T ceil(const T x) \r\n\r\n    {\r\n\r\n        return x.ceil();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\r\n\r\n     * @param x number from which nearest whole number is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return a double number r such that r is an integer r - 0.5 &lt;= x &lt;= r + 0.5\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T rint(const T x) \r\n\r\n    {\r\n\r\n        return x.rint();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the closest long to x.\r\n\r\n     * @param x number from which closest long is requested\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return closest long to x\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  long round(const T x) \r\n\r\n    {\r\n\r\n        return x.round();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T min(const T& a, const T& b) \r\n\r\n    {\r\n\r\n        const double& aR = a.get_real();\r\n\r\n        const double bR = b.get_real();\r\n\r\n        if (aR < bR) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\nelse if (bR < aR) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // either the numbers are equal, or one of them is a NaN\r\n\r\n            return std::isnan(aR) ? a : b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T min(const T& a, const double& b) \r\n\r\n    {\r\n\r\n        const double& aR = a.get_real();\r\n\r\n        if (aR < b) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\nelse if (b < aR) \r\n\r\n        {\r\n\r\n            return a.get_field().get_zero().add(b);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // either the numbers are equal, or one of them is a NaN\r\n\r\n            return std::isnan(aR) ? a : a.get_field().get_zero().add(b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T max(const T& a, const T& b) \r\n\r\n    {\r\n\r\n        const double& aR = a.get_real();\r\n\r\n        const double bR = b.get_real();\r\n\r\n        if (aR < bR) \r\n\r\n        {\r\n\r\n            return b;\r\n\r\n        }\r\n\r\nelse if (bR < aR) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // either the numbers are equal, or one of them is a NaN\r\n\r\n            return std::isnan(aR) ? a : b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T max(const T& a, const double& b) \r\n\r\n    {\r\n\r\n        const double& aR = a.get_real();\r\n\r\n        if (aR < b) \r\n\r\n        {\r\n\r\n            return a.get_field().get_zero().add(b);\r\n\r\n        }\r\n\r\nelse if (b < aR) \r\n\r\n        {\r\n\r\n            return a;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // either the numbers are equal, or one of them is a NaN\r\n\r\n            return std::isnan(aR) ? a : a.get_field().get_zero().add(b);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\r\n\r\n     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\r\n\r\n     * avoiding intermediate overflow or underflow.\r\n\r\n     *\r\n\r\n     * <ul>\r\n\r\n     * <li> If either argument is infinite, then the result is positive infinity.</li>\r\n\r\n     * <li> else, if either argument is NaN then the result is NaN.</li>\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param x a value\r\n\r\n     * @param y a value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T hypot(const T& x, const T& y) \r\n\r\n    {\r\n\r\n        return x.hypot(y);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the remainder as prescribed by the IEEE 754 standard.\r\n\r\n     * The remainder value is mathematically equal to {@code x - y*n}\r\n\r\n     * where {@code n} is the mathematical integer closest to the exact mathematical value\r\n\r\n     * of the quotient {@code x/y}.\r\n\r\n     * If two mathematical integers are equally close to {@code x/y} then\r\n\r\n     * {@code n} is the integer that is even.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>If either operand is NaN, the result is NaN.</li>\r\n\r\n     * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\r\n\r\n     * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\r\n\r\n     * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\r\n\r\n     * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\r\n\r\n     * </ul>\r\n\r\n     * @param dividend the number to be divided\r\n\r\n     * @param divisor the number by which to divide\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return the remainder, rounded\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T IEE_Eremainder(const T dividend, const double divisor) \r\n\r\n    {\r\n\r\n        return dividend.remainder(divisor);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the remainder as prescribed by the IEEE 754 standard.\r\n\r\n     * The remainder value is mathematically equal to {@code x - y*n}\r\n\r\n     * where {@code n} is the mathematical integer closest to the exact mathematical value\r\n\r\n     * of the quotient {@code x/y}.\r\n\r\n     * If two mathematical integers are equally close to {@code x/y} then\r\n\r\n     * {@code n} is the integer that is even.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>If either operand is NaN, the result is NaN.</li>\r\n\r\n     * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\r\n\r\n     * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\r\n\r\n     * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\r\n\r\n     * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\r\n\r\n     * </ul>\r\n\r\n     * @param dividend the number to be divided\r\n\r\n     * @param divisor the number by which to divide\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return the remainder, rounded\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T IEE_Eremainder(const T dividend, const T divisor) \r\n\r\n    {\r\n\r\n        return dividend.remainder(divisor);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the first argument with the sign of the second argument.\r\n\r\n     * A NaN {@code sign} argument is treated as positive.\r\n\r\n     *\r\n\r\n     * @param magnitude the value to return\r\n\r\n     * @param sign the sign for the returned value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return the magnitude with the same sign as the {@code sign} argument\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T copy_sign(T magnitude, T sign) \r\n\r\n    {\r\n\r\n        return magnitude.copy_sign(sign);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the first argument with the sign of the second argument.\r\n\r\n     * A NaN {@code sign} argument is treated as positive.\r\n\r\n     *\r\n\r\n     * @param magnitude the value to return\r\n\r\n     * @param sign the sign for the returned value\r\n\r\n     * @param <T> the type of the field element\r\n\r\n     * @return the magnitude with the same sign as the {@code sign} argument\r\n\r\n     * @since 1.3\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  T copy_sign(T magnitude, double sign) \r\n\r\n    {\r\n\r\n        return magnitude.copy_sign(sign);\r\n\r\n    }\r\n\r\n\r\n\r\n//    /**\r\n\r\n//     * Print out contents of arrays, and check the length.\r\n\r\n//     * <p>used to generate the preset arrays originally.</p>\r\n\r\n//     * @param a unused\r\n\r\n//     */\r\n\r\n//    public static void main(std::string[] a) \r\n\r\n{\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "EXP_INT_TABLE_A", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "EXP_INT_TABLE_B", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "EXP_FRAC_TABLE_A", EXP_FRAC_TABLE_LEN, Exp_fracTable.EXP_FRAC_TABLE_A);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "EXP_FRAC_TABLE_B", EXP_FRAC_TABLE_LEN, Exp_fracTable.EXP_FRAC_TABLE_B);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "LN_MANT",LN_MANT_LEN, lnMant.LN_MANT);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "SINE_TABLE_A", SINE_TABLE_LEN, SINE_TABLE_A);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "SINE_TABLE_B", SINE_TABLE_LEN, SINE_TABLE_B);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "COSINE_TABLE_A", SINE_TABLE_LEN, COSINE_TABLE_A);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "COSINE_TABLE_B", SINE_TABLE_LEN, COSINE_TABLE_B);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "TANGENT_TABLE_A", SINE_TABLE_LEN, TANGENT_TABLE_A);\r\n\r\n//        Fast_Math_Calc.printarray(System.out, "TANGENT_TABLE_B", SINE_TABLE_LEN, TANGENT_TABLE_B);\r\n\r\n//    }\r\n\r\n\r\n\r\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\r\n\r\n    private static class ExpIntTable \r\n\r\n    {\r\n\r\n        /** Exponential evaluated at integer values, * exp(x) =  exp_int_table_a[x + EXP_INT_TABLE_MAX_INDEX] + exp_int_table_b[x+EXP_INT_TABLE_MAX_INDEX].\r\n\r\n         */\r\n\r\n        private static const std::vector<double> EXP_INT_TABLE_A;\r\n\r\n        /** Exponential evaluated at integer values, * exp(x) =  exp_int_table_a[x + EXP_INT_TABLE_MAX_INDEX] + exp_int_table_b[x+EXP_INT_TABLE_MAX_INDEX]\r\n\r\n         */\r\n\r\n        private static const std::vector<double> EXP_INT_TABLE_B;\r\n\r\n\r\n\r\n        static \r\n\r\n        {\r\n\r\n            if (RECOMPUTE_TABLES_AT_RUNTIME) \r\n\r\n            {\r\n\r\n                EXP_INT_TABLE_A = std::vector<double>(FastMath.EXP_INT_TABLE_LEN];\r\n\r\n                EXP_INT_TABLE_B = std::vector<double>(FastMath.EXP_INT_TABLE_LEN];\r\n\r\n\r\n\r\n                const double tmp[] = std::vector<double>(2);\r\n\r\n                const double recip[] = std::vector<double>(2);\r\n\r\n\r\n\r\n                // Populate expIntTable\r\n\r\n                for (int i{}; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) \r\n\r\n                {\r\n\r\n                    Fast_Math_Calc.expint(i, tmp);\r\n\r\n                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\r\n\r\n                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\r\n\r\n\r\n\r\n                    if (i != 0) \r\n\r\n                    {\r\n\r\n                        // Negative integer powers\r\n\r\n                        Fast_Math_Calc.split_reciprocal(tmp, recip);\r\n\r\n                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\r\n\r\n                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                EXP_INT_TABLE_A = Fast_Math_Literal_Arrays.load_exp_int_a();\r\n\r\n                EXP_INT_TABLE_B = Fast_Math_Literal_Arrays.load_exp_int_b();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\r\n\r\n    private static class Exp_fracTable \r\n\r\n    {\r\n\r\n        /** Exponential over the range of 0 - 1 in increments of 2^-10\r\n\r\n         * exp(x/1024) =  exp_frac_table_a[x] + exp_frac_table_b[x].\r\n\r\n         * 1024 = 2^10\r\n\r\n         */\r\n\r\n        private static const std::vector<double> EXP_FRAC_TABLE_A;\r\n\r\n        /** Exponential over the range of 0 - 1 in increments of 2^-10\r\n\r\n         * exp(x/1024) =  exp_frac_table_a[x] + exp_frac_table_b[x].\r\n\r\n         */\r\n\r\n        private static const std::vector<double> EXP_FRAC_TABLE_B;\r\n\r\n\r\n\r\n        static \r\n\r\n        {\r\n\r\n            if (RECOMPUTE_TABLES_AT_RUNTIME) \r\n\r\n            {\r\n\r\n                EXP_FRAC_TABLE_A = std::vector<double>(FastMath.EXP_FRAC_TABLE_LEN];\r\n\r\n                EXP_FRAC_TABLE_B = std::vector<double>(FastMath.EXP_FRAC_TABLE_LEN];\r\n\r\n\r\n\r\n                const double tmp[] = std::vector<double>(2);\r\n\r\n\r\n\r\n                // Populate exp_fracTable\r\n\r\n                const double factor = 1.0/ (EXP_FRAC_TABLE_LEN - 1);\r\n\r\n                for (int i{}; i < EXP_FRAC_TABLE_A.size(); i++) \r\n\r\n                {\r\n\r\n                    Fast_Math_Calc.slowexp(i * factor, tmp);\r\n\r\n                    EXP_FRAC_TABLE_A[i] = tmp[0];\r\n\r\n                    EXP_FRAC_TABLE_B[i] = tmp[1];\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                EXP_FRAC_TABLE_A = Fast_Math_Literal_Arrays.load_exp_frac_a();\r\n\r\n                EXP_FRAC_TABLE_B = Fast_Math_Literal_Arrays.load_exp_frac_b();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\r\n\r\n    private static class lnMant \r\n\r\n    {\r\n\r\n        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\r\n\r\n        private static const std::vector<std::vector<double>> LN_MANT;\r\n\r\n\r\n\r\n        static \r\n\r\n        {\r\n\r\n            if (RECOMPUTE_TABLES_AT_RUNTIME) \r\n\r\n            {\r\n\r\n                LN_MANT = std::vector<double>(FastMath.LN_MANT_LEN][];\r\n\r\n\r\n\r\n                // Populate lnMant table\r\n\r\n                for (int i{}; i < LN_MANT.size(); i++) \r\n\r\n                {\r\n\r\n                    const double d = Double.long_bits_to_double( ((static_cast<long>( i) << 42) | 0x3ff0000000000000L );\r\n\r\n                    LN_MANT[i] = Fast_Math_Calc.slow_log(d);\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                LN_MANT = Fast_Math_Literal_Arrays.load_ln_mant();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Enclose the Cody/Waite reduction (used in "sin", "cos" and "tan"). */\r\n\r\n    private static class CodyWaite \r\n\r\n    {\r\n\r\n        /** k */\r\n\r\n        private const int constK;\r\n\r\n        /** remA */\r\n\r\n        private const double const_rem_a;\r\n\r\n        /** remB */\r\n\r\n        private const double const_rem_b;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * @param xa Argument.\r\n\r\n         */\r\n\r\n        CodyWaite(double xa) \r\n\r\n        {\r\n\r\n            // Estimate k.\r\n\r\n            //k = static_cast<int>((xa / 1.5707963267948966);\r\n\r\n            int k = static_cast<int>((xa * 0.6366197723675814);\r\n\r\n\r\n\r\n            // Compute remainder.\r\n\r\n            double remA;\r\n\r\n            double remB;\r\n\r\n            while (true) \r\n\r\n            {\r\n\r\n                double a = -k * 1.570796251296997;\r\n\r\n                remA = xa + a;\r\n\r\n                remB = -(remA - xa - a);\r\n\r\n\r\n\r\n                a = -k * 7.549789948768648E-8;\r\n\r\n                double b = remA;\r\n\r\n                remA = a + b;\r\n\r\n                remB += -(remA - b - a);\r\n\r\n\r\n\r\n                a = -k * 6.123233995736766E-17;\r\n\r\n                b = remA;\r\n\r\n                remA = a + b;\r\n\r\n                remB += -(remA - b - a);\r\n\r\n\r\n\r\n                if (remA > 0) \r\n\r\n                {\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n\r\n\r\n                // Remainder is negative, so decrement k and try again.\r\n\r\n                // This should only happen if the input is very close\r\n\r\n                // to an even multiple of pi/2.\r\n\r\n                --k;\r\n\r\n            }\r\n\r\n\r\n\r\n            this.constK = k;\r\n\r\n            this.const_rem_a = remA;\r\n\r\n            this.const_rem_b = remB;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * @return k\r\n\r\n         */\r\n\r\n        int get_k() \r\n\r\n        {\r\n\r\n            return constK;\r\n\r\n        }\r\n\r\n        /**\r\n\r\n         * @return remA\r\n\r\n         */\r\n\r\n        double get_remA() \r\n\r\n        {\r\n\r\n            return const_rem_a;\r\n\r\n        }\r\n\r\n        /**\r\n\r\n         * @return remB\r\n\r\n         */\r\n\r\n        double get_remB() \r\n\r\n        {\r\n\r\n            return const_rem_b;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n