/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.util;\r\n\r\n\r\n\r\n//import java.lang.reflect.Array;\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.Arrays;\r\n\r\n//import java.util.Collections;\r\n\r\n//import java.util.Comparator;\r\n\r\n//import java.util.Iterator;\r\n\r\n//import java.util.List;\r\n\r\n//import java.util.Tree_Set;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Field_Element;\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.random.Random_Generator;\r\n\r\n//import org.hipparchus.random.Well19937c;\r\n\r\n#include <vector>\r\n\r\n#include <cmath>\r\n\r\n#include "MathUtils.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * Arrays utilities.\r\n\r\n */\r\n\r\nclass Math_Arrays \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /**\r\n\r\n     * Private constructor.\r\n\r\n     */\r\n\r\n    Math_Arrays() = default;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Real-valued function that operates on an array or a part of it.\r\n\r\n     */\r\n\r\n    class Function\r\n\r\n    {\r\n\r\n        /**\r\n\r\n         * Operates on an entire array.\r\n\r\n         *\r\n\r\n         * @param array Array to operate on.\r\n\r\n         * @return the result of the operation.\r\n\r\n         */\r\n\r\n        double evaluate(std::vector<double> array);\r\n\r\n        /**\r\n\r\n         * @param array Array to operate on.\r\n\r\n         * @param start_index Index of the first element to take into account.\r\n\r\n         * @param num_elements Number of elements to take into account.\r\n\r\n         * @return the result of the operation.\r\n\r\n         */\r\n\r\n        double evaluate(std::vector<double> array, int start_index, int num_elements);\r\n\r\n    };\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a copy of an array scaled by a value.\r\n\r\n     *\r\n\r\n     * @param arr Array to scale.\r\n\r\n     * @param val Scalar.\r\n\r\n     * @return scaled copy of array with each entry multiplied by val.\r\n\r\n     */\r\n\r\n    static std::vector<double> scale(const double& val, const std::vector<double>& arr) \r\n\r\n    {\r\n\r\n        auto new_arr = std::vector<double>(arr.size());\r\n\r\n        for (int i{}; i < arr.size(); i++) \r\n\r\n        {\r\n\r\n            new_arr[i] = arr[i] * val;\r\n\r\n        }\r\n\r\n        return new_arr;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply each element of an array by a value.\r\n\r\n     * <p>\r\n\r\n     * The array is modified in place (no copy is created).\r\n\r\n     *\r\n\r\n     * @param arr Array to scale\r\n\r\n     * @param val Scalar\r\n\r\n     */\r\n\r\n    static void scale_in_place(const double& val, std::vector<double>& arr) \r\n\r\n    {\r\n\r\n        for (int i{}; i < arr.size(); i++) \r\n\r\n        {\r\n\r\n            arr[i] *= val;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an array whose contents will be the element-by-element\r\n\r\n     * addition of the arguments.\r\n\r\n     *\r\n\r\n     * @param a First term of the addition.\r\n\r\n     * @param b Second term of the addition.\r\n\r\n     * @return a array {@code r} where {@code r[i] = a[i] + b[i]}.\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static std::vector<double> ebe_add(std::vector<double>& a, const std::vector<double>& b)\r\n\r\n    {\r\n\r\n        check_equal_length(a, b);\r\n\r\n\r\n\r\n        std::vector<double> result = a;\r\n\r\n        for (int i{}; i < a.size(); i++) \r\n\r\n        {\r\n\r\n            result[i] += b[i];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an array whose contents will be the element-by-element\r\n\r\n     * subtraction of the second argument from the first.\r\n\r\n     *\r\n\r\n     * @param a First term.\r\n\r\n     * @param b Element to be subtracted.\r\n\r\n     * @return a array {@code r} where {@code r[i] = a[i] - b[i]}.\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static std::vector<double> ebe_subtract(const std::vector<double>& a, const std::vector<double>& b)\r\n\r\n    {\r\n\r\n        check_equal_length(a, b);\r\n\r\n\r\n\r\n        std::vector<double> result = a;\r\n\r\n        for (int i{}; i < a.size(); i++) \r\n\r\n        {\r\n\r\n            result[i] -= b[i];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Creates an array whose contents will be the element-by-element\r\n\r\n     * multiplication of the arguments.\r\n\r\n     *\r\n\r\n     * @param a First factor of the multiplication.\r\n\r\n     * @param b Second factor of the multiplication.\r\n\r\n     * @return a array {@code r} where {@code r[i] = a[i] * b[i]}.\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static std::vector<double> ebe_multiply(const std::vector<double>& a, const std::vector<double>& b)\r\n\r\n    {\r\n\r\n        check_equal_length(a, b);\r\n\r\n\r\n\r\n        std::vector<double> result = a;\r\n\r\n        for (int i{}; i < a.size(); i++) \r\n\r\n        {\r\n\r\n            result[i] *= b[i];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Creates an array whose contents will be the element-by-element\r\n\r\n     * division of the first argument by the second.\r\n\r\n     *\r\n\r\n     * @param a Numerator of the division.\r\n\r\n     * @param b Denominator of the division.\r\n\r\n     * @return a array {@code r} where {@code r[i] = a[i] / b[i]}.\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static std::vector<double> ebe_divide(const std::vector<double>& a, const std::vector<double>& b)\r\n\r\n    {\r\n\r\n        check_equal_length(a, b);\r\n\r\n\r\n\r\n        std::vector<double> result = a;\r\n\r\n        for (int i{}; i < a.size(); i++) \r\n\r\n        {\r\n\r\n            result[i] /= b[i];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>1</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static double distance1(const std::vector<double>& p1, const std::vector<double>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        double sum{};\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            sum += std::abs(p1[i] - p2[i]);\r\n\r\n        }\r\n\r\n        return sum;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>1</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static int distance1(const std::vector<int>& p1, const std::vector<int>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        int sum = 0;\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            sum += std::abs(p1[i] - p2[i]);\r\n\r\n        }\r\n\r\n        return sum;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>2</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static double distance(const std::vector<double>& p1, const std::vector<double>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        double sum{};\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            const double dp = p1[i] - p2[i];\r\n\r\n            sum += dp * dp;\r\n\r\n        }\r\n\r\n        return std::sqrt(sum);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the cosine of the angle between two vectors.\r\n\r\n     *\r\n\r\n     * @param v1 Cartesian coordinates of the first vector.\r\n\r\n     * @param v2 Cartesian coordinates of the second vector.\r\n\r\n     * @return the cosine of the angle between the vectors.\r\n\r\n     */\r\n\r\n    static double cos_angle(const std::vector<double>& v1, const std::vector<double>& v2) \r\n\r\n    {\r\n\r\n        return linear_combination(v1, v2) / (safe_norm(v1) * safe_norm(v2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>2</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static double distance(const std::vector<int>& p1, const std::vector<int>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        double sum{};\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            const double dp = p1[i] - p2[i];\r\n\r\n            sum += dp * dp;\r\n\r\n        }\r\n\r\n        return std::sqrt(sum);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>&infin;</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static double distance_inf(const std::vector<double>& p1, const std::vector<double>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        double max = 0;\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            max = std::max(max, std::abs(p1[i] - p2[i]));\r\n\r\n        }\r\n\r\n        return max;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\r\n\r\n     *\r\n\r\n     * @param p1 the first point\r\n\r\n     * @param p2 the second point\r\n\r\n     * @return the L<sub>&infin;</sub> distance between the two points\r\n\r\n     * @ if the array lengths differ.\r\n\r\n     */\r\n\r\n    static int distance_inf(const std::vector<int>& p1, const std::vector<int>& p2)\r\n\r\n    {\r\n\r\n        check_equal_length(p1, p2);\r\n\r\n        int max = 0;\r\n\r\n        for (int i{}; i < p1.size(); i++) \r\n\r\n        {\r\n\r\n            max = std::max(max, std::abs(p1[i] - p2[i]));\r\n\r\n        }\r\n\r\n        return max;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Specification of ordering direction.\r\n\r\n     */\r\n\r\n    enum Order_Direction\r\n\r\n    {\r\n\r\n        /** Constant for increasing direction. */\r\n\r\n        INCREASING, /** Constant for decreasing direction. */\r\n\r\n        DECREASING\r\n\r\n    };\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that an array is monotonically increasing or decreasing.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the elements in the specified array\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @return {@code true} if sorted, {@code false} otherwise.\r\n\r\n     */\r\n\r\n    //static <T extends Comparable<? super T>> bool is_monotonic(std::vector<T>& val, const Order_Direction& dir, bool strict) \r\n\r\n    //{\r\n\r\n    //    T previous = val[0];\r\n\r\n    //    const int max = val.size();\r\n\r\n    //    for (int i{ 1 }; i < max; i++) \r\n\r\n    //    {\r\n\r\n    //        const int comp;\r\n\r\n    //        switch (dir) \r\n\r\n    //        {\r\n\r\n    //        case INCREASING:\r\n\r\n    //            comp = previous.compare_to(val[i]);\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (comp >= 0) \r\n\r\n    //                {\r\n\r\n    //                    return false;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (comp > 0) \r\n\r\n    //                {\r\n\r\n    //                    return false;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        case DECREASING:\r\n\r\n    //            comp = val[i].compare_to(previous);\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (comp >= 0) \r\n\r\n    //                {\r\n\r\n    //                    return false;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (comp > 0) \r\n\r\n    //                {\r\n\r\n    //                   return false;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        default:\r\n\r\n    //            // Should never happen.\r\n\r\n    //            throw Math_Runtime_Exception.create_internal_error();\r\n\r\n    //        }\r\n\r\n\r\n\r\n    //        previous = val[i];\r\n\r\n    //    }\r\n\r\n    //    return true;\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that an array is monotonically increasing or decreasing.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @return {@code true} if sorted, {@code false} otherwise.\r\n\r\n     */\r\n\r\n    //static bool is_monotonic(const std::vector<double>& val, const Order_Direction& dir, bool strict) \r\n\r\n    //{\r\n\r\n    //    return check_order(val, dir, strict, false);\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @param abort Whether to throw an exception if the check fails.\r\n\r\n     * @return {@code true} if the arrays have the same length.\r\n\r\n     * @ if the lengths differ and\r\n\r\n     * {@code abort} is {@code true}.\r\n\r\n     */\r\n\r\n    static bool check_equal_length(const std::vector<double>& a, const std::vector<double>& b, bool abort) \r\n\r\n    {\r\n\r\n        if (a.size() == b.size()) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        /*if (abort) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, a.size(), b.size());\r\n\r\n        }*/\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @ if the lengths differ.\r\n\r\n     */\r\n\r\n    static void check_equal_length(const std::vector<double>& a, const std::vector<double>& b) \r\n\r\n    {\r\n\r\n        check_equal_length(a, b, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @param abort Whether to throw an exception if the check fails.\r\n\r\n     * @return {@code true} if the arrays have the same length.\r\n\r\n     * @ if the lengths differ and\r\n\r\n     * {@code abort} is {@code true}.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    /*static  bool check_equal_length(const std::vector<T>& a, const std::vector<T>& b, bool abort) \r\n\r\n    {\r\n\r\n        if (a.size() == b.size()) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        if (abort) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, a.size(), b.size());\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }*/\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @ if the lengths differ.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    /*static  void check_equal_length(const std::vector<T>& a, const std::vector<T>& b) \r\n\r\n    {\r\n\r\n        check_equal_length(a, b, true);\r\n\r\n    }*/\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @param abort Whether to throw an exception if the check fails.\r\n\r\n     * @return {@code true} if the arrays have the same length.\r\n\r\n     * @ if the lengths differ and\r\n\r\n     * {@code abort} is {@code true}.\r\n\r\n     */\r\n\r\n    static bool check_equal_length(const std::vector<int>& a, const std::vector<int>& b, bool abort) \r\n\r\n    {\r\n\r\n        if (a.size() == b.size()) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        /*if (abort) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, a.size(), b.size());\r\n\r\n        }*/\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that both arrays have the same length.\r\n\r\n     *\r\n\r\n     * @param a Array.\r\n\r\n     * @param b Array.\r\n\r\n     * @ if the lengths differ.\r\n\r\n     */\r\n\r\n    static void check_equal_length(const std::vector<int>& a, const std::vector<int>& b) \r\n\r\n    {\r\n\r\n        check_equal_length(a, b, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @param abort Whether to throw an exception if the check fails.\r\n\r\n     * @return {@code true} if the array is sorted.\r\n\r\n     * @ if the array is not sorted\r\n\r\n     * and {@code abort} is {@code true}.\r\n\r\n     */\r\n\r\n    //static bool check_order(const std::vector<double>& val, const Order_Direction& dir, bool strict, bool abort)\r\n\r\n    //     \r\n\r\n    //    {\r\n\r\n    //    double previous = val[0];\r\n\r\n    //    const int max = val.size();\r\n\r\n\r\n\r\n    //    int index;\r\n\r\n    //    ITEM:\r\n\r\n    //    for (index = 1; index < max; index++) \r\n\r\n    //    {\r\n\r\n    //        switch (dir) \r\n\r\n    //        {\r\n\r\n    //        case INCREASING:\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (val[index] <= previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (val[index] < previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        case DECREASING:\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (val[index] >= previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (val[index] > previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        default:\r\n\r\n    //            // Should never happen.\r\n\r\n    //            throw Math_Runtime_Exception.create_internal_error();\r\n\r\n    //        }\r\n\r\n\r\n\r\n    //        previous = val[index];\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    if (index == max) \r\n\r\n    //    {\r\n\r\n    //        // Loop completed.\r\n\r\n    //        return true;\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    // Loop early exit means wrong ordering.\r\n\r\n    //    if (abort) \r\n\r\n    //    {\r\n\r\n    //        throw (dir == Math_Arrays::Order_Direction::INCREASING ?\r\n\r\n    //                                                (strict ?\r\n\r\n    //                                                 Localized_Core_Formats.NOT_STRICTLY_INCREASING_SEQUENCE :\r\n\r\n    //                                                 Localized_Core_Formats.NOT_INCREASING_SEQUENCE) :\r\n\r\n    //                                                (strict ?\r\n\r\n    //                                                 Localized_Core_Formats.NOT_STRICTLY_DECREASING_SEQUENCE :\r\n\r\n    //                                                 Localized_Core_Formats.NOT_DECREASING_SEQUENCE), val[index], previous, index, index - 1);\r\n\r\n    //    }\r\n\r\n    //       else \r\n\r\n    //    {\r\n\r\n    //        return false;\r\n\r\n    //    }\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @ if the array is not sorted.\r\n\r\n     */\r\n\r\n    //static void check_order(const std::vector<double>& val, const Order_Direction& dir, bool strict)  \r\n\r\n    //{\r\n\r\n    //    check_order(val, dir, strict, true);\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted in strictly increasing order.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @ if the array is not sorted.\r\n\r\n     */\r\n\r\n    //static void check_order(const std::vector<double>& val)  \r\n\r\n    //{\r\n\r\n    //    check_order(val, Order_Direction.INCREASING, true);\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @param abort Whether to throw an exception if the check fails.\r\n\r\n     * @return {@code true} if the array is sorted.\r\n\r\n     * @ if the array is not sorted\r\n\r\n     * and {@code abort} is {@code true}.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    //static bool check_order(const std::vector<T>& val, const Order_Direction& dir, bool strict, bool abort)\r\n\r\n    //{\r\n\r\n    //    double previous = val[0].get_real();\r\n\r\n    //    const int max = val.size();\r\n\r\n\r\n\r\n    //    int index;\r\n\r\n    //    ITEM:\r\n\r\n    //    for (index = 1; index < max; index++) \r\n\r\n    //    {\r\n\r\n    //        switch (dir) \r\n\r\n    //        {\r\n\r\n    //        case INCREASING:\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (val[index].get_real() <= previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (val[index].get_real() < previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        case DECREASING:\r\n\r\n    //            if (strict) \r\n\r\n    //            {\r\n\r\n    //                if (val[index].get_real() >= previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            else \r\n\r\n    //            {\r\n\r\n    //                if (val[index].get_real() > previous) \r\n\r\n    //                {\r\n\r\n    //                    break ITEM;\r\n\r\n    //                }\r\n\r\n    //            }\r\n\r\n    //            break;\r\n\r\n    //        default:\r\n\r\n    //            // Should never happen.\r\n\r\n    //            throw Math_Runtime_Exception.create_internal_error();\r\n\r\n    //        }\r\n\r\n\r\n\r\n    //        previous = val[index].get_real();\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    if (index == max) \r\n\r\n    //    {\r\n\r\n    //        // Loop completed.\r\n\r\n    //        return true;\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    // Loop early exit means wrong ordering.\r\n\r\n    //    if (abort) \r\n\r\n    //    {\r\n\r\n    //        throw (dir == Math_Arrays::Order_Direction::INCREASING ?\r\n\r\n    //                                                (strict ?\r\n\r\n    //                                                 Localized_Core_Formats.NOT_STRICTLY_INCREASING_SEQUENCE :\r\n\r\n    //                                                 Localized_Core_Formats.NOT_INCREASING_SEQUENCE) :\r\n\r\n    //                                                (strict ?\r\n\r\n    //                                                 Localized_Core_Formats.NOT_STRICTLY_DECREASING_SEQUENCE :\r\n\r\n    //                                                 Localized_Core_Formats.NOT_DECREASING_SEQUENCE), val[index], previous, index, index - 1);\r\n\r\n    //    }\r\n\r\n    //    else \r\n\r\n    //    {\r\n\r\n    //        return false;\r\n\r\n    //    }\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @param dir Ordering direction.\r\n\r\n     * @param strict Whether the order should be strict.\r\n\r\n     * @ if the array is not sorted.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    //static  void check_order(const std::vector<T>& val, const Order_Direction& dir, bool strict)  \r\n\r\n    //{\r\n\r\n    //    check_order(val, dir, strict, true);\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the given array is sorted in strictly increasing order.\r\n\r\n     *\r\n\r\n     * @param val Values.\r\n\r\n     * @ if the array is not sorted.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    //static  void check_order(const std::vector<T>& val)  \r\n\r\n    //{\r\n\r\n    //    check_order(val, Order_Direction.INCREASING, true);\r\n\r\n    //}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Throws  if the input array is not rectangular.\r\n\r\n     *\r\n\r\n     * @param in array to be tested\r\n\r\n     * @Null_Argument_Exception if input array is null\r\n\r\n     * @ if input array is not rectangular\r\n\r\n     */\r\n\r\n    static void check_rectangular(const std::vector<std::vector<long>>& in)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(in);\r\n\r\n        for (int i{ 1 }; i < in.size(); i++) \r\n\r\n        {\r\n\r\n            if (ele.size() != ele.size()) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIFFERENT_ROWS_LENGTHS, in[i].size(), in[0].size());\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that all entries of the input array are strictly positive.\r\n\r\n     *\r\n\r\n     * @param in Array to be tested\r\n\r\n     * @ if any entries of the array are not\r\n\r\n     * strictly positive.\r\n\r\n     */\r\n\r\n    static void check_positive(const std::vector<double>& in)\r\n\r\n    {\r\n\r\n        for (const auto& ele : in)\r\n\r\n        {\r\n\r\n            if (ele <= 0)\r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, in[i], 0);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that no entry of the input array is {@code NaN}.\r\n\r\n     *\r\n\r\n     * @param in Array to be tested.\r\n\r\n     * @ if an entry is {@code NaN}.\r\n\r\n     */\r\n\r\n    static void check_not_na_n(const std::vector<double>& in)\r\n\r\n    {\r\n\r\n        for (const auto& ele : in)\r\n\r\n        {\r\n\r\n            if (std::isnan(ele))\r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NAN_ELEMENT_AT_INDEX, i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that all entries of the input array are &gt;= 0.\r\n\r\n     *\r\n\r\n     * @param in Array to be tested\r\n\r\n     * @ if any array entries are less than 0.\r\n\r\n     */\r\n\r\n    static void check_non_negative(const std::vector<long>& in)\r\n\r\n    {\r\n\r\n        for (const auto& ele : in)\r\n\r\n        {\r\n\r\n            if (ele < 0)\r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NUMBER_TOO_SMALL, in[i], 0);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check all entries of the input array are &gt;= 0.\r\n\r\n     *\r\n\r\n     * @param in Array to be tested\r\n\r\n     * @ if any array entries are less than 0.\r\n\r\n     */\r\n\r\n    static void check_non_negative(const std::vector<std::vector<long>>& in)\r\n\r\n    {\r\n\r\n        for (const auto& row : in)\r\n\r\n        {\r\n\r\n            for (const auto& ele : row)\r\n\r\n            {\r\n\r\n                if (ele < 0)\r\n\r\n                {\r\n\r\n                    throw (Localized_Core_Formats.NUMBER_TOO_SMALL, ele, 0);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\r\n\r\n     * Translation of the minpack enorm subroutine.\r\n\r\n     *\r\n\r\n     * The redistribution policy for MINPACK is available\r\n\r\n     * <a href="http://www.netlib.org/minpack/disclaimer">here</a>, for\r\n\r\n     * convenience, it is reproduced below.</p>\r\n\r\n     *\r\n\r\n     * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">\r\n\r\n     * <tr><td>\r\n\r\n     *    Minpack Copyright Notice (1999) University of Chicago.\r\n\r\n     *    All rights reserved\r\n\r\n     * </td></tr>\r\n\r\n     * <tr><td>\r\n\r\n     * Redistribution and use in source and binary forms, with or without\r\n\r\n     * modification, are permitted provided that the following conditions\r\n\r\n     * are met:\r\n\r\n     * <ol>\r\n\r\n     *  <li>Redistributions of source code must retain the above copyright\r\n\r\n     *      notice, this list of conditions and the following disclaimer.</li>\r\n\r\n     * <li>Redistributions in binary form must reproduce the above\r\n\r\n     *     copyright notice, this list of conditions and the following\r\n\r\n     *     disclaimer in the documentation and/or other materials provided\r\n\r\n     *     with the distribution.</li>\r\n\r\n     * <li>The end-user documentation included with the redistribution, if any, *     must include the following acknowledgment:\r\n\r\n     *     {@code This product includes software developed by the University of\r\n\r\n     *           Chicago, as Operator of Argonne National Laboratory.}\r\n\r\n     *     Alternately, this acknowledgment may appear in the software itself, *     if and wherever such third-party acknowledgments normally appear.</li>\r\n\r\n     * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"\r\n\r\n     *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\r\n\r\n     *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\r\n\r\n     *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\r\n\r\n     *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\r\n\r\n     *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\r\n\r\n     *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\r\n\r\n     *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\r\n\r\n     *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\r\n\r\n     *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\r\n\r\n     *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\r\n\r\n     *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\r\n\r\n     *     BE CORRECTED.</strong></li>\r\n\r\n     * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\r\n\r\n     *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\r\n\r\n     *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\r\n\r\n     *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\r\n\r\n     *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\r\n\r\n     *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\r\n\r\n     *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\r\n\r\n     *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\r\n\r\n     * <ol></td></tr>\r\n\r\n     * </table>\r\n\r\n     *\r\n\r\n     * @param v Vector of doubles.\r\n\r\n     * @return the 2-norm of the vector.\r\n\r\n     */\r\n\r\n    static double safe_norm(const std::vector<double>& v) \r\n\r\n    {\r\n\r\n        double rdwarf = 3.834e-20;\r\n\r\n        double rgiant = 1.304e+19;\r\n\r\n        double s1 = 0;\r\n\r\n        double s2 = 0;\r\n\r\n        double s3 = 0;\r\n\r\n        double x1max = 0;\r\n\r\n        double x3max = 0;\r\n\r\n        double floatn = v.size();\r\n\r\n        double agiant = rgiant / floatn;\r\n\r\n        for (int i{}; i < v.size(); i++) \r\n\r\n        {\r\n\r\n            double xabs = std::abs(v[i]);\r\n\r\n            if (xabs < rdwarf || xabs > agiant) \r\n\r\n            {\r\n\r\n                if (xabs > rdwarf) \r\n\r\n                {\r\n\r\n                    if (xabs > x1max) \r\n\r\n                    {\r\n\r\n                        double r = x1max / xabs;\r\n\r\n                        s1= 1 + s1 * r * r;\r\n\r\n                        x1max = xabs;\r\n\r\n                    }\r\n\r\n                    else \r\n\r\n                    {\r\n\r\n                        double r = xabs / x1max;\r\n\r\n                        s1 += r * r;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    if (xabs > x3max) \r\n\r\n                    {\r\n\r\n                        double r = x3max / xabs;\r\n\r\n                        s3= 1 + s3 * r * r;\r\n\r\n                        x3max = xabs;\r\n\r\n                    }\r\n\r\n                    else \r\n\r\n                    {\r\n\r\n                        if (xabs != 0) \r\n\r\n                        {\r\n\r\n                            double r = xabs / x3max;\r\n\r\n                            s3 += r * r;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n            else \r\n\r\n            {\r\n\r\n                s2 += xabs * xabs;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        double norm;\r\n\r\n        if (s1 != 0) \r\n\r\n        {\r\n\r\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            if (s2 == 0) \r\n\r\n            {\r\n\r\n                norm = x3max * Math.sqrt(s3);\r\n\r\n            }\r\n\r\n            else \r\n\r\n            {\r\n\r\n                if (s2 >= x3max) \r\n\r\n                {\r\n\r\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\r\n\r\n                }\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return norm;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Sort an array in ascending order in place and perform the same reordering\r\n\r\n     * of entries on other arrays. For example, if\r\n\r\n     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then\r\n\r\n     * {@code sort_in_place(x, y, z)} will update {@code x} to {@code [1, 2, 3]}, * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\r\n\r\n     *\r\n\r\n     * @param x Array to be sorted and used as a pattern for permutation\r\n\r\n     * of the other arrays.\r\n\r\n     * @param y_list Set of arrays whose permutations of entries will follow\r\n\r\n     * those performed on {@code x}.\r\n\r\n     * @ if any {@code y} is not the same\r\n\r\n     * size as {@code x}.\r\n\r\n     * @Null_Argument_Exception if {@code x} or any {@code y} is null.\r\n\r\n     */\r\n\r\n    static void sort_in_place(const std::vector<double>& x, const std::vector<double>... y_list)\r\n\r\n    {\r\n\r\n        sort_in_place(x, Order_Direction.INCREASING, y_list);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Helper data structure holding a (double, integer) pair.\r\n\r\n     */\r\n\r\n    class Pair_Double_Integer \r\n\r\n    {\r\n\r\n    private:\r\n\r\n        /** Key */\r\n\r\n        const double my_key;\r\n\r\n        /** Value */\r\n\r\n        const int my_value;\r\n\r\n\r\n\r\n    public:\r\n\r\n        /**\r\n\r\n         * @param key Key.\r\n\r\n         * @param value Value.\r\n\r\n         */\r\n\r\n        Pair_Double_Integer(double key, int value) : my_key{ key }, my_value{ value } {};\r\n\r\n\r\n\r\n        /** @return the key. */\r\n\r\n        double get_key() const\r\n\r\n        {\r\n\r\n            return my_key;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** @return the value. */\r\n\r\n        int get_value() const\r\n\r\n        {\r\n\r\n            return my_value;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Sort an array in place and perform the same reordering of entries on\r\n\r\n     * other arrays.  This method works the same as the other\r\n\r\n     * {@link #sort_in_place(std::vector<double>, std::vector<std::vector<double>>) sort_in_place} method, but\r\n\r\n     * allows the order of the sort to be provided in the {@code dir}\r\n\r\n     * parameter.\r\n\r\n     *\r\n\r\n     * @param x Array to be sorted and used as a pattern for permutation\r\n\r\n     * of the other arrays.\r\n\r\n     * @param dir Order direction.\r\n\r\n     * @param y_list Set of arrays whose permutations of entries will follow\r\n\r\n     * those performed on {@code x}.\r\n\r\n     * @ if any {@code y} is not the same\r\n\r\n     * size as {@code x}.\r\n\r\n     * @Null_Argument_Exception if {@code x} or any {@code y} is null\r\n\r\n     */\r\n\r\n    static void sort_in_place(const std::vector<double>& x, const Order_Direction& dir, const std::vector<double>&... y_list)\r\n\r\n    {\r\n\r\n        // Consistency checks.\r\n\r\n        if (x == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n\r\n\r\n        const int y_list_len = y_list.size();\r\n\r\n        const int len = x.size();\r\n\r\n\r\n\r\n        for (int j{}; j < y_list_len; j++) \r\n\r\n        {\r\n\r\n            const std::vector<double> y = y_list[j];\r\n\r\n            if (y == null) \r\n\r\n            {\r\n\r\n                throw Null_Argument_Exception();\r\n\r\n            }\r\n\r\n            if (y.size() != len) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, y.size(), len);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // Associate each abscissa "x[i]" with its index "i".\r\n\r\n        const List<Pair_Double_Integer> list = Array_list<>(len);\r\n\r\n        for (int i{}; i < len; i++) \r\n\r\n        {\r\n\r\n            list.add(new Pair_Double_Integer(x[i], i));\r\n\r\n        }\r\n\r\n\r\n\r\n        // Create comparators for increasing and decreasing orders.\r\n\r\n        const Comparator<Pair_Double_Integer> comp =\r\n\r\n            dir == Math_Arrays::Order_Direction::INCREASING ?\r\n\r\n            Comparator<Pair_Double_Integer>() \r\n\r\n            {\r\n\r\n                /** {@inherit_doc} */\r\n\r\n                //override\r\n\r\n                int compare(Pair_Double_Integer o1, Pair_Double_Integer o2) \r\n\r\n                {\r\n\r\n                    return Double.compare(o1.get_key(), o2.get_key());\r\n\r\n                }\r\n\r\n            } :\r\n\r\n            Comparator<Pair_Double_Integer>() \r\n\r\n            {\r\n\r\n                /** {@inherit_doc} */\r\n\r\n                //override\r\n\r\n                int compare(Pair_Double_Integer o1, Pair_Double_Integer o2) \r\n\r\n                {\r\n\r\n                    return Double.compare(o2.get_key(), o1.get_key());\r\n\r\n                }\r\n\r\n            };\r\n\r\n\r\n\r\n        // Sort.\r\n\r\n        Collections.sort(list, comp);\r\n\r\n\r\n\r\n        // Modify the original array so that its elements are in\r\n\r\n        // the prescribed order.\r\n\r\n        // Retrieve indices of original locations.\r\n\r\n        const std::vector<int> indices = int[len];\r\n\r\n        for (int i{}; i < len; i++) \r\n\r\n        {\r\n\r\n            const Pair_Double_Integer e = list.get(i);\r\n\r\n            x[i] = e.get_key();\r\n\r\n            indices[i] = e.get_value();\r\n\r\n        }\r\n\r\n\r\n\r\n        // In each of the associated arrays, move the\r\n\r\n        // elements to their location.\r\n\r\n        for (int j{}; j < y_list_len; j++) \r\n\r\n        {\r\n\r\n            // Input array will be modified in place.\r\n\r\n            std::vector<double> y_in_place = y_list[j];\r\n\r\n            const std::vector<double> y_orig = y_in_place.clone();\r\n\r\n\r\n\r\n            for (int i{}; i < len; i++) \r\n\r\n            {\r\n\r\n                y_in_place[i] = y_orig[indices[i]];\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination accurately.\r\n\r\n     * This method computes the sum of the products\r\n\r\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\r\n\r\n     * It does so by using specific multiplication and addition algorithms to\r\n\r\n     * preserve accuracy and reduce cancellation effects.\r\n\r\n     * <br/>\r\n\r\n     * It is based on the 2005 paper\r\n\r\n     * <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">\r\n\r\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n\r\n     *\r\n\r\n     * @param a Factors.\r\n\r\n     * @param b Factors.\r\n\r\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\r\n\r\n     * @ if arrays dimensions don't match\r\n\r\n     */\r\n\r\n    static double linear_combination(const std::vector<double> a, const std::vector<double> b)\r\n\r\n    {\r\n\r\n        check_equal_length(a, b);\r\n\r\n        const int len = a.size();\r\n\r\n\r\n\r\n        if (len == 1) \r\n\r\n        {\r\n\r\n            // Revert to scalar multiplication.\r\n\r\n            return a[0] * b[0];\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<double> prod_high = std::vector<double>(len];\r\n\r\n        double prod_low_sum = 0;\r\n\r\n\r\n\r\n        for (int i{}; i < len; i++) \r\n\r\n        {\r\n\r\n            const double& ai    = a[i];\r\n\r\n            const double& a_high = Double.long_bits_to_double(Double.double_to_raw_long_bits(ai) & ((-1L) << 27));\r\n\r\n            const double& a_low  = ai - a_high;\r\n\r\n\r\n\r\n            const double bi    = b[i];\r\n\r\n            const double b_high = Double.long_bits_to_double(Double.double_to_raw_long_bits(bi) & ((-1L) << 27));\r\n\r\n            const double b_low  = bi - b_high;\r\n\r\n            prod_high[i] = ai * bi;\r\n\r\n            const double prod_low = a_low * b_low - (((prod_high[i] -\r\n\r\n                                                    a_high * b_high) -\r\n\r\n                                                   a_low * b_high) -\r\n\r\n                                                  a_high * b_low);\r\n\r\n            prod_low_sum += prod_low;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        const double prod_high_cur = prod_high[0];\r\n\r\n        double prod_high_next = prod_high[1];\r\n\r\n        double s_high_prev = prod_high_cur + prod_high_next;\r\n\r\n        double s_prime = s_high_prev - prod_high_next;\r\n\r\n        double s_low_sum = (prod_high_next - (s_high_prev - s_prime)) + (prod_high_cur - s_prime);\r\n\r\n\r\n\r\n        const int len_minus_one = len - 1;\r\n\r\n        for (int i{ 1 }; i < len_minus_one; i++) \r\n\r\n        {\r\n\r\n            prod_high_next = prod_high[i + 1];\r\n\r\n            const double s_high_cur = s_high_prev + prod_high_next;\r\n\r\n            s_prime = s_high_cur - prod_high_next;\r\n\r\n            s_low_sum += (prod_high_next - (s_high_cur - s_prime)) + (s_high_prev - s_prime);\r\n\r\n            s_high_prev = s_high_cur;\r\n\r\n        }\r\n\r\n\r\n\r\n        double result = s_high_prev + (prod_low_sum + s_low_sum);\r\n\r\n\r\n\r\n        if (std::isnan(result) || result == 0.0) \r\n\r\n        {\r\n\r\n            // either we have split infinite numbers or some coefficients were NaNs or signed zeros, // just rely on the naive implementation and let IEEE754 handle this\r\n\r\n            // we do this for zeros too as we want to preserve the sign of zero (see issue #76)\r\n\r\n            result = a[0] * b[0];\r\n\r\n            for (int i{ 1 }; i < len; ++i) \r\n\r\n            {\r\n\r\n                result += a[i] * b[i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination accurately.\r\n\r\n     * <p>\r\n\r\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\r\n\r\n     * so by using specific multiplication and addition algorithms to\r\n\r\n     * preserve accuracy and reduce cancellation effects. It is based\r\n\r\n     * on the 2005 paper <a\r\n\r\n     * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">\r\n\r\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n\r\n     * </p>\r\n\r\n     * @param a1 first factor of the first term\r\n\r\n     * @param b1 second factor of the first term\r\n\r\n     * @param a2 first factor of the second term\r\n\r\n     * @param b2 second factor of the second term\r\n\r\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub>\r\n\r\n     * @see #linear_combination(double, double, double, double, double, double)\r\n\r\n     * @see #linear_combination(double, double, double, double, double, double, double, double)\r\n\r\n     */\r\n\r\n    static double linear_combination(const double& a1, const double b1, const double& a2, const double b2) \r\n\r\n    {\r\n\r\n        // the code below is split in many additions/subtractions that may\r\n\r\n        // appear redundant. However, they should NOT be simplified, as they\r\n\r\n        // use IEEE754 floating point arithmetic rounding properties.\r\n\r\n        // The variable naming conventions are that xyz_high contains the most significant\r\n\r\n        // bits of xyz and xyz_low contains its least significant bits. So theoretically\r\n\r\n        // xyz is the sum xyz_high + xyz_low, but in many cases below, this sum cannot\r\n\r\n        // be represented in only one double precision number so we preserve two numbers\r\n\r\n        // to hold it as long as we can, combining the high and low order bits together\r\n\r\n        // only at the end, after cancellation may have occurred on high order bits\r\n\r\n\r\n\r\n        // split a1 and b1 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a1) & ((-1L) << 27));\r\n\r\n        const double& a1_low      = a1 - a1_high;\r\n\r\n        const double b1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b1) & ((-1L) << 27));\r\n\r\n        const double b1_low      = b1 - b1_high;\r\n\r\n\r\n\r\n        // accurate multiplication a1 * b1\r\n\r\n        const double prod1_high  = a1 * b1;\r\n\r\n        const double prod1_low   = a1_low * b1_low - (((prod1_high - a1_high * b1_high) - a1_low * b1_high) - a1_high * b1_low);\r\n\r\n\r\n\r\n        // split a2 and b2 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a2) & ((-1L) << 27));\r\n\r\n        const double& a2_low      = a2 - a2_high;\r\n\r\n        const double b2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b2) & ((-1L) << 27));\r\n\r\n        const double b2_low      = b2 - b2_high;\r\n\r\n\r\n\r\n        // accurate multiplication a2 * b2\r\n\r\n        const double prod2_high  = a2 * b2;\r\n\r\n        const double prod2_low   = a2_low * b2_low - (((prod2_high - a2_high * b2_high) - a2_low * b2_high) - a2_high * b2_low);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2\r\n\r\n        const double s12_high    = prod1_high + prod2_high;\r\n\r\n        const double s12_prime   = s12_high - prod2_high;\r\n\r\n        const double s12_low     = (prod2_high - (s12_high - s12_prime)) + (prod1_high - s12_prime);\r\n\r\n\r\n\r\n        // const rounding, s12 may have suffered many cancellations, we try\r\n\r\n        // to recover some bits from the extra words we have saved up to now\r\n\r\n        double result = s12_high + (prod1_low + prod2_low + s12_low);\r\n\r\n\r\n\r\n        if (std::isnan(result) || result == 0.0) \r\n\r\n        {\r\n\r\n            // either we have split infinite numbers or some coefficients were NaNs or signed zeros, // just rely on the naive implementation and let IEEE754 handle this\r\n\r\n            // we do this for zeros too as we want to preserve the sign of zero (see issue #76)\r\n\r\n            result = a1 * b1 + a2 * b2;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination accurately.\r\n\r\n     * <p>\r\n\r\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\r\n\r\n     * to high accuracy. It does so by using specific multiplication and\r\n\r\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\r\n\r\n     * It is based on the 2005 paper <a\r\n\r\n     * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">\r\n\r\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n\r\n     * </p>\r\n\r\n     * @param a1 first factor of the first term\r\n\r\n     * @param b1 second factor of the first term\r\n\r\n     * @param a2 first factor of the second term\r\n\r\n     * @param b2 second factor of the second term\r\n\r\n     * @param a3 first factor of the third term\r\n\r\n     * @param b3 second factor of the third term\r\n\r\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\r\n\r\n     * @see #linear_combination(double, double, double, double)\r\n\r\n     * @see #linear_combination(double, double, double, double, double, double, double, double)\r\n\r\n     */\r\n\r\n    static double linear_combination(const double& a1, const double b1, const double& a2, const double b2, const double& a3, const double b3) \r\n\r\n    {\r\n\r\n        // the code below is split in many additions/subtractions that may\r\n\r\n        // appear redundant. However, they should NOT be simplified, as they\r\n\r\n        // do use IEEE754 floating point arithmetic rounding properties.\r\n\r\n        // The variables naming conventions are that xyz_high contains the most significant\r\n\r\n        // bits of xyz and xyz_low contains its least significant bits. So theoretically\r\n\r\n        // xyz is the sum xyz_high + xyz_low, but in many cases below, this sum cannot\r\n\r\n        // be represented in only one double precision number so we preserve two numbers\r\n\r\n        // to hold it as long as we can, combining the high and low order bits together\r\n\r\n        // only at the end, after cancellation may have occurred on high order bits\r\n\r\n\r\n\r\n        // split a1 and b1 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a1) & ((-1L) << 27));\r\n\r\n        const double& a1_low      = a1 - a1_high;\r\n\r\n        const double b1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b1) & ((-1L) << 27));\r\n\r\n        const double b1_low      = b1 - b1_high;\r\n\r\n\r\n\r\n        // accurate multiplication a1 * b1\r\n\r\n        const double prod1_high  = a1 * b1;\r\n\r\n        const double prod1_low   = a1_low * b1_low - (((prod1_high - a1_high * b1_high) - a1_low * b1_high) - a1_high * b1_low);\r\n\r\n\r\n\r\n        // split a2 and b2 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a2) & ((-1L) << 27));\r\n\r\n        const double& a2_low      = a2 - a2_high;\r\n\r\n        const double b2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b2) & ((-1L) << 27));\r\n\r\n        const double b2_low      = b2 - b2_high;\r\n\r\n\r\n\r\n        // accurate multiplication a2 * b2\r\n\r\n        const double prod2_high  = a2 * b2;\r\n\r\n        const double prod2_low   = a2_low * b2_low - (((prod2_high - a2_high * b2_high) - a2_low * b2_high) - a2_high * b2_low);\r\n\r\n\r\n\r\n        // split a3 and b3 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a3_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a3) & ((-1L) << 27));\r\n\r\n        const double& a3_low      = a3 - a3_high;\r\n\r\n        const double b3_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b3) & ((-1L) << 27));\r\n\r\n        const double b3_low      = b3 - b3_high;\r\n\r\n\r\n\r\n        // accurate multiplication a3 * b3\r\n\r\n        const double prod3_high  = a3 * b3;\r\n\r\n        const double prod3_low   = a3_low * b3_low - (((prod3_high - a3_high * b3_high) - a3_low * b3_high) - a3_high * b3_low);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2\r\n\r\n        const double s12_high    = prod1_high + prod2_high;\r\n\r\n        const double s12_prime   = s12_high - prod2_high;\r\n\r\n        const double s12_low     = (prod2_high - (s12_high - s12_prime)) + (prod1_high - s12_prime);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\r\n\r\n        const double s123_high   = s12_high + prod3_high;\r\n\r\n        const double s123_prime  = s123_high - prod3_high;\r\n\r\n        const double s123_low    = (prod3_high - (s123_high - s123_prime)) + (s12_high - s123_prime);\r\n\r\n\r\n\r\n        // const rounding, s123 may have suffered many cancellations, we try\r\n\r\n        // to recover some bits from the extra words we have saved up to now\r\n\r\n        double result = s123_high + (prod1_low + prod2_low + prod3_low + s12_low + s123_low);\r\n\r\n\r\n\r\n        if (std::isnan(result) || result == 0.0) \r\n\r\n        {\r\n\r\n            // either we have split infinite numbers or some coefficients were NaNs or signed zeros, // just rely on the naive implementation and let IEEE754 handle this\r\n\r\n            // we do this for zeros too as we want to preserve the sign of zero (see issue #76)\r\n\r\n            result = a1 * b1 + a2 * b2 + a3 * b3;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination accurately.\r\n\r\n     * <p>\r\n\r\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\r\n\r\n     * a<sub>4</sub>&times;b<sub>4</sub>\r\n\r\n     * to high accuracy. It does so by using specific multiplication and\r\n\r\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\r\n\r\n     * It is based on the 2005 paper <a\r\n\r\n     * href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547">\r\n\r\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\r\n\r\n     * </p>\r\n\r\n     * @param a1 first factor of the first term\r\n\r\n     * @param b1 second factor of the first term\r\n\r\n     * @param a2 first factor of the second term\r\n\r\n     * @param b2 second factor of the second term\r\n\r\n     * @param a3 first factor of the third term\r\n\r\n     * @param b3 second factor of the third term\r\n\r\n     * @param a4 first factor of the third term\r\n\r\n     * @param b4 second factor of the third term\r\n\r\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\r\n\r\n     * a<sub>4</sub>&times;b<sub>4</sub>\r\n\r\n     * @see #linear_combination(double, double, double, double)\r\n\r\n     * @see #linear_combination(double, double, double, double, double, double)\r\n\r\n     */\r\n\r\n    static double linear_combination(const double& a1, const double b1, const double& a2, const double b2, const double& a3, const double b3, const double& a4, const double b4) \r\n\r\n    {\r\n\r\n\r\n\r\n        // the code below is split in many additions/subtractions that may\r\n\r\n        // appear redundant. However, they should NOT be simplified, as they\r\n\r\n        // do use IEEE754 floating point arithmetic rounding properties.\r\n\r\n        // The variables naming conventions are that xyz_high contains the most significant\r\n\r\n        // bits of xyz and xyz_low contains its least significant bits. So theoretically\r\n\r\n        // xyz is the sum xyz_high + xyz_low, but in many cases below, this sum cannot\r\n\r\n        // be represented in only one double precision number so we preserve two numbers\r\n\r\n        // to hold it as long as we can, combining the high and low order bits together\r\n\r\n        // only at the end, after cancellation may have occurred on high order bits\r\n\r\n\r\n\r\n        // split a1 and b1 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a1) & ((-1L) << 27));\r\n\r\n        const double& a1_low      = a1 - a1_high;\r\n\r\n        const double b1_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b1) & ((-1L) << 27));\r\n\r\n        const double b1_low      = b1 - b1_high;\r\n\r\n\r\n\r\n        // accurate multiplication a1 * b1\r\n\r\n        const double prod1_high  = a1 * b1;\r\n\r\n        const double prod1_low   = a1_low * b1_low - (((prod1_high - a1_high * b1_high) - a1_low * b1_high) - a1_high * b1_low);\r\n\r\n\r\n\r\n        // split a2 and b2 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a2) & ((-1L) << 27));\r\n\r\n        const double& a2_low      = a2 - a2_high;\r\n\r\n        const double b2_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b2) & ((-1L) << 27));\r\n\r\n        const double b2_low      = b2 - b2_high;\r\n\r\n\r\n\r\n        // accurate multiplication a2 * b2\r\n\r\n        const double prod2_high  = a2 * b2;\r\n\r\n        const double prod2_low   = a2_low * b2_low - (((prod2_high - a2_high * b2_high) - a2_low * b2_high) - a2_high * b2_low);\r\n\r\n\r\n\r\n        // split a3 and b3 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a3_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a3) & ((-1L) << 27));\r\n\r\n        const double& a3_low      = a3 - a3_high;\r\n\r\n        const double b3_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b3) & ((-1L) << 27));\r\n\r\n        const double b3_low      = b3 - b3_high;\r\n\r\n\r\n\r\n        // accurate multiplication a3 * b3\r\n\r\n        const double prod3_high  = a3 * b3;\r\n\r\n        const double prod3_low   = a3_low * b3_low - (((prod3_high - a3_high * b3_high) - a3_low * b3_high) - a3_high * b3_low);\r\n\r\n\r\n\r\n        // split a4 and b4 as one 26 bits number and one 27 bits number\r\n\r\n        const double& a4_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(a4) & ((-1L) << 27));\r\n\r\n        const double& a4_low      = a4 - a4_high;\r\n\r\n        const double b4_high     = Double.long_bits_to_double(Double.double_to_raw_long_bits(b4) & ((-1L) << 27));\r\n\r\n        const double b4_low      = b4 - b4_high;\r\n\r\n\r\n\r\n        // accurate multiplication a4 * b4\r\n\r\n        const double prod4_high  = a4 * b4;\r\n\r\n        const double prod4_low   = a4_low * b4_low - (((prod4_high - a4_high * b4_high) - a4_low * b4_high) - a4_high * b4_low);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2\r\n\r\n        const double s12_high    = prod1_high + prod2_high;\r\n\r\n        const double s12_prime   = s12_high - prod2_high;\r\n\r\n        const double s12_low     = (prod2_high - (s12_high - s12_prime)) + (prod1_high - s12_prime);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\r\n\r\n        const double s123_high   = s12_high + prod3_high;\r\n\r\n        const double s123_prime  = s123_high - prod3_high;\r\n\r\n        const double s123_low    = (prod3_high - (s123_high - s123_prime)) + (s12_high - s123_prime);\r\n\r\n\r\n\r\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\r\n\r\n        const double s1234High  = s123_high + prod4_high;\r\n\r\n        const double s1234_prime = s1234High - prod4_high;\r\n\r\n        const double s1234_low   = (prod4_high - (s1234High - s1234_prime)) + (s123_high - s1234_prime);\r\n\r\n\r\n\r\n        // const rounding, s1234 may have suffered many cancellations, we try\r\n\r\n        // to recover some bits from the extra words we have saved up to now\r\n\r\n        double result = s1234High + (prod1_low + prod2_low + prod3_low + prod4_low + s12_low + s123_low + s1234_low);\r\n\r\n\r\n\r\n        if (std::isnan(result) || result == 0.0) \r\n\r\n        {\r\n\r\n            // either we have split infinite numbers or some coefficients were NaNs or signed zeros, // just rely on the naive implementation and let IEEE754 handle this\r\n\r\n            // we do this for zeros too as we want to preserve the sign of zero (see issue #76)\r\n\r\n            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns true iff both arguments are null or have same dimensions and all\r\n\r\n     * their elements are equal as defined by\r\n\r\n     * {@link Precision#equals(float,float)}.\r\n\r\n     *\r\n\r\n     * @param x first array\r\n\r\n     * @param y second array\r\n\r\n     * @return true if the values are both null or have same dimension\r\n\r\n     * and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(std::vector<float> x, std::vector<float> y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (!Precision.equals(x[i], y[i])) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns true iff both arguments are null or have same dimensions and all\r\n\r\n     * their elements are equal as defined by\r\n\r\n     * {@link Precision#equals_including_nan(double,double) this method}.\r\n\r\n     *\r\n\r\n     * @param x first array\r\n\r\n     * @param y second array\r\n\r\n     * @return true if the values are both null or have same dimension and\r\n\r\n     * equal elements\r\n\r\n     */\r\n\r\n    static bool equals_including_nan(std::vector<float> x, std::vector<float> y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (!Precision.equals_including_nan(x[i], y[i])) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} iff both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equal as defined by\r\n\r\n     * {@link Precision#equals(double,double)}.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(std::vector<double> x, std::vector<double> y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (!Precision.equals(x[i], y[i])) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} iff both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equal as defined by\r\n\r\n     * {@link Precision#equals_including_nan(double,double) this method}.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals_including_nan(std::vector<double> x, std::vector<double> y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (!Precision.equals_including_nan(x[i], y[i])) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equals.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(long[] x, long[] y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (x[i] != y[i]) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equals.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(const std::vector<int>& x, std::vector<int> y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (x[i] != y[i]) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equals.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(std::vector<std::byte>x, std::vector<std::byte>y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (x[i] != y[i]) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if both arguments are {@code null} or have same\r\n\r\n     * dimensions and all their elements are equals.\r\n\r\n     *\r\n\r\n     * @param x First array.\r\n\r\n     * @param y Second array.\r\n\r\n     * @return {@code true} if the values are both {@code null} or have same\r\n\r\n     * dimension and equal elements.\r\n\r\n     */\r\n\r\n    static bool equals(std::vector<short>& x, std::vector<short>& y) \r\n\r\n    {\r\n\r\n        if ((x == null) || (y == null)) \r\n\r\n        {\r\n\r\n            return !((x == null) ^ (y == null));\r\n\r\n        }\r\n\r\n        if (x.size() != y.size()) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        for (int i{}; i < x.size(); ++i) \r\n\r\n        {\r\n\r\n            if (x[i] != y[i]) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Normalizes an array to make it sum to a specified value.\r\n\r\n     * Returns the result of the transformation\r\n\r\n     * <pre>\r\n\r\n     *    x \xe2\x86\xa6 x * normalized_sum / sum\r\n\r\n     * </pre>\r\n\r\n     * applied to each non-NaN element x of the input array, where sum is the\r\n\r\n     * sum of the non-NaN entries in the input array.\r\n\r\n     * <p>\r\n\r\n     * Throws Illegal_Argument_Exception if {@code normalized_sum} is infinite\r\n\r\n     * or NaN and Arithmetic_Exception if the input array contains any infinite elements\r\n\r\n     * or sums to 0.\r\n\r\n     * <p>\r\n\r\n     * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.\r\n\r\n     * The input array is unchanged by this method.\r\n\r\n     *\r\n\r\n     * @param values Input array to be normalized\r\n\r\n     * @param normalized_sum Target sum for the normalized array\r\n\r\n     * @return the normalized array\r\n\r\n     * @Math_Runtime_Exception if the input array contains infinite\r\n\r\n     * elements or sums to zero\r\n\r\n     * @ if the target sum is infinite or {@code NaN}\r\n\r\n     */\r\n\r\n    static std::vector<double> normalize_array(const std::vector<double>& values, const double& normalized_sum)\r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(normalized_sum)) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NORMALIZE_INFINITE);\r\n\r\n        }\r\n\r\n        if (std::isnan(normalized_sum)) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NORMALIZE_NAN);\r\n\r\n        }\r\n\r\n        double sum{};\r\n\r\n        const auto len = values.size();\r\n\r\n        auto out = std::vector<double>(len);\r\n\r\n        for (int i{}; i < len; i++) \r\n\r\n        {\r\n\r\n            if (Double.std::isinfinite(values[i])) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.INFINITE_ARRAY_ELEMENT, values[i], i);\r\n\r\n            }\r\n\r\n            if (!std::isnan(values[i])) \r\n\r\n            {\r\n\r\n                sum += values[i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (sum == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ARRAY_SUMS_TO_ZERO);\r\n\r\n        }\r\n\r\n        for (int i{}; i < len; i++) \r\n\r\n        {\r\n\r\n            out[i] = std::isnan(values[i])\r\n\r\n                ? std::numeric_limits<double>::quiet_NaN()\r\n\r\n                : values[i] * normalized_sum / sum;\r\n\r\n        }\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build an array of elements.\r\n\r\n     * <p>\r\n\r\n     * Arrays are filled with {@code field.get_zero()}\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which array elements belong\r\n\r\n     * @param length of the array\r\n\r\n     * @return a array\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> std::vector<T> build_array(const Field<T> field, const int length) \r\n\r\n    {\r\n\r\n        ////@Suppress_Warnings("unchecked") // OK because field must be correct class\r\n\r\n        std::vector<T> array = (std::vector<T>) Array.new_instance(field.get_runtime_class(), length);\r\n\r\n        Arrays.fill(array, field.get_zero());\r\n\r\n        return array;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a double dimension array of elements.\r\n\r\n     * <p>\r\n\r\n     * Arrays are filled with {@code field.get_zero()}\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which array elements belong\r\n\r\n     * @param rows number of rows in the array\r\n\r\n     * @param columns number of columns (may be negative to build partial\r\n\r\n     * arrays in the same way {@code Field[rows][]} works)\r\n\r\n     * @return a array\r\n\r\n     */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    static <T extends Field_Element<T>> std::vector<std::vector<T>> build_array(const Field<T>& field, const int& rows, const int& columns) \r\n\r\n    {\r\n\r\n        std::vector<std::vector<T>> arr_2d;\r\n\r\n        if (columns < 0) \r\n\r\n        {\r\n\r\n            std::vector<T> dummy_row = build_array(field, 0);\r\n\r\n            arr_2d = (std::vector<std::vector<T>>) Array.new_instance(dummy_row.get_class(), rows);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            arr = (std::vector<std::vector<T>>) Array.new_instance(field.get_runtime_class(), std::vector<int>\r\n\r\n            {\r\n\r\n                                                  rows, columns\r\n\r\n            });\r\n\r\n            const auto row_size = arr_2d[0].size();\r\n\r\n            for (auto& row : arr_2d)\r\n\r\n            {\r\n\r\n                row = std::vector<T>(row_size, field.get_zero());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return arr_2d;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a triple dimension array of elements.\r\n\r\n     * <p>\r\n\r\n     * Arrays are filled with {@code field.get_zero()}\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which array elements belong\r\n\r\n     * @param l1 number of elements along first dimension\r\n\r\n     * @param l2 number of elements along second dimension\r\n\r\n     * @param l3 number of elements along third dimension (may be negative to build partial\r\n\r\n     * arrays in the same way {@code Field[l1][l2][]} works)\r\n\r\n     * @return a array\r\n\r\n     * @since 1.4\r\n\r\n     */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    static <T extends Field_Element<T>> std::vector<std::vector<std::vector<T>>> build_array(const Field<T>& field, const int& l1, const int& l2, const int& l3) \r\n\r\n    {\r\n\r\n        std::vector<std::vector<std::vector<T>>> arr_3d;\r\n\r\n        if (l3 < 0) \r\n\r\n        {\r\n\r\n            std::vector<T> dummy_row = build_array(field, 0);\r\n\r\n            arr_3d = (std::vector<std::vector<T>>[]) Array.new_instance(dummy_row.get_class(), l1, l2);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            arr_3d = (std::vector<std::vector<T>>[]) Array.new_instance(field.get_runtime_class(), std::vector<int>\r\n\r\n            {\r\n\r\n                l1, l2, l3\r\n\r\n            });\r\n\r\n            for (int i{}; i < l1; ++i) \r\n\r\n            {\r\n\r\n                for (int j{}; j < l2; ++j) \r\n\r\n                {\r\n\r\n                    Arrays.fill(arr_3d[i][j], field.get_zero());\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return arr_3d;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the <a href="http://en.wikipedia.org/wiki/Convolution">\r\n\r\n     * convolution</a> between two sequences.\r\n\r\n     * <p>\r\n\r\n     * The solution is obtained via straightforward computation of the\r\n\r\n     * convolution sum (and not via FFT). Whenever the computation needs\r\n\r\n     * an element that would be located at an index outside the input arrays, * the value is assumed to be zero.\r\n\r\n     *\r\n\r\n     * @param x First sequence.\r\n\r\n     * Typically, this sequence will represent an input signal to a system.\r\n\r\n     * @param h Second sequence.\r\n\r\n     * Typically, this sequence will represent the impulse response of the system.\r\n\r\n     * @return the convolution of {@code x} and {@code h}.\r\n\r\n     * This array's length will be {@code x.size() + h.size() - 1}.\r\n\r\n     * @Null_Argument_Exception if either {@code x} or {@code h} is {@code null}.\r\n\r\n     * @ if either {@code x} or {@code h} is empty.\r\n\r\n     */\r\n\r\n    static std::vector<double> convolve(const std::vector<double>& x, const std::vector<double>& h)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(x);\r\n\r\n        //Math_Utils::check_not_null(h);\r\n\r\n\r\n\r\n        const int x_len = x.size();\r\n\r\n        const int h_len = h.size();\r\n\r\n\r\n\r\n        if (x_len == 0 || h_len == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NO_DATA);\r\n\r\n        }\r\n\r\n\r\n\r\n        // initialize the output array\r\n\r\n        const int total_length = x_len + h_len - 1;\r\n\r\n        const std::vector<double> y = std::vector<double>(total_length];\r\n\r\n\r\n\r\n        // straightforward implementation of the convolution sum\r\n\r\n        for (const int n = 0; n < total_length; n++) \r\n\r\n        {\r\n\r\n            double yn = 0;\r\n\r\n            int k = std::max(0, n + 1 - x_len);\r\n\r\n            int j = n - k;\r\n\r\n            while (k < h_len && j >= 0) \r\n\r\n            {\r\n\r\n                yn += x[j--] * h[k++];\r\n\r\n            }\r\n\r\n            y[n] = yn;\r\n\r\n        }\r\n\r\n\r\n\r\n        return y;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Specification for indicating that some operation applies\r\n\r\n     * before or after a given index.\r\n\r\n     */\r\n\r\n    enum Position \r\n\r\n    {\r\n\r\n        /** Designates the beginning of the array (near index 0). */\r\n\r\n        HEAD, /** Designates the end of the array. */\r\n\r\n        TAIL\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Shuffle the entries of the given array.\r\n\r\n     * The {@code start} and {@code pos} parameters select which portion\r\n\r\n     * of the array is randomized and which is left untouched.\r\n\r\n     *\r\n\r\n     * @see #shuffle(std::vector<int>,int,Position,Random_Generator)\r\n\r\n     *\r\n\r\n     * @param list Array whose entries will be shuffled (in-place).\r\n\r\n     * @param start Index at which shuffling begins.\r\n\r\n     * @param pos Shuffling is performed for index positions between\r\n\r\n     * {@code start} and either the end (if {@link Position#TAIL})\r\n\r\n     * or the beginning (if {@link Position#HEAD}) of the array.\r\n\r\n     */\r\n\r\n    static void shuffle(const std::vector<int>& list, const int& start, const Position& pos) \r\n\r\n    {\r\n\r\n        shuffle(list, start, pos, Well19937c());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Shuffle the entries of the given array, using the\r\n\r\n     * <a href="http://en.wikipedia.org/wiki/Fisher\xe2\x80\x93Yates_shuffle#The_modern_algorithm">\r\n\r\n     * Fisher\xe2\x80\x93Yates</a> algorithm.\r\n\r\n     * The {@code start} and {@code pos} parameters select which portion\r\n\r\n     * of the array is randomized and which is left untouched.\r\n\r\n     *\r\n\r\n     * @param list Array whose entries will be shuffled (in-place).\r\n\r\n     * @param start Index at which shuffling begins.\r\n\r\n     * @param pos Shuffling is performed for index positions between\r\n\r\n     * {@code start} and either the end (if {@link Position#TAIL})\r\n\r\n     * or the beginning (if {@link Position#HEAD}) of the array.\r\n\r\n     * @param rng Random number generator.\r\n\r\n     */\r\n\r\n    static void shuffle(const std::vector<int>& list, const int& start, const Position& pos, const Random_Generator& rng) \r\n\r\n    {\r\n\r\n        switch (pos) \r\n\r\n        {\r\n\r\n        case TAIL:\r\n\r\n            for (int i = list.size() - 1; i > start; i--) \r\n\r\n            {\r\n\r\n                const int target = start + rng.next_int(i - start + 1);\r\n\r\n                const int temp = list[target];\r\n\r\n                list[target] = list[i];\r\n\r\n                list[i] = temp;\r\n\r\n            }\r\n\r\n            break;\r\n\r\n\r\n\r\n        case HEAD:\r\n\r\n            for (int i{}; i < start; i++) \r\n\r\n            {\r\n\r\n                const int target = i + rng.next_int(start - i + 1);\r\n\r\n                const int temp = list[target];\r\n\r\n                list[target] = list[i];\r\n\r\n                list[i] = temp;\r\n\r\n            }\r\n\r\n            break;\r\n\r\n\r\n\r\n        default:\r\n\r\n            throw Math_Runtime_Exception.create_internal_error(); // Should never happen.\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Shuffle the entries of the given array.\r\n\r\n     *\r\n\r\n     * @see #shuffle(std::vector<int>,int,Position,Random_Generator)\r\n\r\n     *\r\n\r\n     * @param list Array whose entries will be shuffled (in-place).\r\n\r\n     * @param rng Random number generator.\r\n\r\n     */\r\n\r\n    static void shuffle(const std::vector<int>& list, const Random_Generator& rng) \r\n\r\n    {\r\n\r\n        shuffle(list, 0, Position.TAIL, rng);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Shuffle the entries of the given array.\r\n\r\n     *\r\n\r\n     * @see #shuffle(std::vector<int>,int,Position,Random_Generator)\r\n\r\n     *\r\n\r\n     * @param list Array whose entries will be shuffled (in-place).\r\n\r\n     */\r\n\r\n    static void shuffle(const std::vector<int>& list) \r\n\r\n    {\r\n\r\n        shuffle(list, Well19937c());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an array representing the natural number {@code n}.\r\n\r\n     *\r\n\r\n     * @param n Natural number.\r\n\r\n     * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\r\n\r\n     * If {@code n == 0}, the returned array is empty.\r\n\r\n     */\r\n\r\n    static std::vector<int> natural(const int& n) \r\n\r\n    {\r\n\r\n        return sequence(n, 0, 1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an array of {@code size} integers starting at {@code start}, * skipping {@code stride} numbers.\r\n\r\n     *\r\n\r\n     * @param size Natural number.\r\n\r\n     * @param start Natural number.\r\n\r\n     * @param stride Natural number.\r\n\r\n     * @return an array whose entries are the numbers\r\n\r\n     * {@code start, start + stride, ..., start + (size - 1) * stride}.\r\n\r\n     * If {@code size == 0}, the returned array is empty.\r\n\r\n     */\r\n\r\n    static std::vector<int> sequence(const int& size, const int& start, const int& stride) \r\n\r\n    {\r\n\r\n        auto a = std::vector<int>(size);\r\n\r\n        for (auto& ele : a)\r\n\r\n        {\r\n\r\n            ele = start + i * stride;\r\n\r\n        }\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method is used\r\n\r\n     * to verify that the input parameters designate a subarray of positive length.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>returns <code>true</code> iff the parameters designate a subarray of\r\n\r\n     * positive length</li>\r\n\r\n     * <li><code></code> if the array is null or\r\n\r\n     * or the indices are invalid</li>\r\n\r\n     * <li>returns <code>false</li> if the array is non-null, but\r\n\r\n     * <code>length</code> is 0.\r\n\r\n     * </ul></p>\r\n\r\n     *\r\n\r\n     * @param values the input array\r\n\r\n     * @param begin index of the first array element to include\r\n\r\n     * @param length the number of elements to include\r\n\r\n     * @return true if the parameters are valid and designate a subarray of positive length\r\n\r\n     * @ if the indices are invalid or the array is null\r\n\r\n     */\r\n\r\n    static bool verify_values(const std::vector<double>& values, const int& begin, const int& length)\r\n\r\n    {\r\n\r\n        return verify_values(values, begin, length, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method is used\r\n\r\n     * to verify that the input parameters designate a subarray of positive length.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>returns <code>true</code> iff the parameters designate a subarray of\r\n\r\n     * non-negative length</li>\r\n\r\n     * <li><code>Illegal_Argument_Exception</code> if the array is null or\r\n\r\n     * or the indices are invalid</li>\r\n\r\n     * <li>returns <code>false</li> if the array is non-null, but\r\n\r\n     * <code>length</code> is 0 unless <code>allow_empty</code> is <code>true</code>\r\n\r\n     * </ul></p>\r\n\r\n     *\r\n\r\n     * @param values the input array\r\n\r\n     * @param begin index of the first array element to include\r\n\r\n     * @param length the number of elements to include\r\n\r\n     * @param allow_empty if <code>true</code> then zero length arrays are allowed\r\n\r\n     * @return true if the parameters are valid\r\n\r\n     * @ if the indices are invalid or the array is null\r\n\r\n     */\r\n\r\n    static bool verify_values(const std::vector<double>& values, const int& begin, const int& length, const bool allow_empty)  \r\n\r\n    {\r\n\r\n\r\n\r\n        //Math_Utils::check_not_null(values, Localized_Core_Formats.INPUT_ARRAY);\r\n\r\n\r\n\r\n        if (begin < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.START_POSITION, static_cast<int>(begin));\r\n\r\n        }\r\n\r\n\r\n\r\n        if (length < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.size(), static_cast<int>(length));\r\n\r\n        }\r\n\r\n\r\n\r\n        if (begin + length > values.size()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SUBARRAY_ENDS_AFTER_ARRAY_END, static_cast<int>(begin + length), static_cast<int>(values.size()), true);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (length == 0 && !allow_empty) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method is used\r\n\r\n     * to verify that the begin and length parameters designate a subarray of positive length\r\n\r\n     * and the weights are all non-negative, non-NaN, finite, and not all zero.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>returns <code>true</code> iff the parameters designate a subarray of\r\n\r\n     * positive length and the weights array contains legitimate values.</li>\r\n\r\n     * <li><code>Illegal_Argument_Exception</code> if any of the following are true:\r\n\r\n     * <ul><li>the values array is null</li>\r\n\r\n     *     <li>the weights array is null</li>\r\n\r\n     *     <li>the weights array does not have the same length as the values array</li>\r\n\r\n     *     <li>the weights array contains one or more infinite values</li>\r\n\r\n     *     <li>the weights array contains one or more NaN values</li>\r\n\r\n     *     <li>the weights array contains negative values</li>\r\n\r\n     *     <li>the start and length arguments do not determine a valid array</li></ul>\r\n\r\n     * </li>\r\n\r\n     * <li>returns <code>false</li> if the array is non-null, but\r\n\r\n     * <code>length</code> is 0.\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param values the input array\r\n\r\n     * @param weights the weights array\r\n\r\n     * @param begin index of the first array element to include\r\n\r\n     * @param length the number of elements to include\r\n\r\n     * @return true if the parameters are valid and designate a subarray of positive length\r\n\r\n     * @ if the indices are invalid or the array is null\r\n\r\n     */\r\n\r\n    static bool verify_values(const std::vector<double>& values, const std::vector<double>& weights, const int& begin, const int& length)  \r\n\r\n    {\r\n\r\n        return verify_values(values, weights, begin, length, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method is used\r\n\r\n     * to verify that the begin and length parameters designate a subarray of positive length\r\n\r\n     * and the weights are all non-negative, non-NaN, finite, and not all zero.\r\n\r\n     * <p>\r\n\r\n     * <ul>\r\n\r\n     * <li>returns <code>true</code> iff the parameters designate a subarray of\r\n\r\n     * non-negative length and the weights array contains legitimate values.</li>\r\n\r\n     * <li><code></code> if any of the following are true:\r\n\r\n     * <ul><li>the values array is null</li>\r\n\r\n     *     <li>the weights array is null</li>\r\n\r\n     *     <li>the weights array does not have the same length as the values array</li>\r\n\r\n     *     <li>the weights array contains one or more infinite values</li>\r\n\r\n     *     <li>the weights array contains one or more NaN values</li>\r\n\r\n     *     <li>the weights array contains negative values</li>\r\n\r\n     *     <li>the start and length arguments do not determine a valid array</li></ul>\r\n\r\n     * </li>\r\n\r\n     * <li>returns <code>false</li> if the array is non-null, but\r\n\r\n     * <code>length</code> is 0 unless <code>allow_empty</code> is <code>true</code>.\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param values the input array.\r\n\r\n     * @param weights the weights array.\r\n\r\n     * @param begin index of the first array element to include.\r\n\r\n     * @param length the number of elements to include.\r\n\r\n     * @param allow_empty if {@code true} than allow zero length arrays to pass.\r\n\r\n     * @return {@code true} if the parameters are valid.\r\n\r\n     * @Null_Argument_Exception if either of the arrays are null\r\n\r\n     * @ if the array indices are not valid, * the weights array contains NaN, infinite or negative elements, or there\r\n\r\n     * are no positive weights.\r\n\r\n     */\r\n\r\n    static bool verify_values(const std::vector<double>& values, const std::vector<double>& weights, const int& begin, const int& length, const bool allow_empty)  \r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(weights, Localized_Core_Formats.INPUT_ARRAY);\r\n\r\n        //Math_Utils::check_not_null(values, Localized_Core_Formats.INPUT_ARRAY);\r\n\r\n\r\n\r\n        check_equal_length(weights, values);\r\n\r\n\r\n\r\n        bool contains_positive_weight{};\r\n\r\n        for (int i{ begin }; i < begin + length; i++)\r\n\r\n        {\r\n\r\n            const double weight = weights[i];\r\n\r\n            if (std::isnan(weight)) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NAN_ELEMENT_AT_INDEX, static_cast<int>(i));\r\n\r\n            }\r\n\r\n            if (std::isinfinite(weight)) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.INFINITE_ARRAY_ELEMENT, static_cast<double>(weight), static_cast<int>(i));\r\n\r\n            }\r\n\r\n            if (weight < 0) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NEGATIVE_ELEMENT_AT_INDEX, static_cast<int>(i), static_cast<double>(weight));\r\n\r\n            }\r\n\r\n            if (!contains_positive_weight && weight > 0.0) \r\n\r\n            {\r\n\r\n                contains_positive_weight = true;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        if (!contains_positive_weight) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\r\n\r\n        }\r\n\r\n\r\n\r\n        return verify_values(values, begin, length, allow_empty);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Concatenates a sequence of arrays. The return array consists of the\r\n\r\n     * entries of the input arrays concatenated in the order they appear in\r\n\r\n     * the argument list.  Null arrays cause Null_Pointer_Exceptions; zero\r\n\r\n     * length arrays are allowed (contributing nothing to the output array).\r\n\r\n     *\r\n\r\n     * @param x list of std::vector<double> arrays to concatenate\r\n\r\n     * @return a array consisting of the entries of the argument arrays\r\n\r\n     * @Null_Pointer_Exception if any of the arrays are null\r\n\r\n     */\r\n\r\n    static std::vector<double> concatenate(const std::vector<double>... x) \r\n\r\n    {\r\n\r\n        int combined_length{};\r\n\r\n        for (std::vector<double> a : x) \r\n\r\n        {\r\n\r\n            combined_length += a.size();\r\n\r\n        }\r\n\r\n        int offset{};\r\n\r\n        const std::vector<double> combined = std::vector<double>(combined_length];\r\n\r\n        for (int i{}; i < x.size(); i++) \r\n\r\n        {\r\n\r\n            const int cur_length = x[i].size();\r\n\r\n            System.arraycopy(x[i], 0, combined, offset, cur_length);\r\n\r\n            offset += cur_length;\r\n\r\n        }\r\n\r\n        return combined;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an array consisting of the unique values in {@code data}.\r\n\r\n     * The return array is sorted in descending order.  Empty arrays\r\n\r\n     * are allowed, but null arrays result in Null_Pointer_Exception.\r\n\r\n     * Infinities are allowed.  NaN values are allowed with maximum\r\n\r\n     * sort order - i.e., if there are NaN values in {@code data}, * {@codeNAN} will be the first element of the output array, * even if the array also contains {@code INFINITY}.\r\n\r\n     *\r\n\r\n     * @param data array to scan\r\n\r\n     * @return descending list of values included in the input array\r\n\r\n     * @Null_Pointer_Exception if data is null\r\n\r\n     */\r\n\r\n    static std::vector<double> unique(std::vector<double>& data) \r\n\r\n    {\r\n\r\n        Tree_Set<Double> values = Tree_Set<>();\r\n\r\n        for (int i{}; i < data.size(); i++) \r\n\r\n        {\r\n\r\n            values.add(data[i]);\r\n\r\n        }\r\n\r\n        const int count = values.size();\r\n\r\n        const std::vector<double> out = std::vector<double>(count];\r\n\r\n        Iterator<Double> iterator = values.descending_iterator();\r\n\r\n        int i = 0;\r\n\r\n        while (iterator.has_next()) \r\n\r\n        {\r\n\r\n            out[i++] = iterator.next();\r\n\r\n        }\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n};\r\n