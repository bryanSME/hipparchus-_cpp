/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.util;\r\n\r\n\r\n\r\n//import java.util.Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n#include <vector>\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\n * This class allows to perform the same computation of all components of a Tuple at once.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Tuple : Calculus_Field_Element<Field_Tuple<T>> \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Components of the tuple. */\r\n\r\n    const std::vector<T> my_values;\r\n\r\n\r\n\r\n    /** Field the instance belongs to. */\r\n\r\n    const Field_Tuple_Field<T> my_field;\r\n\r\n\r\n\r\n    /** Creates a instance from its components.\r\n\r\n     * @param field field the instance belongs to\r\n\r\n     * @param x components of the tuple (beware, it is <em>not</em> copied, it is shared with caller)\r\n\r\n     */\r\n\r\n    Field_Tuple(const Field_Tuple_Field<T> field, const std::vector<T> x) { // NOPMD - storing user-supplied array is intentional and documented here\r\n\r\n        this.values = x;\r\n\r\n        this.field = field;\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Creates a instance from its components.\r\n\r\n     * @param x components of the tuple\r\n\r\n     */\r\n\r\n    //@Safe_Varargs\r\n\r\n    Field_Tuple(const T... x) \r\n\r\n    {\r\n\r\n        this(new Field_Tuple_Field<>(x[0].get_field(), x.size()), x.clone());\r\n\r\n    }\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> new_instance(const double value) \r\n\r\n    {\r\n\r\n        ////@Suppress_Warnings("unchecked")\r\n\r\n        const Field_Tuple<T> t = Field_Tuple<>(field, (std::vector<T>) Math_Arrays::build_array(field, values.size()));\r\n\r\n        Arrays.fill(t.values, value);\r\n\r\n        return t;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the dimension of the tuple.\r\n\r\n     * @return dimension of the tuple\r\n\r\n     */\r\n\r\n    int get_dimension() const\r\n\r\n    {\r\n\r\n        return my_values.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get one component of the tuple.\r\n\r\n     * @param index index of the component, between 0 and {@link #get_dimension() get_dimension()} - 1\r\n\r\n     * @return value of the component\r\n\r\n     */\r\n\r\n    T get_component(const int& index) const\r\n\r\n    {\r\n\r\n        return my_values[index];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get all components of the tuple.\r\n\r\n     * @return all components\r\n\r\n     */\r\n\r\n    std::vector<T> get_components() const\r\n\r\n    {\r\n\r\n        return my_values;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field<Field_Tuple<T>> get_field() const\r\n\r\n    {\r\n\r\n        return my_field;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> add(const Field_Tuple<T> a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].add(a.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> subtract(const Field_Tuple<T> a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].subtract(a.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> negate() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].negate();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> multiply(const Field_Tuple<T> a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].multiply(a.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> multiply(const int& n) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].multiply(n);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> divide(const Field_Tuple<T> a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].divide(a.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> reciprocal() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].reciprocal();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    bool equals(const Object obj) \r\n\r\n    {\r\n\r\n        if (obj instanceof Field_Tuple<?> ) \r\n\r\n        {\r\n\r\n            ////@Suppress_Warnings("unchecked")\r\n\r\n            const Field_Tuple<T> that = (Field_Tuple<T>) obj;\r\n\r\n            if (get_dimension() == that.get_dimension()) \r\n\r\n            {\r\n\r\n                bool equals = true;\r\n\r\n                for (int i{}; i < values.size(); ++i) \r\n\r\n                {\r\n\r\n                    equals &= values[i].equals(that.values[i]);\r\n\r\n                }\r\n\r\n                return equals;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int hash_code() \r\n\r\n    {\r\n\r\n        return  0x58f61de5 + Arrays.hash_code(values);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    double get_real() \r\n\r\n    {\r\n\r\n        return my_values[0].get_real();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> add(const double& a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].add(a);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> subtract(const double& a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].subtract(a);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> multiply(const double& a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].multiply(a);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> divide(const double& a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].divide(a);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> remainder(const double& a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].remainder(a);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> remainder(const Field_Tuple<T> a) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].remainder(a.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> abs() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].abs();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> ceil() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].ceil();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> floor() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].floor();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> rint() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].rint();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> sign() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].sign();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> copy_sign(const Field_Tuple<T> sign) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].copy_sign(sign.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> copy_sign(const double sign) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].copy_sign(sign);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> scalb(const int& n) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].scalb(n);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> ulp() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].ulp();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> hypot(const Field_Tuple<T> y) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].hypot(y.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> sqrt() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].sqrt();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> cbrt() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].cbrt();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> root_n(const int& n) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].root_n(n);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> pow(const double& p) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].pow(p);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> pow(const int& n) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].pow(n);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> pow(const Field_Tuple<T> e) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].pow(e.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> exp() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].exp();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> expm1() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].expm1();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> log() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].log();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> log1p() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].log1p();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> log10() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].log10();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> cos() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].cos();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> sin() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].sin();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Sin_Cos<Field_Tuple<T>> sin_cos() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> sin = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        const Field_Tuple<T> cos = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            const Field_Sin_Cos<T> sc = Sin_Cos(values[i]);\r\n\r\n            sin.values[i] = sc.sin();\r\n\r\n            cos.values[i] = sc.cos();\r\n\r\n        }\r\n\r\n        return Field_Sin_Cos<>(sin, cos);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> tan() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].tan();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> acos() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].acos();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> asin() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].asin();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> atan() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].atan();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> atan2(const Field_Tuple<T> x) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].atan2(x.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> cosh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].cosh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> sinh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].sinh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Sinh_Cosh<Field_Tuple<T>> sinh_cosh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> sinh = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        const Field_Tuple<T> cosh = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            const Field_Sinh_Cosh<T> sc = std::sinh_cosh(values[i]);\r\n\r\n            sinh.values[i] = sc.sinh();\r\n\r\n            cosh.values[i] = sc.cosh();\r\n\r\n        }\r\n\r\n        return Field_Sinh_Cosh<>(sinh, cosh);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> tanh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].tanh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> acosh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].acosh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> asinh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].asinh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> atanh() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].atanh();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> to_degrees() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].to_degrees();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> to_radians() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = values[i].to_radians();\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const Field_Tuple<T>[] a, const Field_Tuple<T>[] b)\r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        Math_Utils::check_dimension(a.size(), b.size());\r\n\r\n        const std::vector<T> aT = Math_Arrays::build_array(values[0].get_field(), a.size());\r\n\r\n        const std::vector<T> b_t = Math_Arrays::build_array(values[0].get_field(), b.size());\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            for (int j{}; j < a.size(); ++j) \r\n\r\n            {\r\n\r\n                aT[j] = a[j].values[i];\r\n\r\n                b_t[j] = b[j].values[i];\r\n\r\n            }\r\n\r\n            result.values[i] = aT[0].linear_combination(aT, b_t);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const std::vector<double> a, const Field_Tuple<T>[] b)\r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        Math_Utils::check_dimension(a.size(), b.size());\r\n\r\n        const std::vector<T> b_t = Math_Arrays::build_array(values[0].get_field(), b.size());\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            for (int j{}; j < a.size(); ++j) \r\n\r\n            {\r\n\r\n                b_t[j] = b[j].values[i];\r\n\r\n            }\r\n\r\n            result.values[i] = b_t[0].linear_combination(a, b_t);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const Field_Tuple<T> a1, const Field_Tuple<T> b1, const Field_Tuple<T> a2, const Field_Tuple<T> b2) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = a1.values[0].linear_combination(a1.values[i], b1.values[i], a2.values[i], b2.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const double& a1, const Field_Tuple<T> b1, const double& a2, const Field_Tuple<T> b2) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = b1.values[0].linear_combination(a1, b1.values[i], a2, b2.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const Field_Tuple<T> a1, const Field_Tuple<T> b1, const Field_Tuple<T> a2, const Field_Tuple<T> b2, const Field_Tuple<T> a3, const Field_Tuple<T> b3) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = a1.values[0].linear_combination(a1.values[i], b1.values[i], a2.values[i], b2.values[i], a3.values[i], b3.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const double& a1, const Field_Tuple<T> b1, const double& a2, const Field_Tuple<T> b2, const double& a3, const Field_Tuple<T> b3) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = b1.values[0].linear_combination(a1, b1.values[i], a2, b2.values[i], a3, b3.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const Field_Tuple<T> a1, const Field_Tuple<T> b1, const Field_Tuple<T> a2, const Field_Tuple<T> b2, const Field_Tuple<T> a3, const Field_Tuple<T> b3, const Field_Tuple<T> a4, const Field_Tuple<T> b4) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = a1.values[0].linear_combination(a1.values[i], b1.values[i], a2.values[i], b2.values[i], a3.values[i], b3.values[i], a4.values[i], b4.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> linear_combination(const double& a1, const Field_Tuple<T> b1, const double& a2, const Field_Tuple<T> b2, const double& a3, const Field_Tuple<T> b3, const double& a4, const Field_Tuple<T> b4) \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        for (int i{}; i < values.size(); ++i) \r\n\r\n        {\r\n\r\n            result.values[i] = b1.values[0].linear_combination(a1, b1.values[i], a2, b2.values[i], a3, b3.values[i], a4, b4.values[i]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Tuple<T> get_pi() \r\n\r\n    {\r\n\r\n        const Field_Tuple<T> result = Field_Tuple<>(field, Math_Arrays::build_array(values[0].get_field(), values.size()));\r\n\r\n        Arrays.fill(result.values, values[0].get_pi());\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Field for {link Field_Tuple} instances.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    //private static class Field_Tuple_Field : Field<Field_Tuple<T>> \r\n\r\n    //{\r\n\r\n\r\n\r\n    //    /** Constant function evaluating to 0.0. */\r\n\r\n    //    private const Field_Tuple<T> zero;\r\n\r\n\r\n\r\n    //    /** Constant function evaluating to 1.0. */\r\n\r\n    //    private const Field_Tuple<T> one;\r\n\r\n\r\n\r\n    //    /** Simple constructor.\r\n\r\n    //     * @param field field to which the elements belong\r\n\r\n    //     * @param dimension dimension of the tuple\r\n\r\n    //     */\r\n\r\n    //    Field_Tuple_Field(const Field<T> field, const int& dimension) \r\n\r\n    //    {\r\n\r\n    //        const std::vector<T> zero_data = Math_Arrays::build_array(field, dimension);\r\n\r\n    //        Arrays.fill(zero_data, field.get_zero());\r\n\r\n    //        const std::vector<T> one_data  = Math_Arrays::build_array(field, dimension);\r\n\r\n    //        Arrays.fill(one_data, field.get_one());\r\n\r\n    //        this.zero = Field_Tuple<>(this, zero_data);\r\n\r\n    //        this.one  = Field_Tuple<>(this, one_data);\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    /** {@inherit_doc} */\r\n\r\n    //    //override\r\n\r\n    //    public Field_Tuple<T> get_zero() \r\n\r\n    //    {\r\n\r\n    //        return zero;\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    /** {@inherit_doc} */\r\n\r\n    //    //override\r\n\r\n    //    public Field_Tuple<T> get_one() \r\n\r\n    //    {\r\n\r\n    //        return one;\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    /** {@inherit_doc} */\r\n\r\n    //    ////@Suppress_Warnings("unchecked")\r\n\r\n    //    //override\r\n\r\n    //    public Class<Field_Tuple<T>> get_runtime_class() \r\n\r\n    //    {\r\n\r\n    //        return (Class<Field_Tuple<T>>) zero.get_class();\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    /** {@inherit_doc} */\r\n\r\n    //    //override\r\n\r\n    //    public bool equals(const Object& other) \r\n\r\n    //    {\r\n\r\n    //        if (other instanceof Field_Tuple_Field) \r\n\r\n    //        {\r\n\r\n    //            ////@Suppress_Warnings("unchecked")\r\n\r\n    //            const Field_Tuple_Field<T> that = (Field_Tuple_Field<T>) other;\r\n\r\n    //            return zero.get_dimension() == that.zero.get_dimension();\r\n\r\n    //        }\r\n\r\n    //        else \r\n\r\n    //        {\r\n\r\n    //            return false;\r\n\r\n    //        }\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //    /** {@inherit_doc} */\r\n\r\n    //    //override\r\n\r\n    //    public int hash_code() \r\n\r\n    //    {\r\n\r\n    //        return 0xb4a533e1 ^ zero.get_dimension();\r\n\r\n    //    }\r\n\r\n\r\n\r\n    //}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n