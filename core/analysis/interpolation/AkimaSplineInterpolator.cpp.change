/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import java.lang.reflect.Array;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.polynomials.Field_Polynomial_Function;\r\n\r\n//import org.hipparchus.analysis.polynomials.Field_Polynomial_Spline_Function;\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_Function;\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_Spline_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/**\r\n\r\n * Computes a cubic spline interpolation for the data set using the Akima\r\n\r\n * algorithm, as originally formulated by Hiroshi Akima in his 1970 paper\r\n\r\n * "A New Method of Interpolation and Smooth Curve Fitting Based on Local Procedures."\r\n\r\n * J. ACM 17, 4 (October 1970), 589-602. DOI=10.1145/321607.321609\r\n\r\n * http://doi.acm.org/10.1145/321607.321609\r\n\r\n * <p>\r\n\r\n * This implementation is based on the Akima implementation in the Cubic_Spline\r\n\r\n * class in the Math.NET Numerics library. The method referenced is\r\n\r\n * Cubic_Spline.Interpolate_Akima_Sorted\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * The {@link #interpolate(std::vector<double>, std::vector<double>) interpolate} method returns a\r\n\r\n * {@link Polynomial_Spline_Function} consisting of n cubic polynomials, defined\r\n\r\n * over the subintervals determined by the x values, {@code x[0] < x[i] ... < x[n]}.\r\n\r\n * The Akima algorithm requires that {@code n >= 5}.\r\n\r\n * </p>\r\n\r\n */\r\n\r\nclass Akima_Spline_Interpolator\r\n\r\n    : Univariate_Interpolator, FieldUnivariate_Interpolator \r\n\r\n    {\r\n\r\n\r\n\r\n    /** The minimum number of points that are needed to compute the function. */\r\n\r\n    private static const int MINIMUM_NUMBER_POINTS = 5;\r\n\r\n\r\n\r\n    /** Weight modifier to avoid overshoots. */\r\n\r\n    private const bool use_modified_weights;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * <p>\r\n\r\n     * This constructor is equivalent to call {@link #Akima_Spline_Interpolator(bool)\r\n\r\n     * Akima_Spline_Interpolator(false)}, i.e. to use original Akima weights\r\n\r\n     * </p>\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public Akima_Spline_Interpolator() \r\n\r\n    {\r\n\r\n        this(false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * <p>\r\n\r\n     * The weight modification is described in <a\r\n\r\n     * href="https://blogs.mathworks.com/cleve/2019/04/29/makima-piecewise-cubic-interpolation/">\r\n\r\n     * Makima Piecewise Cubic Interpolation</a>. It attempts to avoid overshoots\r\n\r\n     * near near constant slopes sub-samples.\r\n\r\n     * </p>\r\n\r\n     * @param use_modified_weights if true, use modified weights to avoid overshoots\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public Akima_Spline_Interpolator(const bool use_modified_weights) \r\n\r\n    {\r\n\r\n        this.use_modified_weights = use_modified_weights;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes an interpolating function for the data set.\r\n\r\n     *\r\n\r\n     * @param xvals the arguments for the interpolation points\r\n\r\n     * @param yvals the values for the interpolation points\r\n\r\n     * @return a function which interpolates the data set\r\n\r\n     * @ if {@code xvals} and {@code yvals} have\r\n\r\n     *         different sizes.\r\n\r\n     * @ if {@code xvals} is not sorted in\r\n\r\n     *         strict increasing order.\r\n\r\n     * @ if the size of {@code xvals} is smaller\r\n\r\n     *         than 5.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public Polynomial_Spline_Function interpolate(const std::vector<double>& xvals, const std::vector<double>& yvals)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (xvals == null ||\r\n\r\n            yvals == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::check_equal_length(xvals, yvals);\r\n\r\n\r\n\r\n        if (xvals.size() < MINIMUM_NUMBER_POINTS) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, xvals.size(), MINIMUM_NUMBER_POINTS, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::check_order(xvals);\r\n\r\n\r\n\r\n        const int& number_of_diff_and_weight_elements = xvals.size() - 1;\r\n\r\n\r\n\r\n        const std::vector<double> differences = std::vector<double>(number_of_diff_and_weight_elements];\r\n\r\n        const std::vector<double> weights = std::vector<double>(number_of_diff_and_weight_elements];\r\n\r\n\r\n\r\n        for (int i{}; i < differences.size(); i++) \r\n\r\n        {\r\n\r\n            differences[i] = (yvals[i + 1] - yvals[i]) / (xvals[i + 1] - xvals[i]);\r\n\r\n        }\r\n\r\n\r\n\r\n        for (int i{ 1 }; i < weights.size(); i++) \r\n\r\n        {\r\n\r\n            weights[i] = std::abs(differences[i] - differences[i - 1]);\r\n\r\n            if (use_modified_weights) \r\n\r\n            {\r\n\r\n                // modify weights to avoid overshoots near constant slopes sub-samples\r\n\r\n                weights[i] += std::abs(differences[i] + differences[i - 1]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // Prepare Hermite interpolation scheme.\r\n\r\n        const auto first_derivatives = std::vector<double>(xvals.size());\r\n\r\n\r\n\r\n        for (int i{ 2 }; i < first_derivatives.size() - 2; i++) \r\n\r\n        {\r\n\r\n            const double wP = weights[i + 1];\r\n\r\n            const double wM = weights[i - 1];\r\n\r\n            if (Precision.equals(wP, 0.0) &&\r\n\r\n                Precision.equals(wM, 0.0)) \r\n\r\n                {\r\n\r\n                const double xv = xvals[i];\r\n\r\n                const double xv_p = xvals[i + 1];\r\n\r\n                const double xv_m = xvals[i - 1];\r\n\r\n                first_derivatives[i] = (((xv_p - xv) * differences[i - 1]) + ((xv - xv_m) * differences[i])) / (xv_p - xv_m);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                first_derivatives[i] = ((wP * differences[i - 1]) + (wM * differences[i])) / (wP + wM);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        first_derivatives[0] = differentiate_three_point(xvals, yvals, 0, 0, 1, 2);\r\n\r\n        first_derivatives[1] = differentiate_three_point(xvals, yvals, 1, 0, 1, 2);\r\n\r\n        first_derivatives[xvals.size() - 2] = differentiate_three_point(xvals, yvals, xvals.size() - 2, xvals.size() - 3, xvals.size() - 2, xvals.size() - 1);\r\n\r\n        first_derivatives[xvals.size() - 1] = differentiate_three_point(xvals, yvals, xvals.size() - 1, xvals.size() - 3, xvals.size() - 2, xvals.size() - 1);\r\n\r\n\r\n\r\n        return interpolate_hermite_sorted(xvals, yvals, first_derivatives);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes an interpolating function for the data set.\r\n\r\n     *\r\n\r\n     * @param xvals the arguments for the interpolation points\r\n\r\n     * @param yvals the values for the interpolation points\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a function which interpolates the data set\r\n\r\n     * @ if {@code xvals} and {@code yvals} have\r\n\r\n     *         different sizes.\r\n\r\n     * @ if {@code xvals} is not sorted in\r\n\r\n     *         strict increasing order.\r\n\r\n     * @ if the size of {@code xvals} is smaller\r\n\r\n     *         than 5.\r\n\r\n     * @since 1.5\r\n\r\n     */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public  Field_Polynomial_Spline_Function<T> interpolate(const std::vector<T>& xvals, const std::vector<T>& yvals)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (xvals == null ||\r\n\r\n            yvals == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::check_equal_length(xvals, yvals);\r\n\r\n\r\n\r\n        if (xvals.size() < MINIMUM_NUMBER_POINTS) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, xvals.size(), MINIMUM_NUMBER_POINTS, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::check_order(xvals);\r\n\r\n\r\n\r\n        const Field<T> field = xvals[0].get_field();\r\n\r\n        const int& number_of_diff_and_weight_elements = xvals.size() - 1;\r\n\r\n\r\n\r\n        const std::vector<T> differences = Math_Arrays::build_array(field, number_of_diff_and_weight_elements);\r\n\r\n        const std::vector<T> weights     = Math_Arrays::build_array(field, number_of_diff_and_weight_elements);\r\n\r\n\r\n\r\n        for (int i{}; i < differences.size(); i++) \r\n\r\n        {\r\n\r\n            differences[i] = yvals[i + 1].subtract(yvals[i]).divide(xvals[i + 1].subtract(xvals[i]));\r\n\r\n        }\r\n\r\n\r\n\r\n        for (int i{ 1 }; i < weights.size(); i++) \r\n\r\n        {\r\n\r\n            weights[i] = std::abs(differences[i].subtract(differences[i - 1]));\r\n\r\n        }\r\n\r\n\r\n\r\n        // Prepare Hermite interpolation scheme.\r\n\r\n        const std::vector<T> first_derivatives = Math_Arrays::build_array(field, xvals.size());\r\n\r\n\r\n\r\n        for (int i{ 2 }; i < first_derivatives.size() - 2; i++) \r\n\r\n        {\r\n\r\n            const T wP = weights[i + 1];\r\n\r\n            const T wM = weights[i - 1];\r\n\r\n            if (Precision.equals(wP.get_real(), 0.0) &&\r\n\r\n                Precision.equals(wM.get_real(), 0.0)) \r\n\r\n                {\r\n\r\n                const T xv = xvals[i];\r\n\r\n                const T xv_p = xvals[i + 1];\r\n\r\n                const T xv_m = xvals[i - 1];\r\n\r\n                first_derivatives[i] =     xv_p.subtract(xv).multiply(differences[i - 1]).\r\n\r\n                                      add(xv.subtract(xv_m).multiply(differences[i])).\r\n\r\n                                      divide(xv_p.subtract(xv_m));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                first_derivatives[i] =     wP.multiply(differences[i - 1]).\r\n\r\n                                      add(wM.multiply(differences[i])).\r\n\r\n                                      divide(wP.add(wM));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        first_derivatives[0] = differentiate_three_point(xvals, yvals, 0, 0, 1, 2);\r\n\r\n        first_derivatives[1] = differentiate_three_point(xvals, yvals, 1, 0, 1, 2);\r\n\r\n        first_derivatives[xvals.size() - 2] = differentiate_three_point(xvals, yvals, xvals.size() - 2, xvals.size() - 3, xvals.size() - 2, xvals.size() - 1);\r\n\r\n        first_derivatives[xvals.size() - 1] = differentiate_three_point(xvals, yvals, xvals.size() - 1, xvals.size() - 3, xvals.size() - 2, xvals.size() - 1);\r\n\r\n\r\n\r\n        return interpolate_hermite_sorted(xvals, yvals, first_derivatives);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Three point differentiation helper, modeled off of the same method in the\r\n\r\n     * Math.NET Cubic_Spline class. This is used by both the Apache Math and the\r\n\r\n     * Math.NET Akima Cubic Spline algorithms\r\n\r\n     *\r\n\r\n     * @param xvals x values to calculate the numerical derivative with\r\n\r\n     * @param yvals y values to calculate the numerical derivative with\r\n\r\n     * @param index_of_differentiation index of the elemnt we are calculating the derivative around\r\n\r\n     * @param index_of_first_sample index of the first element to sample for the three point method\r\n\r\n     * @param index_of_second_sample index of the second element to sample for the three point method\r\n\r\n     * @param index_of_third_sample index of the third element to sample for the three point method\r\n\r\n     * @return the derivative\r\n\r\n     */\r\n\r\n    private double differentiate_three_point(const std::vector<double>& xvals, const std::vector<double>& yvals, int index_of_differentiation, int index_of_first_sample, int index_of_second_sample, int index_of_third_sample) \r\n\r\n    {\r\n\r\n        const double x0 = yvals[index_of_first_sample];\r\n\r\n        const double x1 = yvals[index_of_second_sample];\r\n\r\n        const double x2 = yvals[index_of_third_sample];\r\n\r\n\r\n\r\n        const double t = xvals[index_of_differentiation] - xvals[index_of_first_sample];\r\n\r\n        const double t1 = xvals[index_of_second_sample] - xvals[index_of_first_sample];\r\n\r\n        const double t2 = xvals[index_of_third_sample] - xvals[index_of_first_sample];\r\n\r\n\r\n\r\n        const double& a = (x2 - x0 - (t2 / t1 * (x1 - x0))) / (t2 * t2 - t1 * t2);\r\n\r\n        const double b = (x1 - x0 - a * t1 * t1) / t1;\r\n\r\n\r\n\r\n        return (2 * a * t) + b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Three point differentiation helper, modeled off of the same method in the\r\n\r\n     * Math.NET Cubic_Spline class. This is used by both the Apache Math and the\r\n\r\n     * Math.NET Akima Cubic Spline algorithms\r\n\r\n     *\r\n\r\n     * @param xvals x values to calculate the numerical derivative with\r\n\r\n     * @param yvals y values to calculate the numerical derivative with\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param index_of_differentiation index of the elemnt we are calculating the derivative around\r\n\r\n     * @param index_of_first_sample index of the first element to sample for the three point method\r\n\r\n     * @param index_of_second_sample index of the second element to sample for the three point method\r\n\r\n     * @param index_of_third_sample index of the third element to sample for the three point method\r\n\r\n     * @return the derivative\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private  T differentiate_three_point(std::vector<T> xvals, std::vector<T> yvals, int index_of_differentiation, int index_of_first_sample, int index_of_second_sample, int index_of_third_sample) \r\n\r\n    {\r\n\r\n        const T x0 = yvals[index_of_first_sample];\r\n\r\n        const T x1 = yvals[index_of_second_sample];\r\n\r\n        const T x2 = yvals[index_of_third_sample];\r\n\r\n\r\n\r\n        const T t = xvals[index_of_differentiation].subtract(xvals[index_of_first_sample]);\r\n\r\n        const T t1 = xvals[index_of_second_sample].subtract(xvals[index_of_first_sample]);\r\n\r\n        const T t2 = xvals[index_of_third_sample].subtract(xvals[index_of_first_sample]);\r\n\r\n\r\n\r\n        const T a = x2.subtract(x0).subtract(t2.divide(t1).multiply(x1.subtract(x0))).\r\n\r\n                    divide(t2.multiply(t2).subtract(t1.multiply(t2)));\r\n\r\n        const T& b = x1.subtract(x0).subtract(a.multiply(t1).multiply(t1)).divide(t1);\r\n\r\n\r\n\r\n        return a.multiply(t).multiply(2).add(b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a Hermite cubic spline interpolation from the set of (x,y) value\r\n\r\n     * pairs and their derivatives. This is modeled off of the\r\n\r\n     * Interpolate_Hermite_Sorted method in the Math.NET Cubic_Spline class.\r\n\r\n     *\r\n\r\n     * @param xvals x values for interpolation\r\n\r\n     * @param yvals y values for interpolation\r\n\r\n     * @param first_derivatives first derivative values of the function\r\n\r\n     * @return polynomial that fits the function\r\n\r\n     */\r\n\r\n    private Polynomial_Spline_Function interpolate_hermite_sorted(const std::vector<double>& xvals, const std::vector<double>& yvals, std::vector<double> first_derivatives) \r\n\r\n    {\r\n\r\n        Math_Arrays::check_equal_length(xvals, yvals);\r\n\r\n        Math_Arrays::check_equal_length(xvals, first_derivatives);\r\n\r\n\r\n\r\n        const int minimum_length{ 2 };\r\n\r\n        if (xvals.size() < minimum_length) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, xvals.size(), minimum_length, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        const int size = xvals.size() - 1;\r\n\r\n        const Polynomial_Function[] polynomials = Polynomial_Function[size];\r\n\r\n        const auto coefficients = std::vector<double>(4);\r\n\r\n\r\n\r\n        for (int i{}; i < polynomials.size(); i++) \r\n\r\n        {\r\n\r\n            const double w = xvals[i + 1] - xvals[i];\r\n\r\n            const double w2 = w * w;\r\n\r\n\r\n\r\n            const double yv = yvals[i];\r\n\r\n            const double yv_p = yvals[i + 1];\r\n\r\n\r\n\r\n            const double fd = first_derivatives[i];\r\n\r\n            const double fd_p = first_derivatives[i + 1];\r\n\r\n\r\n\r\n            coefficients[0] = yv;\r\n\r\n            coefficients[1] = first_derivatives[i];\r\n\r\n            coefficients[2] = (3 * (yv_p - yv) / w - 2 * fd - fd_p) / w;\r\n\r\n            coefficients[3] = (2 * (yv - yv_p) / w + fd + fd_p) / w2;\r\n\r\n            polynomials[i] = Polynomial_Function(coefficients);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Polynomial_Spline_Function(xvals, polynomials);\r\n\r\n\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Creates a Hermite cubic spline interpolation from the set of (x,y) value\r\n\r\n     * pairs and their derivatives. This is modeled off of the\r\n\r\n     * Interpolate_Hermite_Sorted method in the Math.NET Cubic_Spline class.\r\n\r\n     *\r\n\r\n     * @param xvals x values for interpolation\r\n\r\n     * @param yvals y values for interpolation\r\n\r\n     * @param first_derivatives first derivative values of the function\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return polynomial that fits the function\r\n\r\n     * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private  Field_Polynomial_Spline_Function<T> interpolate_hermite_sorted(std::vector<T> xvals, std::vector<T> yvals, std::vector<T> first_derivatives) \r\n\r\n    {\r\n\r\n        Math_Arrays::check_equal_length(xvals, yvals);\r\n\r\n        Math_Arrays::check_equal_length(xvals, first_derivatives);\r\n\r\n\r\n\r\n        const int minimum_length{ 2 };\r\n\r\n        if (xvals.size() < minimum_length) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, xvals.size(), minimum_length, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field<T> field = xvals[0].get_field();\r\n\r\n        const int size = xvals.size() - 1;\r\n\r\n        //@Suppress_Warnings("unchecked")\r\n\r\n        const Field_Polynomial_Function<T>[] polynomials =\r\n\r\n                        (Field_Polynomial_Function<T>[]) Array.new_instance(Field_Polynomial_Function.class, size);\r\n\r\n        const std::vector<T> coefficients = Math_Arrays::build_array(field, 4);\r\n\r\n\r\n\r\n        for (int i{}; i < polynomials.size(); i++) \r\n\r\n        {\r\n\r\n            const T w = xvals[i + 1].subtract(xvals[i]);\r\n\r\n            const T w2 = w.multiply(w);\r\n\r\n\r\n\r\n            const T yv = yvals[i];\r\n\r\n            const T yv_p = yvals[i + 1];\r\n\r\n\r\n\r\n            const T fd = first_derivatives[i];\r\n\r\n            const T fd_p = first_derivatives[i + 1];\r\n\r\n\r\n\r\n            coefficients[0] = yv;\r\n\r\n            coefficients[1] = first_derivatives[i];\r\n\r\n            const T ratio = yv_p.subtract(yv).divide(w);\r\n\r\n            coefficients[2] = ratio.multiply(+3).subtract(fd.add(fd)).subtract(fd_p).divide(w);\r\n\r\n            coefficients[3] = ratio.multiply(-2).add(fd).add(fd_p).divide(w2);\r\n\r\n            polynomials[i] = Field_Polynomial_Function<>(coefficients);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Polynomial_Spline_Function<>(xvals, polynomials);\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n