/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Adapter for classes implementing the {@link Univariate_Interpolator}\r\n\r\n * interface.\r\n\r\n * The data to be interpolated is assumed to be periodic. Thus values that are\r\n\r\n * outside of the range can be passed to the interpolation function: They will\r\n\r\n * be wrapped into the initial range before being passed to the class that\r\n\r\n * actually computes the interpolation.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Univariate_Periodic_Interpolator\r\n\r\n    : Univariate_Interpolator \r\n\r\n    {\r\n\r\n    /** Default number of extension points of the samples array. */\r\n\r\n    public static const int DEFAULT_EXTEND = 5;\r\n\r\n    /** Interpolator. */\r\n\r\n    private const Univariate_Interpolator interpolator;\r\n\r\n    /** Period. */\r\n\r\n    private const double period;\r\n\r\n    /** Number of extension points. */\r\n\r\n    private const int extend;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds an interpolator.\r\n\r\n     *\r\n\r\n     * @param interpolator Interpolator.\r\n\r\n     * @param period Period.\r\n\r\n     * @param extend Number of points to be appended at the beginning and\r\n\r\n     * end of the sample arrays in order to avoid interpolation failure at\r\n\r\n     * the (periodic) boundaries of the orginal interval. The value is the\r\n\r\n     * number of sample points which the original {@code interpolator} needs\r\n\r\n     * on each side of the interpolated point.\r\n\r\n     */\r\n\r\n    public Univariate_Periodic_Interpolator(Univariate_Interpolator interpolator, const double& period, int extend) \r\n\r\n    {\r\n\r\n        this.interpolator = interpolator;\r\n\r\n        this.period = period;\r\n\r\n        this.extend = extend;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds an interpolator.\r\n\r\n     * Uses {@link #DEFAULT_EXTEND} as the number of extension points on each side\r\n\r\n     * of the original abscissae range.\r\n\r\n     *\r\n\r\n     * @param interpolator Interpolator.\r\n\r\n     * @param period Period.\r\n\r\n     */\r\n\r\n    public Univariate_Periodic_Interpolator(Univariate_Interpolator interpolator, double period) \r\n\r\n    {\r\n\r\n        this(interpolator, period, DEFAULT_EXTEND);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if the number of extension points\r\n\r\n     * is larger than the size of {@code xval}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public Univariate_Function interpolate(std::vector<double> xval, std::vector<double> yval)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (xval.size() < extend) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, xval.size(), extend);\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::check_order(xval);\r\n\r\n        const double offset = xval[0];\r\n\r\n\r\n\r\n        const int len = xval.size() + extend * 2;\r\n\r\n        const std::vector<double> x = std::vector<double>(len];\r\n\r\n        const std::vector<double> y = std::vector<double>(len];\r\n\r\n        for (int i{}; i < xval.size(); i++) \r\n\r\n        {\r\n\r\n            const int index = i + extend;\r\n\r\n            x[index] = Math_Utils::reduce(xval[i], period, offset);\r\n\r\n            y[index] = yval[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        // Wrap to enable interpolation at the boundaries.\r\n\r\n        for (int i{}; i < extend; i++) \r\n\r\n        {\r\n\r\n            int index = xval.size() - extend + i;\r\n\r\n            x[i] = Math_Utils::reduce(xval[index], period, offset) - period;\r\n\r\n            y[i] = yval[index];\r\n\r\n\r\n\r\n            index = len - extend + i;\r\n\r\n            x[index] = Math_Utils::reduce(xval[i], period, offset) + period;\r\n\r\n            y[index] = yval[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        Math_Arrays::sort_in_place(x, y);\r\n\r\n\r\n\r\n        const Univariate_Function f = interpolator.interpolate(x, y);\r\n\r\n        return Univariate_Function() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public double value(const double& x)  \r\n\r\n            {\r\n\r\n                return f.value(Math_Utils::reduce(x, period, offset));\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n