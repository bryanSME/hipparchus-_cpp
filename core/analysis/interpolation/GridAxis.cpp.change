/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n#include <vector>\r\n\r\n#include <atomic>\r\n\r\n#include "../../util/MathArrays.h"\r\n\r\n//import java.io.Serializable;\r\n\r\n//import java.util.concurrent.atomic.Atomic_Integer;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/**\r\n\r\n * Helper for finding interpolation nodes along one axis of grid data.\r\n\r\n * <p>\r\n\r\n * This class is intended to be used for interpolating inside grids.\r\n\r\n * It works on any sorted data without duplication and size at least\r\n\r\n * {@code n} where {@code n} is the number of points required for\r\n\r\n * interpolation (i.e. 2 for linear interpolation, 3 for quadratic...)\r\n\r\n * <p>\r\n\r\n * </p>\r\n\r\n * The method uses linear interpolation to select the nodes indices.\r\n\r\n * It should be O(1) for sufficiently regular data, therefore much faster\r\n\r\n * than bisection. It also features caching, which improves speed when\r\n\r\n * interpolating several points in raw in the close locations, i.e. when\r\n\r\n * successive calls have a high probability to return the same interpolation\r\n\r\n * nodes. This occurs for example when scanning with small steps a loose\r\n\r\n * grid. The method also works on non-regular grids, but may be slower in\r\n\r\n * this case.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * This class is thread-safe.\r\n\r\n * </p>\r\n\r\n * @since 1.4\r\n\r\n */\r\n\r\nclass Grid_Axis  \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** All the coordinates of the interpolation points, sorted in increasing order. */\r\n\r\n    std::vector<double> my_grid;\r\n\r\n\r\n\r\n    /** Number of points required for interpolation. */\r\n\r\n    int my_n;\r\n\r\n\r\n\r\n    /** Cached value of last x index. */\r\n\r\n    std::atomic<int> my_cache;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param grid coordinates of the interpolation points, sorted in increasing order\r\n\r\n     * @param n number of points required for interpolation, i.e. 2 for linear, 3\r\n\r\n     * for quadratic...\r\n\r\n     * @exception  if grid size is smaller than {@code n}\r\n\r\n     * or if the grid is not sorted in strict increasing order\r\n\r\n     */\r\n\r\n    Grid_Axis(const std::vector<double>& grid, const int& n)\r\n\r\n        : my_grid{ grid }, my_n{ n }, my_cache{ std::atomic<int>(0) }\r\n\r\n    {\r\n\r\n        //// safety checks\r\n\r\n        //if (my_grid.size() < n) \r\n\r\n        //{\r\n\r\n        //    throw (Localized_Core_Formats.INSUFFICIENT_DIMENSION, grid.size(), n);\r\n\r\n        //}\r\n\r\n        //Math_Arrays::check_order(grid);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the number of points of the grid.\r\n\r\n     * @return number of points of the grid\r\n\r\n     */\r\n\r\n    int size() const \r\n\r\n    {\r\n\r\n        return my_grid.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the number of points required for interpolation.\r\n\r\n     * @return number of points required for interpolation\r\n\r\n     */\r\n\r\n    int get_n() const \r\n\r\n    {\r\n\r\n        return my_n;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the interpolation node at specified index.\r\n\r\n     * @param index node index\r\n\r\n     * @return coordinate of the node at specified index\r\n\r\n     */\r\n\r\n    double node(const int& index) const\r\n\r\n    {\r\n\r\n        return my_grid[index];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the index of the first interpolation node for some coordinate along the grid.\r\n\r\n     * <p>\r\n\r\n     * The index return is the one for the lowest interpolation node suitable for\r\n\r\n     * {@code t}. This means that if {@code i} is returned the nodes to use for\r\n\r\n     * interpolation at coordinate {@code t} are at indices {@code i}, {@code i+1}, * ..., {@code i+n-1}, where {@code n} is the number of points required for\r\n\r\n     * interpolation passed at construction.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * The index is selected in order to have the subset of nodes from {@code i} to\r\n\r\n     * {@code i+n-1} as balanced as possible around {@code t}:\r\n\r\n     * </p>\r\n\r\n     * <ul>\r\n\r\n     *   <li>\r\n\r\n     *     if {@code t} is inside the grid and sufficiently far from the endpoints\r\n\r\n     *     <ul>\r\n\r\n     *       <li>\r\n\r\n     *         if {@code n} is even, the returned nodes will be perfectly balanced:\r\n\r\n     *         there will be {@code n/2} nodes smaller than {@code t} and {@code n/2}\r\n\r\n     *         nodes larger than {@code t}\r\n\r\n     *       </li>\r\n\r\n     *       <li>\r\n\r\n     *         if {@code n} is odd, the returned nodes will be slightly unbalanced by\r\n\r\n     *         one point: there will be {@code (n+1)/2} nodes smaller than {@code t}\r\n\r\n     *         and {@code (n-1)/2} nodes larger than {@code t}\r\n\r\n     *       </li>\r\n\r\n     *     </ul>\r\n\r\n     *   </li>\r\n\r\n     *   <li>\r\n\r\n     *     if {@code t} is inside the grid and close to endpoints, the returned nodes\r\n\r\n     *     will be unbalanced: there will be less nodes on the endpoints side and\r\n\r\n     *     more nodes on the interior side\r\n\r\n     *   </li>\r\n\r\n     *   <li>\r\n\r\n     *     if {@code t} is outside of the grid, the returned nodes will completely\r\n\r\n     *     off balance: all nodes will be on the same side with respect to {@code t}\r\n\r\n     *   </li>\r\n\r\n     * </ul>\r\n\r\n     * <p>\r\n\r\n     * It is <em>not</em> an error to call this method with {@code t} outside of the grid, * it simply implies that the interpolation will become an extrapolation and accuracy\r\n\r\n     * will decrease as {@code t} goes farther from the grid points. This is intended so\r\n\r\n     * interpolation does not fail near the end of the grid.\r\n\r\n     * </p>\r\n\r\n     * @param t coordinate of the point to interpolate\r\n\r\n     * @return index {@code i} such {@link #nodestatic_cast<int>( node(i)}, {@link #nodestatic_cast<int>( node(i+1)}, * ... {@link #nodestatic_cast<int>( node(i+n-1)} can be used for interpolating a value at\r\n\r\n     * coordinate {@code t}\r\n\r\n     * @since 1.4\r\n\r\n     */\r\n\r\n    int interpolation_index(const double& t) \r\n\r\n    {\r\n\r\n\r\n\r\n        const int middle_offset = (my_n - 1) / 2;\r\n\r\n        int i_inf = middle_offset;\r\n\r\n        int i_sup = my_grid.size() - (my_n - 1) + middle_offset;\r\n\r\n\r\n\r\n        // first try to simply reuse the cached index, // for faster return in a common case\r\n\r\n        auto    cached = my_cache.load(); // .get();\r\n\r\n        const auto    middle = cached + middle_offset;\r\n\r\n        const double& a_mid0  = my_grid[middle];\r\n\r\n        const double& a_mid1  = my_grid[middle + 1];\r\n\r\n        if (t < a_mid0) \r\n\r\n        {\r\n\r\n            if (middle == i_inf) \r\n\r\n            {\r\n\r\n                // we are in the unbalanced low area\r\n\r\n                return cached;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        else if (t < a_mid1) \r\n\r\n        {\r\n\r\n            // we are in the balanced middle area\r\n\r\n            return cached;\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            if (middle == i_sup - 1) \r\n\r\n            {\r\n\r\n                // we are in the unbalanced high area\r\n\r\n                return cached;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // we need to find a index\r\n\r\n        auto a_inf = my_grid[i_inf];\r\n\r\n        auto a_sup = my_grid[i_sup];\r\n\r\n        while (i_sup - i_inf > 1) \r\n\r\n        {\r\n\r\n            const int i_interp = static_cast<int>( ((i_inf * (a_sup - t) + i_sup * (t - a_inf)) / (a_sup - a_inf));\r\n\r\n            const int i_med    = std::max(i_inf + 1, std::min(i_interp, i_sup - 1));\r\n\r\n            if (t < my_grid[i_med]) \r\n\r\n            {\r\n\r\n                // keeps looking in the lower part of the grid\r\n\r\n                i_sup = i_med;\r\n\r\n                a_sup = my_grid[i_sup];\r\n\r\n            }\r\n\r\n            else \r\n\r\n            {\r\n\r\n                // keeps looking in the upper part of the grid\r\n\r\n                i_inf = i_med;\r\n\r\n                a_inf = my_grid[i_inf];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n       const auto new_cached = i_inf - middle_offset;\r\n\r\n       my_cache.compare_exchange_strong(cached, new_cached);\r\n\r\n       return new_cached;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n};\r\n