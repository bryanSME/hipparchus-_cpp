/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Bivariate_Function;\r\n\r\n//import org.hipparchus.analysis.FieldBivariate_Function;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n\r\n\r\n/**\r\n\r\n * Interpolate grid data using bi-linear interpolation.\r\n\r\n * <p>\r\n\r\n * This interpolator is thread-safe.\r\n\r\n * </p>\r\n\r\n * @since 1.4\r\n\r\n */\r\n\r\nclass Bilinear_interpolating_function : Bivariate_Function, FieldBivariate_Function\r\n\r\n{\r\n\r\n\r\n\r\n    /** Serializable UID. */\r\n\r\n    private static const long serial_version_uid = 20180926L;\r\n\r\n\r\n\r\n    /** Grid along the x axis. */\r\n\r\n    private const Grid_Axis x_grid;\r\n\r\n\r\n\r\n    /** Grid along the y axis. */\r\n\r\n    private const Grid_Axis y_grid;\r\n\r\n\r\n\r\n    /** Grid size along the y axis. */\r\n\r\n    private const int y_size;\r\n\r\n\r\n\r\n    /** Values of the interpolation points on all the grid knots (in a flatten array). */\r\n\r\n    private const std::vector<double> f_val;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param x_val All the x-coordinates of the interpolation points, sorted\r\n\r\n     * in increasing order.\r\n\r\n     * @param y_val All the y-coordinates of the interpolation points, sorted\r\n\r\n     * in increasing order.\r\n\r\n     * @param f_val The values of the interpolation points on all the grid knots:\r\n\r\n     * {@code f_val[i][j] = f(x_val[i], y_val[j])}.\r\n\r\n     * @exception  if grid size is smaller than 2\r\n\r\n     * or if the grid is not sorted in strict increasing order\r\n\r\n     */\r\n\r\n    public Bilinear_interpolating_function(const std::vector<double> x_val, const std::vector<double> y_val, const std::vector<std::vector<double>> f_val)\r\n\r\n         \r\n\r\n        {\r\n\r\n        this.x_grid = Grid_Axis(x_val, 2);\r\n\r\n        this.y_grid = Grid_Axis(y_val, 2);\r\n\r\n        this.y_size = y_val.size();\r\n\r\n        this.f_val  = std::vector<double>(x_val.size() * y_size];\r\n\r\n        int k = 0;\r\n\r\n        for (int i{}; i < x_val.size(); ++i) \r\n\r\n        {\r\n\r\n            const std::vector<double> fi = f_val[i];\r\n\r\n            for (int j{}; j < y_size; ++j) \r\n\r\n            {\r\n\r\n                this.f_val[k++] = fi[j];\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the lowest grid x coordinate.\r\n\r\n     * @return lowest grid x coordinate\r\n\r\n     */\r\n\r\n    public double get_x_inf() \r\n\r\n    {\r\n\r\n        return x_grid.node(0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the highest grid x coordinate.\r\n\r\n     * @return highest grid x coordinate\r\n\r\n     */\r\n\r\n    public double get_x_sup() \r\n\r\n    {\r\n\r\n        return x_grid.node(x_grid.size() - 1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the lowest grid y coordinate.\r\n\r\n     * @return lowest grid y coordinate\r\n\r\n     */\r\n\r\n    public double get_y_inf() \r\n\r\n    {\r\n\r\n        return y_grid.node(0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the highest grid y coordinate.\r\n\r\n     * @return highest grid y coordinate\r\n\r\n     */\r\n\r\n    public double get_y_sup() \r\n\r\n    {\r\n\r\n        return y_grid.node(y_grid.size() - 1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public double value(const double& x, const double y) \r\n\r\n    {\r\n\r\n\r\n\r\n        // get the interpolation nodes\r\n\r\n        const int    i   = x_grid.interpolation_index(x);\r\n\r\n        const int    j   = y_grid.interpolation_index(y);\r\n\r\n        const double x0  = x_grid.node(i);\r\n\r\n        const double x1  = x_grid.node(i + 1);\r\n\r\n        const double y0  = y_grid.node(j);\r\n\r\n        const double y1  = y_grid.node(j + 1);\r\n\r\n\r\n\r\n        // get the function values at interpolation nodes\r\n\r\n        const int    k0  = i * y_size + j;\r\n\r\n        const int    k1  = k0 + y_size;\r\n\r\n        const double z00 = f_val[k0];\r\n\r\n        const double z01 = f_val[k0 + 1];\r\n\r\n        const double z10 = f_val[k1];\r\n\r\n        const double z11 = f_val[k1 + 1];\r\n\r\n\r\n\r\n        // interpolate\r\n\r\n        const double dx0  = x  - x0;\r\n\r\n        const double dx1  = x1 - x;\r\n\r\n        const double dx10 = x1 - x0;\r\n\r\n        const double dy0  = y  - y0;\r\n\r\n        const double dy1  = y1 - y;\r\n\r\n        const double dy10 = y1 - y0;\r\n\r\n        return (dx0 * (dy0 * z11 + dy1 * z10) + dx1 * (dy0 * z01 + dy1 * z00)) /\r\n\r\n               (dx10 * dy10);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * @since 1.5\r\n\r\n     */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public  T value(T x, T y) \r\n\r\n    {\r\n\r\n\r\n\r\n        // get the interpolation nodes\r\n\r\n        const int    i   = x_grid.interpolation_index(x.get_real());\r\n\r\n        const int    j   = y_grid.interpolation_index(y.get_real());\r\n\r\n        const double x0  = x_grid.node(i);\r\n\r\n        const double x1  = x_grid.node(i + 1);\r\n\r\n        const double y0  = y_grid.node(j);\r\n\r\n        const double y1  = y_grid.node(j + 1);\r\n\r\n\r\n\r\n        // get the function values at interpolation nodes\r\n\r\n        const int    k0  = i * y_size + j;\r\n\r\n        const int    k1  = k0 + y_size;\r\n\r\n        const double z00 = f_val[k0];\r\n\r\n        const double z01 = f_val[k0 + 1];\r\n\r\n        const double z10 = f_val[k1];\r\n\r\n        const double z11 = f_val[k1 + 1];\r\n\r\n\r\n\r\n        // interpolate\r\n\r\n        const T      dx0   = x.subtract(x0);\r\n\r\n        const T      mdx1  = x.subtract(x1);\r\n\r\n        const double dx10  = x1 - x0;\r\n\r\n        const T      dy0   = y.subtract(y0);\r\n\r\n        const T      mdy1  = y.subtract(y1);\r\n\r\n        const double dy10  = y1 - y0;\r\n\r\n        return          dy0.multiply(z11).subtract(mdy1.multiply(z10)).multiply(dx0).\r\n\r\n               subtract(dy0.multiply(z01).subtract(mdy1.multiply(z00)).multiply(mdx1)).\r\n\r\n               divide(dx10 * dy10);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n