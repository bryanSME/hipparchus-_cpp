/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.random.UnitSphereRandom_Vector_Generator;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Utility class for the {@link Microsphere_Projection_Interpolator} algorithm.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Interpolating_Microsphere \r\n\r\n{\r\n\r\n    /** Microsphere. */\r\n\r\n    private const List<Facet> microsphere;\r\n\r\n    /** Microsphere data. */\r\n\r\n    private const List<Facet_Data> microsphere_data;\r\n\r\n    /** Space dimension. */\r\n\r\n    private const int dimension;\r\n\r\n    /** Number of surface elements. */\r\n\r\n    private const int size;\r\n\r\n    /** Maximum fraction of the facets that can be dark. */\r\n\r\n    private const double max_dark_fraction;\r\n\r\n    /** Lowest non-zero illumination. */\r\n\r\n    private const double dark_threshold;\r\n\r\n    /** Background value. */\r\n\r\n    private const double background;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create an unitialiazed sphere.\r\n\r\n     * Sub-classes are responsible for calling the {@code add(std::vector<double>) add}\r\n\r\n     * method in order to initialize all the sphere's facets.\r\n\r\n     *\r\n\r\n     * @param dimension Dimension of the data space.\r\n\r\n     * @param size Number of surface elements of the sphere.\r\n\r\n     * @param max_dark_fraction Maximum fraction of the facets that can be dark.\r\n\r\n     * If the fraction of "non-illuminated" facets is larger, no estimation\r\n\r\n     * of the value will be performed, and the {@code background} value will\r\n\r\n     * be returned instead.\r\n\r\n     * @param dark_threshold Value of the illumination below which a facet is\r\n\r\n     * considered dark.\r\n\r\n     * @param background Value returned when the {@code max_dark_fraction}\r\n\r\n     * threshold is exceeded.\r\n\r\n     * @ if {@code dimension <= 0}\r\n\r\n     * or {@code size <= 0}.\r\n\r\n     * @ if {@code dark_threshold < 0}.\r\n\r\n     * @ if {@code max_dark_fraction} does not\r\n\r\n     * belong to the interval {@code [0, 1]}.\r\n\r\n     */\r\n\r\n    protected Interpolating_Microsphere(const int& dimension, int size, double max_dark_fraction, double dark_threshold, double background) \r\n\r\n    {\r\n\r\n        if (dimension <= 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, dimension, 0);\r\n\r\n        }\r\n\r\n        if (size <= 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, size, 0);\r\n\r\n        }\r\n\r\n        Math_Utils::check_range_inclusive(max_dark_fraction, 0, 1);\r\n\r\n        if (dark_threshold < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, dark_threshold, 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        this.dimension = dimension;\r\n\r\n        this.size = size;\r\n\r\n        this.max_dark_fraction = max_dark_fraction;\r\n\r\n        this.dark_threshold = dark_threshold;\r\n\r\n        this.background = background;\r\n\r\n        microsphere = Array_list<>(size);\r\n\r\n        microsphere_data = Array_list<>(size);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a sphere from randomly sampled vectors.\r\n\r\n     *\r\n\r\n     * @param dimension Dimension of the data space.\r\n\r\n     * @param size Number of surface elements of the sphere.\r\n\r\n     * @param rand Unit vector generator for creating the microsphere.\r\n\r\n     * @param max_dark_fraction Maximum fraction of the facets that can be dark.\r\n\r\n     * If the fraction of "non-illuminated" facets is larger, no estimation\r\n\r\n     * of the value will be performed, and the {@code background} value will\r\n\r\n     * be returned instead.\r\n\r\n     * @param dark_threshold Value of the illumination below which a facet\r\n\r\n     * is considered dark.\r\n\r\n     * @param background Value returned when the {@code max_dark_fraction}\r\n\r\n     * threshold is exceeded.\r\n\r\n     * @ if the size of the generated\r\n\r\n     * vectors does not match the dimension set in the constructor.\r\n\r\n     * @ if {@code dimension <= 0}\r\n\r\n     * or {@code size <= 0}.\r\n\r\n     * @ if {@code dark_threshold < 0}.\r\n\r\n     * @ if {@code max_dark_fraction} does not\r\n\r\n     * belong to the interval {@code [0, 1]}.\r\n\r\n     */\r\n\r\n    public Interpolating_Microsphere(const int& dimension, int size, double max_dark_fraction, double dark_threshold, double background, UnitSphereRandom_Vector_Generator rand) \r\n\r\n    {\r\n\r\n        this(dimension, size, max_dark_fraction, dark_threshold, background);\r\n\r\n\r\n\r\n        // Generate the microsphere normals, assuming that a number of\r\n\r\n        // randomly generated normals will represent a sphere.\r\n\r\n        for (int i{}; i < size; i++) \r\n\r\n        {\r\n\r\n            add(rand.next_vector(), false);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Copy constructor.\r\n\r\n     *\r\n\r\n     * @param other Instance to copy.\r\n\r\n     */\r\n\r\n    protected Interpolating_Microsphere(Interpolating_Microsphere other) \r\n\r\n    {\r\n\r\n        dimension = other.dimension;\r\n\r\n        size = other.size;\r\n\r\n        max_dark_fraction = other.max_dark_fraction;\r\n\r\n        dark_threshold = other.dark_threshold;\r\n\r\n        background = other.background;\r\n\r\n\r\n\r\n        // Field can be shared.\r\n\r\n        microsphere = other.microsphere;\r\n\r\n\r\n\r\n        // Field must be copied.\r\n\r\n        microsphere_data = Array_list<>(size);\r\n\r\n        for (Facet_Data fd : other.microsphere_data) \r\n\r\n        {\r\n\r\n            microsphere_data.add(new Facet_Data(fd.illumination(), fd.sample()));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Perform a copy.\r\n\r\n     *\r\n\r\n     * @return a copy of this instance.\r\n\r\n     */\r\n\r\n    public Interpolating_Microsphere copy() \r\n\r\n    {\r\n\r\n        return Interpolating_Microsphere(this);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the space dimensionality.\r\n\r\n     *\r\n\r\n     * @return the number of space dimensions.\r\n\r\n     */\r\n\r\n    public int get_dimension() \r\n\r\n    {\r\n\r\n        return dimension;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the size of the sphere.\r\n\r\n     *\r\n\r\n     * @return the number of surface elements of the microspshere.\r\n\r\n     */\r\n\r\n    public int get_size() \r\n\r\n    {\r\n\r\n        return size;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Estimate the value at the requested location.\r\n\r\n     * This microsphere is placed at the given {@code point}, contribution\r\n\r\n     * of the given {@code sample_points} to each sphere facet is computed\r\n\r\n     * (illumination) and the interpolation is performed (integration of\r\n\r\n     * the illumination).\r\n\r\n     *\r\n\r\n     * @param point Interpolation point.\r\n\r\n     * @param sample_points Sampling data points.\r\n\r\n     * @param sample_values Sampling data values at the corresponding\r\n\r\n     * {@code sample_points}.\r\n\r\n     * @param exponent Exponent used in the power law that computes\r\n\r\n     * the weights (distance dimming factor) of the sample data.\r\n\r\n     * @param no_interpolation_tolerance When the distance between the\r\n\r\n     * {@code point} and one of the {@code sample_points} is less than\r\n\r\n     * this value, no interpolation will be performed, and the value\r\n\r\n     * of the sample will just be returned.\r\n\r\n     * @return the estimated value at the given {@code point}.\r\n\r\n     * @ if {@code exponent < 0}.\r\n\r\n     */\r\n\r\n    public double value(std::vector<double> point, std::vector<std::vector<double>> sample_points, std::vector<double> sample_values, double exponent, double no_interpolation_tolerance) \r\n\r\n    {\r\n\r\n        if (exponent < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, exponent, 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        clear();\r\n\r\n\r\n\r\n        // Contribution of each sample point to the illumination of the\r\n\r\n        // microsphere's facets.\r\n\r\n        const int& num_samples = sample_points.size();\r\n\r\n        for (int i{}; i < num_samples; i++) \r\n\r\n        {\r\n\r\n            // Vector between interpolation point and current sample point.\r\n\r\n            const std::vector<double> diff = Math_Arrays::ebe_subtract(sample_points[i], point);\r\n\r\n            const double diff_norm = Math_Arrays::safe_norm(diff);\r\n\r\n\r\n\r\n            if (std::abs(diff_norm) < no_interpolation_tolerance) \r\n\r\n            {\r\n\r\n                // No need to interpolate, as the interpolation point is\r\n\r\n                // actually (very close to) one of the sampled points.\r\n\r\n                return sample_values[i];\r\n\r\n            }\r\n\r\n\r\n\r\n            const double weight = std::pow(diff_norm, -exponent);\r\n\r\n            illuminate(diff, sample_values[i], weight);\r\n\r\n        }\r\n\r\n\r\n\r\n        return interpolate();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Replace {@code i}-th facet of the microsphere.\r\n\r\n     * Method for initializing the microsphere facets.\r\n\r\n     *\r\n\r\n     * @param normal Facet's normal vector.\r\n\r\n     * @param copy Whether to copy the given array.\r\n\r\n     * @ if the length of {@code n}\r\n\r\n     * does not match the space dimension.\r\n\r\n     * @Math_Illegal_State_Exception if the method has been called\r\n\r\n     * more times than the size of the sphere.\r\n\r\n     */\r\n\r\n    protected void add(std::vector<double> normal, bool copy) \r\n\r\n    {\r\n\r\n        if (microsphere.size() >= size) \r\n\r\n        {\r\n\r\n            throw Math_Illegal_State_Exception(Localized_Core_Formats.MAX_COUNT_EXCEEDED, size);\r\n\r\n        }\r\n\r\n        if (normal.size() > dimension) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, normal.size(), dimension);\r\n\r\n        }\r\n\r\n\r\n\r\n        microsphere.add(new Facet(copy ? normal.clone() : normal));\r\n\r\n        microsphere_data.add(new Facet_Data(0d, 0.0));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Interpolation.\r\n\r\n     *\r\n\r\n     * @return the value estimated from the current illumination of the\r\n\r\n     * microsphere.\r\n\r\n     */\r\n\r\n    private double interpolate() \r\n\r\n    {\r\n\r\n        // Number of non-illuminated facets.\r\n\r\n        int dark_count = 0;\r\n\r\n\r\n\r\n        double value = 0;\r\n\r\n        double total_weight = 0;\r\n\r\n        for (Facet_Data fd : microsphere_data) \r\n\r\n        {\r\n\r\n            const double iV = fd.illumination();\r\n\r\n            if (iV != 0.0) \r\n\r\n            {\r\n\r\n                value += iV * fd.sample();\r\n\r\n                total_weight += iV;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                ++dark_count;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        const double dark_fraction = dark_count / static_cast<double>( size;\r\n\r\n\r\n\r\n        return dark_fraction <= max_dark_fraction ?\r\n\r\n            value / total_weight :\r\n\r\n            background;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Illumination.\r\n\r\n     *\r\n\r\n     * @param sample_direction Vector whose origin is at the interpolation\r\n\r\n     * point and tail is at the sample location.\r\n\r\n     * @param sample_value Data value of the sample.\r\n\r\n     * @param weight Weight.\r\n\r\n     */\r\n\r\n    private void illuminate(std::vector<double> sample_direction, double sample_value, double weight) \r\n\r\n    {\r\n\r\n        for (int i{}; i < size; i++) \r\n\r\n        {\r\n\r\n            const std::vector<double> n = microsphere.get(i).get_normal();\r\n\r\n            const double cos = Math_Arrays::cos_angle(n, sample_direction);\r\n\r\n\r\n\r\n            if (cos > 0) \r\n\r\n            {\r\n\r\n                const double illumination = cos * weight;\r\n\r\n\r\n\r\n                if (illumination > dark_threshold &&\r\n\r\n                    illumination > microsphere_data.get(i).illumination()) \r\n\r\n                    {\r\n\r\n                    microsphere_data.set(i, Facet_Data(illumination, sample_value));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Reset the all the {@link Facet facets} data to zero.\r\n\r\n     */\r\n\r\n    private void clear() \r\n\r\n    {\r\n\r\n        for (int i{}; i < size; i++) \r\n\r\n        {\r\n\r\n            microsphere_data.set(i, Facet_Data(0d, 0.0));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Microsphere "facet" (surface element).\r\n\r\n     */\r\n\r\n    private static class Facet \r\n\r\n    {\r\n\r\n        /** Normal vector characterizing a surface element. */\r\n\r\n        private const std::vector<double> normal;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * @param n Normal vector characterizing a surface element\r\n\r\n         * of the microsphere. No copy is made.\r\n\r\n         */\r\n\r\n        Facet(std::vector<double> n) { // NOPMD - array cloning is taken care of at call site\r\n\r\n            normal = n;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Return a reference to the vector normal to this facet.\r\n\r\n         *\r\n\r\n         * @return the normal vector.\r\n\r\n         */\r\n\r\n        public std::vector<double> get_normal() \r\n\r\n        {\r\n\r\n            return normal; // NOPMD - returning an internal array is intentional and documented here\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Data associated with each {@link Facet}.\r\n\r\n     */\r\n\r\n    private static class Facet_Data \r\n\r\n    {\r\n\r\n        /** Illumination received from the sample. */\r\n\r\n        private const double illumination;\r\n\r\n        /** Data value of the sample. */\r\n\r\n        private const double sample;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * @param illumination Illumination.\r\n\r\n         * @param sample Data value.\r\n\r\n         */\r\n\r\n        Facet_Data(double illumination, double sample) \r\n\r\n        {\r\n\r\n            this.illumination = illumination;\r\n\r\n            this.sample = sample;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the illumination.\r\n\r\n         * @return the illumination.\r\n\r\n         */\r\n\r\n        public double illumination() \r\n\r\n        {\r\n\r\n            return illumination;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the data value.\r\n\r\n         * @return the data value.\r\n\r\n         */\r\n\r\n        public double sample() \r\n\r\n        {\r\n\r\n            return sample;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n