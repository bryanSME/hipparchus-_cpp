/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Multivariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.random.UnitSphereRandom_Vector_Generator;\r\n\r\n\r\n\r\n/**\r\n\r\n * Interpolator that : the algorithm described in\r\n\r\n * <em>William Dudziak</em>'s\r\n\r\n * <a href="http://www.dudziak.com/microsphere.pdf">MS thesis</a>.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Microsphere_Projection_Interpolator\r\n\r\n    : Multivariate_Interpolator \r\n\r\n    {\r\n\r\n    /** Brightness exponent. */\r\n\r\n    private const double exponent;\r\n\r\n    /** Microsphere. */\r\n\r\n    private const Interpolating_Microsphere microsphere;\r\n\r\n    /** Whether to share the sphere. */\r\n\r\n    private const bool shared_sphere;\r\n\r\n    /** Tolerance value below which no interpolation is necessary. */\r\n\r\n    private const double no_interpolation_tolerance;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a microsphere interpolator.\r\n\r\n     *\r\n\r\n     * @param dimension Space dimension.\r\n\r\n     * @param elements Number of surface elements of the microsphere.\r\n\r\n     * @param exponent Exponent used in the power law that computes the\r\n\r\n     * @param max_dark_fraction Maximum fraction of the facets that can be dark.\r\n\r\n     * If the fraction of "non-illuminated" facets is larger, no estimation\r\n\r\n     * of the value will be performed, and the {@code background} value will\r\n\r\n     * be returned instead.\r\n\r\n     * @param dark_threshold Value of the illumination below which a facet is\r\n\r\n     * considered dark.\r\n\r\n     * @param background Value returned when the {@code max_dark_fraction}\r\n\r\n     * threshold is exceeded.\r\n\r\n     * @param shared_sphere Whether the sphere can be shared among the\r\n\r\n     * interpolating function instances.  If {@code true}, the instances\r\n\r\n     * will share the same data, and thus will <em>not</em> be thread-safe.\r\n\r\n     * @param no_interpolation_tolerance When the distance between an\r\n\r\n     * interpolated point and one of the sample points is less than this\r\n\r\n     * value, no interpolation will be performed (the value of the sample\r\n\r\n     * will be returned).\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code dimension <= 0} or {@code elements <= 0}.\r\n\r\n     * @ if {@code exponent < 0}.\r\n\r\n     * @ if {@code dark_threshold < 0}.\r\n\r\n     * @org.hipparchus.exception. if\r\n\r\n     * {@code max_dark_fraction} does not belong to the interval {@code [0, 1]}.\r\n\r\n     */\r\n\r\n    public Microsphere_Projection_Interpolator(const int& dimension, int elements, double max_dark_fraction, double dark_threshold, double background, double exponent, bool shared_sphere, double no_interpolation_tolerance) \r\n\r\n    {\r\n\r\n        this(new Interpolating_Microsphere(dimension, elements, max_dark_fraction, dark_threshold, background, UnitSphereRandom_Vector_Generator(dimension)), exponent, shared_sphere, no_interpolation_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a microsphere interpolator.\r\n\r\n     *\r\n\r\n     * @param microsphere Microsphere.\r\n\r\n     * @param exponent Exponent used in the power law that computes the\r\n\r\n     * weights (distance dimming factor) of the sample data.\r\n\r\n     * @param shared_sphere Whether the sphere can be shared among the\r\n\r\n     * interpolating function instances.  If {@code true}, the instances\r\n\r\n     * will share the same data, and thus will <em>not</em> be thread-safe.\r\n\r\n     * @param no_interpolation_tolerance When the distance between an\r\n\r\n     * interpolated point and one of the sample points is less than this\r\n\r\n     * value, no interpolation will be performed (the value of the sample\r\n\r\n     * will be returned).\r\n\r\n     * @ if {@code exponent < 0}.\r\n\r\n     */\r\n\r\n    public Microsphere_Projection_Interpolator(Interpolating_Microsphere microsphere, double exponent, bool shared_sphere, double no_interpolation_tolerance)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (exponent < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, exponent, 0);\r\n\r\n        }\r\n\r\n\r\n\r\n        this.microsphere = microsphere;\r\n\r\n        this.exponent = exponent;\r\n\r\n        this.shared_sphere = shared_sphere;\r\n\r\n        this.no_interpolation_tolerance = no_interpolation_tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if the space dimension of the\r\n\r\n     * given samples does not match the space dimension of the microsphere.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public Multivariate_Function interpolate(const std::vector<std::vector<double>> xval, const std::vector<double> yval)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (xval == null ||\r\n\r\n            yval == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        if (xval.size() == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NO_DATA);\r\n\r\n        }\r\n\r\n        if (xval.size() != yval.size()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, xval.size(), yval.size());\r\n\r\n        }\r\n\r\n        if (xval[0] == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        const int dimension = microsphere.get_dimension();\r\n\r\n        if (dimension != xval[0].size()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, xval[0].size(), dimension);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Microsphere copy.\r\n\r\n        const Interpolating_Microsphere m = shared_sphere ? microsphere : microsphere.copy();\r\n\r\n\r\n\r\n        return Multivariate_Function() \r\n\r\n        {\r\n\r\n            /** {inherit_doc} */\r\n\r\n            //override\r\n\r\n            public double value(std::vector<double> point) \r\n\r\n            {\r\n\r\n                return m.value(point, xval, yval, exponent, no_interpolation_tolerance);\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n