/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.interpolation;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_Function_Lagrange_Form;\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_FunctionNewtonForm;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n\r\n\r\n/**\r\n\r\n * Implements the <a href=\r\n\r\n * "http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html">\r\n\r\n * Divided Difference Algorithm</a> for interpolation of real univariate\r\n\r\n * functions. For reference, see <b>Introduction to Numerical Analysis</b>, * ISBN 038795452X, chapter 2.\r\n\r\n * <p>\r\n\r\n * The actual code of Neville's evaluation is in Polynomial_Function_Lagrange_Form, * this class provides an easy-to-use interface to it.</p>\r\n\r\n *\r\n\r\n */\r\n\r\nclass Divided_Difference_Interpolator\r\n\r\n    : Univariate_Interpolator\r\n\r\n    {\r\n\r\n    /** serializable version identifier */\r\n\r\n    private static const long serial_version_uid = 107049519551235069L;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute an interpolating function for the dataset.\r\n\r\n     *\r\n\r\n     * @param x Interpolating points array.\r\n\r\n     * @param y Interpolating values array.\r\n\r\n     * @return a function which interpolates the dataset.\r\n\r\n     * @ if the array lengths are different.\r\n\r\n     * @ if the number of points is less than 2.\r\n\r\n     * @ if {@code x} is not sorted in\r\n\r\n     * strictly increasing order.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public Polynomial_FunctionNewtonForm interpolate(const std::vector<double>& x, const std::vector<double>& y)\r\n\r\n         \r\n\r\n        {\r\n\r\n        /**\r\n\r\n         * a[] and c[] are defined in the general formula of Newton form:\r\n\r\n         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\r\n\r\n         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\r\n\r\n         */\r\n\r\n        Polynomial_Function_Lagrange_Form.verify_interpolation_array(x, y, true);\r\n\r\n\r\n\r\n        /**\r\n\r\n         * When used for interpolation, the Newton form formula becomes\r\n\r\n         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\r\n\r\n         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\r\n\r\n         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\r\n\r\n         * <p>\r\n\r\n         * Note x[], y[], a[] have the same length but c[]'s size is one less.</p>\r\n\r\n         */\r\n\r\n        const std::vector<double> c = std::vector<double>(x.size()-1];\r\n\r\n        System.arraycopy(x, 0, c, 0, c.size());\r\n\r\n\r\n\r\n        const std::vector<double> a = compute_divided_difference(x, y);\r\n\r\n        return Polynomial_FunctionNewtonForm(a, c);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return a copy of the divided difference array.\r\n\r\n     * <p>\r\n\r\n     * The divided difference array is defined recursively by <pre>\r\n\r\n     * f[x0] = f(x0)\r\n\r\n     * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)\r\n\r\n     * </pre>\r\n\r\n     * <p>\r\n\r\n     * The computational complexity is \\(O(n^2)\\) where \\(n\\) is the common\r\n\r\n     * length of {@code x} and {@code y}.</p>\r\n\r\n     *\r\n\r\n     * @param x Interpolating points array.\r\n\r\n     * @param y Interpolating values array.\r\n\r\n     * @return a fresh copy of the divided difference array.\r\n\r\n     * @ if the array lengths are different.\r\n\r\n     * @ if the number of points is less than 2.\r\n\r\n     * @\r\n\r\n     * if {@code x} is not sorted in strictly increasing order.\r\n\r\n     */\r\n\r\n    protected static std::vector<double> compute_divided_difference(const std::vector<double>& x, const std::vector<double>& y)\r\n\r\n         \r\n\r\n        {\r\n\r\n        Polynomial_Function_Lagrange_Form.verify_interpolation_array(x, y, true);\r\n\r\n\r\n\r\n        const std::vector<double> divdiff = y.clone(); // initialization\r\n\r\n\r\n\r\n        const int n = x.size();\r\n\r\n        const std::vector<double> a = double [n];\r\n\r\n        a[0] = divdiff[0];\r\n\r\n        for (int i{ 1 }; i < n; i++) \r\n\r\n        {\r\n\r\n            for (int j{}; j < n-i; j++) \r\n\r\n            {\r\n\r\n                const double denominator = x[j+i] - x[j];\r\n\r\n                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\r\n\r\n            }\r\n\r\n            a[i] = divdiff[0];\r\n\r\n        }\r\n\r\n\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n