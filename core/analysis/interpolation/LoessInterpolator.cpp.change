/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n#include <cmath>\r\n\r\n//import java.io.Serializable;\r\n\r\n//import java.util.Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_Spline_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Implements the <a href="http://en.wikipedia.org/wiki/Local_regression">\r\n\r\n * Local Regression Algorithm</a> (also Loess, Lowess) for interpolation of\r\n\r\n * real univariate functions.\r\n\r\n * <p>\r\n\r\n * For reference, see\r\n\r\n * <a href="http://amstat.tandfonline.com/doi/abs/10.1080/01621459.1979.10481038">\r\n\r\n * William S. Cleveland - Robust Locally Weighted Regression and Smoothing\r\n\r\n * Scatterplots</a></p>\r\n\r\n * <p>\r\n\r\n * This class : both the loess method and serves as an interpolation\r\n\r\n * adapter to it, allowing one to build a spline on the obtained loess fit.</p>\r\n\r\n *\r\n\r\n */\r\n\r\nclass Loess_Interpolator\r\n\r\n    : Univariate_Interpolator\r\n\r\n    {\r\n\r\n    /** Default value of the bandwidth parameter. */\r\n\r\n    public static const double DEFAULT_BANDWIDTH = 0.3;\r\n\r\n    /** Default value of the number of robustness iterations. */\r\n\r\n    public static const int DEFAULT_ROBUSTNESS_ITERS = 2;\r\n\r\n    /**\r\n\r\n     * Default value for accuracy.\r\n\r\n     */\r\n\r\n    public static const double DEFAULT_ACCURACY = 1e-12;\r\n\r\n    /** serializable version identifier. */\r\n\r\n    private static const long serial_version_uid = 5204927143605193821L;\r\n\r\n    /**\r\n\r\n     * The bandwidth parameter: when computing the loess fit at\r\n\r\n     * a particular point, this fraction of source points closest\r\n\r\n     * to the current point is taken into account for computing\r\n\r\n     * a least-squares regression.\r\n\r\n     * <p>\r\n\r\n     * A sensible value is usually 0.25 to 0.5.</p>\r\n\r\n     */\r\n\r\n    private const double bandwidth;\r\n\r\n    /**\r\n\r\n     * The number of robustness iterations parameter: this many\r\n\r\n     * robustness iterations are done.\r\n\r\n     * <p>\r\n\r\n     * A sensible value is usually 0 (just the initial fit without any\r\n\r\n     * robustness iterations) to 4.</p>\r\n\r\n     */\r\n\r\n    private const int robustness_iters;\r\n\r\n    /**\r\n\r\n     * If the median residual at a certain robustness iteration\r\n\r\n     * is less than this amount, no more iterations are done.\r\n\r\n     */\r\n\r\n    private const double& accuracy;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Constructs a {@link Loess_Interpolator}\r\n\r\n     * with a bandwidth of {@link #DEFAULT_BANDWIDTH}, * {@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations\r\n\r\n     * and an accuracy of {#link #DEFAULT_ACCURACY}.\r\n\r\n     * See {@link #Loess_Interpolator(double, int, double)} for an explanation of\r\n\r\n     * the parameters.\r\n\r\n     */\r\n\r\n    public Loess_Interpolator() \r\n\r\n    {\r\n\r\n        this.bandwidth = DEFAULT_BANDWIDTH;\r\n\r\n        this.robustness_iters = DEFAULT_ROBUSTNESS_ITERS;\r\n\r\n        this.accuracy = DEFAULT_ACCURACY;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a {@link Loess_Interpolator}\r\n\r\n     * with given bandwidth and number of robustness iterations.\r\n\r\n     * <p>\r\n\r\n     * Calling this constructor is equivalent to calling {link {@link\r\n\r\n     * #Loess_Interpolator(double, int, double) Loess_Interpolator(bandwidth, * robustness_iters, Loess_Interpolator.DEFAULT_ACCURACY)}\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param bandwidth  when computing the loess fit at\r\n\r\n     * a particular point, this fraction of source points closest\r\n\r\n     * to the current point is taken into account for computing\r\n\r\n     * a least-squares regression.\r\n\r\n     * A sensible value is usually 0.25 to 0.5, the default value is\r\n\r\n     * {@link #DEFAULT_BANDWIDTH}.\r\n\r\n     * @param robustness_iters This many robustness iterations are done.\r\n\r\n     * A sensible value is usually 0 (just the initial fit without any\r\n\r\n     * robustness iterations) to 4, the default value is\r\n\r\n     * {@link #DEFAULT_ROBUSTNESS_ITERS}.\r\n\r\n\r\n\r\n     * @see #Loess_Interpolator(double, int, double)\r\n\r\n     */\r\n\r\n    public Loess_Interpolator(double bandwidth, int robustness_iters) \r\n\r\n    {\r\n\r\n        this(bandwidth, robustness_iters, DEFAULT_ACCURACY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a {@link Loess_Interpolator}\r\n\r\n     * with given bandwidth, number of robustness iterations and accuracy.\r\n\r\n     *\r\n\r\n     * @param bandwidth  when computing the loess fit at\r\n\r\n     * a particular point, this fraction of source points closest\r\n\r\n     * to the current point is taken into account for computing\r\n\r\n     * a least-squares regression.\r\n\r\n     * A sensible value is usually 0.25 to 0.5, the default value is\r\n\r\n     * {@link #DEFAULT_BANDWIDTH}.\r\n\r\n     * @param robustness_iters This many robustness iterations are done.\r\n\r\n     * A sensible value is usually 0 (just the initial fit without any\r\n\r\n     * robustness iterations) to 4, the default value is\r\n\r\n     * {@link #DEFAULT_ROBUSTNESS_ITERS}.\r\n\r\n     * @param accuracy If the median residual at a certain robustness iteration\r\n\r\n     * is less than this amount, no more iterations are done.\r\n\r\n     * @ if bandwidth does not lie in the interval [0,1].\r\n\r\n     * @ if {@code robustness_iters} is negative.\r\n\r\n     * @see #Loess_Interpolator(double, int)\r\n\r\n     */\r\n\r\n    public Loess_Interpolator(double bandwidth, int robustness_iters, double accuracy)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (bandwidth < 0 ||\r\n\r\n            bandwidth > 1) \r\n\r\n            {\r\n\r\n            throw (Localized_Core_Formats.BANDWIDTH, bandwidth, 0, 1);\r\n\r\n        }\r\n\r\n        this.bandwidth = bandwidth;\r\n\r\n        if (robustness_iters < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.ROBUSTNESS_ITERATIONS, robustness_iters);\r\n\r\n        }\r\n\r\n        this.robustness_iters = robustness_iters;\r\n\r\n        this.accuracy = accuracy;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute an interpolating function by performing a loess fit\r\n\r\n     * on the data at the original abscissae and then building a cubic spline\r\n\r\n     * with a\r\n\r\n     * {@link org.hipparchus.analysis.interpolation.Spline_Interpolator}\r\n\r\n     * on the resulting fit.\r\n\r\n     *\r\n\r\n     * @param xval the arguments for the interpolation points\r\n\r\n     * @param yval the values for the interpolation points\r\n\r\n     * @return A cubic spline built upon a loess fit to the data at the original abscissae\r\n\r\n     * @ if {@code xval} not sorted in\r\n\r\n     * strictly increasing order.\r\n\r\n     * @ if {@code xval} and {@code yval} have\r\n\r\n     * different sizes.\r\n\r\n     * @ if {@code xval} or {@code yval} has zero size.\r\n\r\n     * @ if any of the arguments and values are\r\n\r\n     * not finite real numbers.\r\n\r\n     * @ if the bandwidth is too small to\r\n\r\n     * accomodate the size of the input data (i.e. the bandwidth must be\r\n\r\n     * larger than 2/n).\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public const Polynomial_Spline_Function interpolate(const std::vector<double>& xval, const std::vector<double> yval)\r\n\r\n         \r\n\r\n        {\r\n\r\n        return Spline_Interpolator().interpolate(xval, smooth(xval, yval));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a weighted loess fit on the data at the original abscissae.\r\n\r\n     *\r\n\r\n     * @param xval Arguments for the interpolation points.\r\n\r\n     * @param yval Values for the interpolation points.\r\n\r\n     * @param weights point weights: coefficients by which the robustness weight\r\n\r\n     * of a point is multiplied.\r\n\r\n     * @return the values of the loess fit at corresponding original abscissae.\r\n\r\n     * @ if {@code xval} not sorted in\r\n\r\n     * strictly increasing order.\r\n\r\n     * @ if {@code xval} and {@code yval} have\r\n\r\n     * different sizes.\r\n\r\n     * @ if {@code xval} or {@code yval} has zero size.\r\n\r\n     * @ if any of the arguments and values are\r\n\r\n     not finite real numbers.\r\n\r\n     * @ if the bandwidth is too small to\r\n\r\n     * accomodate the size of the input data (i.e. the bandwidth must be\r\n\r\n     * larger than 2/n).\r\n\r\n     */\r\n\r\n    public const std::vector<double> smooth(const std::vector<double>& xval, const std::vector<double>& yval, const std::vector<double> weights)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (xval.size() != yval.size()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, xval.size(), yval.size());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int n = xval.size();\r\n\r\n\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NO_DATA);\r\n\r\n        }\r\n\r\n\r\n\r\n        check_all_finite_real(xval);\r\n\r\n        check_all_finite_real(yval);\r\n\r\n        check_all_finite_real(weights);\r\n\r\n\r\n\r\n        Math_Arrays::check_order(xval);\r\n\r\n\r\n\r\n        if (n == 1) \r\n\r\n        {\r\n\r\n            return std::vector<double>(]{yval[0]};\r\n\r\n        }\r\n\r\n\r\n\r\n        if (n == 2) \r\n\r\n        {\r\n\r\n            return std::vector<double>(]{yval[0], yval[1]};\r\n\r\n        }\r\n\r\n\r\n\r\n        int bandwidth_in_points = static_cast<int>( (bandwidth * n);\r\n\r\n\r\n\r\n        if (bandwidth_in_points < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.BANDWIDTH, bandwidth_in_points, 2, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<double> res = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> residuals = std::vector<double>(n];\r\n\r\n        const std::vector<double> sorted_residuals = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> robustness_weights = std::vector<double>(n];\r\n\r\n\r\n\r\n        // Do an initial fit and 'robustness_iters' robustness iterations.\r\n\r\n        // This is equivalent to doing 'robustness_iters+1' robustness iterations\r\n\r\n        // starting with all robustness weights set to 1.\r\n\r\n        Arrays.fill(robustness_weights, 1);\r\n\r\n\r\n\r\n        for (const int& iter = 0; iter <= robustness_iters; ++iter) \r\n\r\n        {\r\n\r\n            const std::vector<int> bandwidth_interval = {0, bandwidth_in_points - 1};\r\n\r\n            // At each x, compute a local weighted linear regression\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                const double x = xval[i];\r\n\r\n\r\n\r\n                // Find out the interval of source points on which\r\n\r\n                // a regression is to be made.\r\n\r\n                if (i > 0) \r\n\r\n                {\r\n\r\n                    update_bandwidth_interval(xval, weights, i, bandwidth_interval);\r\n\r\n                }\r\n\r\n\r\n\r\n                const int ileft = bandwidth_interval[0];\r\n\r\n                const int iright = bandwidth_interval[1];\r\n\r\n\r\n\r\n                // Compute the point of the bandwidth interval that is\r\n\r\n                // farthest from x\r\n\r\n                const int edge;\r\n\r\n                if (xval[i] - xval[ileft] > xval[iright] - xval[i]) \r\n\r\n                {\r\n\r\n                    edge = ileft;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    edge = iright;\r\n\r\n                }\r\n\r\n\r\n\r\n                // Compute a least-squares linear fit weighted by\r\n\r\n                // the product of robustness weights and the tricube\r\n\r\n                // weight function.\r\n\r\n                // See http://en.wikipedia.org/wiki/Linear_regression\r\n\r\n                // (section "Univariate linear case")\r\n\r\n                // and http://en.wikipedia.org/wiki/Weighted_least_squares\r\n\r\n                // (section "Weighted least squares")\r\n\r\n                double sum_weights = 0;\r\n\r\n                double sum_xx = 0;\r\n\r\n                double sum_xx_squared = 0;\r\n\r\n                double sum_y = 0;\r\n\r\n                double sum_xy = 0;\r\n\r\n                double denom = std::abs(1.0 / (xval[edge] - x));\r\n\r\n                for (int k = ileft; k <= iright; ++k) \r\n\r\n                {\r\n\r\n                    const double xk   = xval[k];\r\n\r\n                    const double yk   = yval[k];\r\n\r\n                    const double dist = (k < i) ? x - xk : xk - x;\r\n\r\n                    const double w    = tricube(dist * denom) * robustness_weights[k] * weights[k];\r\n\r\n                    const double xkw  = xk * w;\r\n\r\n                    sum_weights += w;\r\n\r\n                    sum_xx += xkw;\r\n\r\n                    sum_xx_squared += xk * xkw;\r\n\r\n                    sum_y += yk * w;\r\n\r\n                    sum_xy += yk * xkw;\r\n\r\n                }\r\n\r\n\r\n\r\n                const double mean_x = sum_xx / sum_weights;\r\n\r\n                const double mean_y = sum_y / sum_weights;\r\n\r\n                const double mean_x_y = sum_xy / sum_weights;\r\n\r\n                const double mean_x_squared = sum_xx_squared / sum_weights;\r\n\r\n\r\n\r\n                const double beta;\r\n\r\n                if (std::sqrt(std::abs(mean_x_squared - mean_x * mean_x)) < accuracy) \r\n\r\n                {\r\n\r\n                    beta = 0;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    beta = (mean_x_y - mean_x * mean_y) / (mean_x_squared - mean_x * mean_x);\r\n\r\n                }\r\n\r\n\r\n\r\n                const double& alpha = mean_y - beta * mean_x;\r\n\r\n\r\n\r\n                res[i] = beta * x + alpha;\r\n\r\n                residuals[i] = std::abs(yval[i] - res[i]);\r\n\r\n            }\r\n\r\n\r\n\r\n            // No need to recompute the robustness weights at the last\r\n\r\n            // iteration, they won't be needed anymore\r\n\r\n            if (iter == robustness_iters) \r\n\r\n            {\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Recompute the robustness weights.\r\n\r\n\r\n\r\n            // Find the median residual.\r\n\r\n            // An arraycopy and a sort are completely tractable here, // because the preceding loop is a lot more expensive\r\n\r\n            System.arraycopy(residuals, 0, sorted_residuals, 0, n);\r\n\r\n            Arrays.sort(sorted_residuals);\r\n\r\n            const double median_residual = sorted_residuals[n / 2];\r\n\r\n\r\n\r\n            if (std::abs(median_residual) < accuracy) \r\n\r\n            {\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                const double& arg = residuals[i] / (6 * median_residual);\r\n\r\n                if (arg >= 1) \r\n\r\n                {\r\n\r\n                    robustness_weights[i] = 0;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    const double w = 1 - arg * arg;\r\n\r\n                    robustness_weights[i] = w * w;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a loess fit on the data at the original abscissae.\r\n\r\n     *\r\n\r\n     * @param xval the arguments for the interpolation points\r\n\r\n     * @param yval the values for the interpolation points\r\n\r\n     * @return values of the loess fit at corresponding original abscissae\r\n\r\n     * @ if {@code xval} not sorted in\r\n\r\n     * strictly increasing order.\r\n\r\n     * @ if {@code xval} and {@code yval} have\r\n\r\n     * different sizes.\r\n\r\n     * @ if {@code xval} or {@code yval} has zero size.\r\n\r\n     * @ if any of the arguments and values are\r\n\r\n     * not finite real numbers.\r\n\r\n     * @ if the bandwidth is too small to\r\n\r\n     * accomodate the size of the input data (i.e. the bandwidth must be\r\n\r\n     * larger than 2/n).\r\n\r\n     */\r\n\r\n    public const std::vector<double> smooth(const std::vector<double>& xval, const std::vector<double> yval)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (xval.size() != yval.size()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, xval.size(), yval.size());\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<double> unit_weights = std::vector<double>(xval.size()];\r\n\r\n        Arrays.fill(unit_weights, 1.0);\r\n\r\n\r\n\r\n        return smooth(xval, yval, unit_weights);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Given an index interval into xval that embraces a certain number of\r\n\r\n     * points closest to {@code xval[i-1]}, update the interval so that it\r\n\r\n     * embraces the same number of points closest to {@code xval[i]}, * ignoring zero weights.\r\n\r\n     *\r\n\r\n     * @param xval Arguments array.\r\n\r\n     * @param weights Weights array.\r\n\r\n     * @param i Index around which the interval should be computed.\r\n\r\n     * @param bandwidth_interval a two-element array {left, right} such that:\r\n\r\n     * {@code (left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])}\r\n\r\n     * and\r\n\r\n     * {@code (right==xval.size()-1 or xval[right+1] - xval[i] > xval[i] - xval[left])}.\r\n\r\n     * The array will be updated.\r\n\r\n     */\r\n\r\n    private static void update_bandwidth_interval(const std::vector<double>& xval, const std::vector<double> weights, const int i, const std::vector<int> bandwidth_interval) \r\n\r\n    {\r\n\r\n        const int left = bandwidth_interval[0];\r\n\r\n        const int right = bandwidth_interval[1];\r\n\r\n\r\n\r\n        // The right edge should be adjusted if the next point to the right\r\n\r\n        // is closer to xval[i] than the leftmost point of the current interval\r\n\r\n        int next_right = next_nonzero(weights, right);\r\n\r\n        if (next_right < xval.size() && xval[next_right] - xval[i] < xval[i] - xval[left]) \r\n\r\n        {\r\n\r\n            int next_left = next_nonzero(weights, bandwidth_interval[0]);\r\n\r\n            bandwidth_interval[0] = next_left;\r\n\r\n            bandwidth_interval[1] = next_right;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the smallest index {@code j} such that\r\n\r\n     * {@code j > i && (j == weights.size() || weights[j] != 0)}.\r\n\r\n     *\r\n\r\n     * @param weights Weights array.\r\n\r\n     * @param i Index from which to start search.\r\n\r\n     * @return the smallest compliant index.\r\n\r\n     */\r\n\r\n    private static int next_nonzero(const std::vector<double> weights, const int i) \r\n\r\n    {\r\n\r\n        int j = i + 1;\r\n\r\n        while(j < weights.size() && weights[j] == 0) \r\n\r\n        {\r\n\r\n            ++j;\r\n\r\n        }\r\n\r\n        return j;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://en.wikipedia.org/wiki/Local_regression#Weight_function">tricube</a>\r\n\r\n     * weight function\r\n\r\n     *\r\n\r\n     * @param x Argument.\r\n\r\n     * @return <code>(1 - |x|<sup>3</sup>)<sup>3</sup></code> for |x| &lt; 1, 0 otherwise.\r\n\r\n     */\r\n\r\n    private static double tricube(const double& x) \r\n\r\n    {\r\n\r\n        const double& abs_x = std::abs(x);\r\n\r\n        if (abs_x >= 1.0) \r\n\r\n        {\r\n\r\n            return 0.0;\r\n\r\n        }\r\n\r\n        const double tmp = 1 - abs_x * abs_x * abs_x;\r\n\r\n        return tmp * tmp * tmp;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that all elements of an array are finite real numbers.\r\n\r\n     *\r\n\r\n     * @param values Values array.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if one of the values is not a finite real number.\r\n\r\n     */\r\n\r\n    private static void check_all_finite_real(const std::vector<double>& values) \r\n\r\n    {\r\n\r\n        for (int i{}; i < values.size(); i++) \r\n\r\n        {\r\n\r\n            Math_Utils::check_finite(values[i]);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n