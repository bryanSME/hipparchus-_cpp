/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the <a href="http://mathworld.wolfram.com/Brents_method.html">\r\n\r\n * Brent algorithm</a> for finding zeros of real univariate functions.\r\n\r\n * The function should be continuous but not necessarily smooth.\r\n\r\n * The {@code solve} method returns a zero {@code x} of the function {@code f}\r\n\r\n * in the given interval {@code [a, b]} to within a tolerance\r\n\r\n * {@code 2 eps abs(x) + t} where {@code eps} is the relative accuracy and\r\n\r\n * {@code t} is the absolute accuracy.\r\n\r\n * <p>The given interval must bracket the root.</p>\r\n\r\n * <p>\r\n\r\n *  The reference implementation is given in chapter 4 of\r\n\r\n *  <blockquote>\r\n\r\n *   <b>Algorithms for Minimization Without Derivatives</b>, *   <em>Richard P. Brent</em>, *   Dover, 2002\r\n\r\n *  </blockquote>\r\n\r\n *\r\n\r\n * @see BaseAbstract_Univariate_Solver\r\n\r\n */\r\n\r\nclass Brent_Solver extends Abstract_Univariate_Solver \r\n\r\n{\r\n\r\n\r\n\r\n    /** Default absolute accuracy. */\r\n\r\n    private static const double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver with default absolute accuracy (1e-6).\r\n\r\n     */\r\n\r\n    public Brent_Solver() \r\n\r\n    {\r\n\r\n        this(DEFAULT_ABSOLUTE_ACCURACY);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Brent_Solver(double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Brent_Solver(double relative_accuracy, double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param function_value_accuracy Function value accuracy.\r\n\r\n     *\r\n\r\n     * @see BaseAbstract_Univariate_Solver#BaseAbstract_Univariate_Solver(double,double,double)\r\n\r\n     */\r\n\r\n    public Brent_Solver(double relative_accuracy, double absolute_accuracy, double function_value_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy, function_value_accuracy);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    protected double do_solve()\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        double min = get_min();\r\n\r\n        double max = get_max();\r\n\r\n        const double initial = get_start_value();\r\n\r\n        const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n        verify_sequence(min, initial, max);\r\n\r\n\r\n\r\n        // Return the initial guess if it is good enough.\r\n\r\n        double y_initial = compute_objective_value(initial);\r\n\r\n        if (std::abs(y_initial) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return initial;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Return the first endpoint if it is good enough.\r\n\r\n        double y_min = compute_objective_value(min);\r\n\r\n        if (std::abs(y_min) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return min;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Reduce interval if min and initial bracket the root.\r\n\r\n        if (y_initial * y_min < 0) \r\n\r\n        {\r\n\r\n            return brent(min, initial, y_min, y_initial);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Return the second endpoint if it is good enough.\r\n\r\n        double y_max = compute_objective_value(max);\r\n\r\n        if (std::abs(y_max) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return max;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Reduce interval if initial and max bracket the root.\r\n\r\n        if (y_initial * y_max < 0) \r\n\r\n        {\r\n\r\n            return brent(initial, max, y_initial, y_max);\r\n\r\n        }\r\n\r\n\r\n\r\n        throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, min, max, y_min, y_max);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Search for a zero inside the provided interval.\r\n\r\n     * This implementation is based on the algorithm described at page 58 of\r\n\r\n     * the book\r\n\r\n     * <blockquote>\r\n\r\n     *  <b>Algorithms for Minimization Without Derivatives</b>, *  <it>Richard P. Brent</it>, *  Dover 0-486-41998-3\r\n\r\n     * </blockquote>\r\n\r\n     *\r\n\r\n     * @param lo Lower bound of the search interval.\r\n\r\n     * @param hi Higher bound of the search interval.\r\n\r\n     * @param f_lo Function value at the lower bound of the search interval.\r\n\r\n     * @param f_hi Function value at the higher bound of the search interval.\r\n\r\n     * @return the value where the function is zero.\r\n\r\n     */\r\n\r\n    private double brent(const double& lo, double hi, double f_lo, double f_hi) \r\n\r\n    {\r\n\r\n        double a = lo;\r\n\r\n        double fa = f_lo;\r\n\r\n        double b = hi;\r\n\r\n        double fb = f_hi;\r\n\r\n        double c = a;\r\n\r\n        double fc = fa;\r\n\r\n        double d = b - a;\r\n\r\n        double e = d;\r\n\r\n\r\n\r\n        const double t = get_absolute_accuracy();\r\n\r\n        const double eps = get_relative_accuracy();\r\n\r\n\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n            if (std::abs(fc) < std::abs(fb)) \r\n\r\n            {\r\n\r\n                a = b;\r\n\r\n                b = c;\r\n\r\n                c = a;\r\n\r\n                fa = fb;\r\n\r\n                fb = fc;\r\n\r\n                fc = fa;\r\n\r\n            }\r\n\r\n\r\n\r\n            const double tol = 2 * eps * std::abs(b) + t;\r\n\r\n            const double m = 0.5 * (c - b);\r\n\r\n\r\n\r\n            if (std::abs(m) <= tol ||\r\n\r\n                Precision.equals(fb, 0))  \r\n\r\n                {\r\n\r\n                return b;\r\n\r\n            }\r\n\r\n            if (std::abs(e) < tol ||\r\n\r\n                std::abs(fa) <= std::abs(fb)) \r\n\r\n                {\r\n\r\n                // Force bisection.\r\n\r\n                d = m;\r\n\r\n                e = d;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                double s = fb / fa;\r\n\r\n                double p;\r\n\r\n                double q;\r\n\r\n                // The equality test (a == c) is intentional, // it is part of the original Brent's method and\r\n\r\n                // it should NOT be replaced by proximity test.\r\n\r\n                if (a == c) \r\n\r\n                {\r\n\r\n                    // Linear interpolation.\r\n\r\n                    p = 2 * m * s;\r\n\r\n                    q = 1 - s;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    // Inverse quadratic interpolation.\r\n\r\n                    q = fa / fc;\r\n\r\n                    const double r = fb / fc;\r\n\r\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\r\n\r\n                    q = (q - 1) * (r - 1) * (s - 1);\r\n\r\n                }\r\n\r\n                if (p > 0) \r\n\r\n                {\r\n\r\n                    q = -q;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    p = -p;\r\n\r\n                }\r\n\r\n                s = e;\r\n\r\n                e = d;\r\n\r\n                if (p >= 1.5 * m * q - std::abs(tol * q) ||\r\n\r\n                    p >= std::abs(0.5 * s * q)) \r\n\r\n                    {\r\n\r\n                    // Inverse quadratic interpolation gives a value\r\n\r\n                    // in the wrong direction, or progress is slow.\r\n\r\n                    // Fall back to bisection.\r\n\r\n                    d = m;\r\n\r\n                    e = d;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    d = p / q;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            a = b;\r\n\r\n            fa = fb;\r\n\r\n\r\n\r\n            if (std::abs(d) > tol) \r\n\r\n            {\r\n\r\n                b += d;\r\n\r\n            }\r\n\r\nelse if (m > 0) \r\n\r\n            {\r\n\r\n                b += tol;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                b -= tol;\r\n\r\n            }\r\n\r\n            fb = compute_objective_value(b);\r\n\r\n            if ((fb > 0 && fc > 0) ||\r\n\r\n                (fb <= 0 && fc <= 0)) \r\n\r\n                {\r\n\r\n                c = a;\r\n\r\n                fc = fa;\r\n\r\n                d = b - a;\r\n\r\n                e = d;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n