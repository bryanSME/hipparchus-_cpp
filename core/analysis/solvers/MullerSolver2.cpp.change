/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the <a href="http://mathworld.wolfram.com/Mullers_method.html">\r\n\r\n * Muller's Method</a> for root finding of real univariate functions. For\r\n\r\n * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477, * chapter 3.\r\n\r\n * <p>\r\n\r\n * Muller's method applies to both real and complex functions, but here we\r\n\r\n * restrict ourselves to real functions.\r\n\r\n * This class differs from {@link Muller_Solver} in the way it avoids complex\r\n\r\n * operations.</p><p>\r\n\r\n * Except for the initial [min, max], it does not require bracketing\r\n\r\n * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If a complex\r\n\r\n * number arises in the computation, we simply use its modulus as a real\r\n\r\n * approximation.</p>\r\n\r\n * <p>\r\n\r\n * Because the interval may not be bracketing, the bisection alternative is\r\n\r\n * not applicable here. However in practice our treatment usually works\r\n\r\n * well, especially near real zeroes where the imaginary part of the complex\r\n\r\n * approximation is often negligible.</p>\r\n\r\n * <p>\r\n\r\n * The formulas here do not use divided differences directly.</p>\r\n\r\n *\r\n\r\n * @see Muller_Solver\r\n\r\n */\r\n\r\nclass Muller_Solver2 extends Abstract_Univariate_Solver \r\n\r\n{\r\n\r\n\r\n\r\n    /** Default absolute accuracy. */\r\n\r\n    private static const double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver with default accuracy (1e-6).\r\n\r\n     */\r\n\r\n    public Muller_Solver2() \r\n\r\n    {\r\n\r\n        this(DEFAULT_ABSOLUTE_ACCURACY);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Muller_Solver2(double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Muller_Solver2(double relative_accuracy, double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    protected double do_solve()\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        const double min = get_min();\r\n\r\n        const double max = get_max();\r\n\r\n\r\n\r\n        verify_interval(min, max);\r\n\r\n\r\n\r\n        const double relative_accuracy = get_relative_accuracy();\r\n\r\n        const double& absolute_accuracy = get_absolute_accuracy();\r\n\r\n        const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n        // x2 is the last root approximation\r\n\r\n        // x is the approximation and x2 for next round\r\n\r\n        // x0 < x1 < x2 does not hold here\r\n\r\n\r\n\r\n        double x0 = min;\r\n\r\n        double y0 = compute_objective_value(x0);\r\n\r\n        if (std::abs(y0) < function_value_accuracy) \r\n\r\n        {\r\n\r\n            return x0;\r\n\r\n        }\r\n\r\n        double x1 = max;\r\n\r\n        double y1 = compute_objective_value(x1);\r\n\r\n        if (std::abs(y1) < function_value_accuracy) \r\n\r\n        {\r\n\r\n            return x1;\r\n\r\n        }\r\n\r\n\r\n\r\n        if(y0 * y1 > 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, x0, x1, y0, y1);\r\n\r\n        }\r\n\r\n\r\n\r\n        double x2 = 0.5 * (x0 + x1);\r\n\r\n        double y2 = compute_objective_value(x2);\r\n\r\n\r\n\r\n        double oldx = INFINITY;\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n            // quadratic interpolation through x0, x1, x2\r\n\r\n            const double q = (x2 - x1) / (x1 - x0);\r\n\r\n            const double& a = q * (y2 - (1 + q) * y1 + q * y0);\r\n\r\n            const double b = (2 * q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\r\n\r\n            const double c = (1 + q) * y2;\r\n\r\n            const double delta = b * b - 4 * a * c;\r\n\r\n            double x;\r\n\r\n            const double denominator;\r\n\r\n            if (delta >= 0.0) \r\n\r\n            {\r\n\r\n                // choose a denominator larger in magnitude\r\n\r\n                double dplus = b + std::sqrt(delta);\r\n\r\n                double dminus = b - std::sqrt(delta);\r\n\r\n                denominator = std::abs(dplus) > std::abs(dminus) ? dplus : dminus;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // take the modulus of (B +/- std::sqrt(delta))\r\n\r\n                denominator = std::sqrt(b * b - delta);\r\n\r\n            }\r\n\r\n            if (denominator != 0) \r\n\r\n            {\r\n\r\n                x = x2 - 2.0 * c * (x2 - x1) / denominator;\r\n\r\n                // perturb x if it exactly coincides with x1 or x2\r\n\r\n                // the equality tests here are intentional\r\n\r\n                while (x == x1 || x == x2) \r\n\r\n                {\r\n\r\n                    x += absolute_accuracy;\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // extremely rare case, get a random number to skip it\r\n\r\n                x = min + FastMath.random() * (max - min);\r\n\r\n                oldx = INFINITY;\r\n\r\n            }\r\n\r\n            const double y = compute_objective_value(x);\r\n\r\n\r\n\r\n            // check for convergence\r\n\r\n            const double& tolerance = std::max(relative_accuracy * std::abs(x), absolute_accuracy);\r\n\r\n            if (std::abs(x - oldx) <= tolerance ||\r\n\r\n                std::abs(y) <= function_value_accuracy) \r\n\r\n                {\r\n\r\n                return x;\r\n\r\n            }\r\n\r\n\r\n\r\n            // prepare the next iteration\r\n\r\n            x0 = x1;\r\n\r\n            y0 = y1;\r\n\r\n            x1 = x2;\r\n\r\n            y1 = y2;\r\n\r\n            x2 = x;\r\n\r\n            y2 = y;\r\n\r\n            oldx = x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n