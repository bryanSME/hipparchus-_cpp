/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/** Interface for {@link Univariate_Solver (univariate real) root-finding\r\n\r\n * algorithms} that maintain a bracketed solution. There are several advantages\r\n\r\n * to having such root-finding algorithms:\r\n\r\n * <ul>\r\n\r\n *  <li>The bracketed solution guarantees that the root is kept within the\r\n\r\n *      interval. As such, these algorithms generally also guarantee\r\n\r\n *      convergence.</li>\r\n\r\n *  <li>The bracketed solution means that we have the opportunity to only\r\n\r\n *      return roots that are greater than or equal to the actual root, or\r\n\r\n *      are less than or equal to the actual root. That is, we can control\r\n\r\n *      whether under-approximations and over-approximations are\r\n\r\n *      {@link Allowed_Solution allowed solutions}. Other root-finding\r\n\r\n *      algorithms can usually only guarantee that the solution (the root that\r\n\r\n *      was found) is around the actual root.</li>\r\n\r\n * </ul>\r\n\r\n *\r\n\r\n * <p>For backwards compatibility, all root-finding algorithms must have\r\n\r\n * {@link Allowed_Solution#ANY_SIDE ANY_SIDE} as default for the allowed\r\n\r\n * solutions.</p>\r\n\r\n * @param <F> Type of function to solve.\r\n\r\n *\r\n\r\n * @see Allowed_Solution\r\n\r\n */\r\n\r\nclass Bracketed_Univariate_Solver<F extends Univariate_Function>\r\n\r\n    extends BaseUnivariate_Solver<F> \r\n\r\n    {\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return A value where the function is zero.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if the arguments do not satisfy the requirements specified by the solver.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception if\r\n\r\n     * the allowed number of evaluations is exceeded.\r\n\r\n     */\r\n\r\n    double solve(const int& max_eval, F f, const double& min,  const double& max,  Allowed_Solution allowed_solution);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval, start at {@code start_value}.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param start_value Start value to use.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return A value where the function is zero.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if the arguments do not satisfy the requirements specified by the solver.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception if\r\n\r\n     * the allowed number of evaluations is exceeded.\r\n\r\n     */\r\n\r\n    double solve(const int& max_eval, F f, const double& min,  const double& max, const double& start_value, Allowed_Solution allowed_solution);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval and return a tolerance interval surrounding\r\n\r\n     * the root.\r\n\r\n     *\r\n\r\n     * <p> It is required that the starting interval brackets a root or that the function\r\n\r\n     * value at either end point is 0.0.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f       Function to solve.\r\n\r\n     * @param min     Lower bound for the interval.\r\n\r\n     * @param max     Upper bound for the interval. Must be greater than {@code min}.\r\n\r\n     * @return an interval [ta, tb] such that for some t in [ta, tb] f(t) == 0.0 or has a\r\n\r\n     * step wise discontinuity that crosses zero. Both end points also satisfy the\r\n\r\n     * convergence criteria so either one could be used as the root. That is the interval\r\n\r\n     * satisfies the condition (| tb - ta | &lt;= {@link #get_absolute_accuracy() absolute}\r\n\r\n     * accuracy + max(ta, tb) * {@link #get_relative_accuracy() relative} accuracy) or (\r\n\r\n     * max(|f(ta)|, |f(tb)|) &lt;= {@link #get_function_value_accuracy()}) or there are no\r\n\r\n     * floating point numbers between ta and tb. The width of the interval (tb - ta) may\r\n\r\n     * be zero.\r\n\r\n     * @ if the arguments do not satisfy the\r\n\r\n     *                                      requirements specified by the solver.\r\n\r\n     * @Math_Illegal_State_Exception    if the allowed number of evaluations is\r\n\r\n     *                                      exceeded.\r\n\r\n     */\r\n\r\n    default Interval solve_interval(const int& max_eval, F f, const double& min,  double max)\r\n\r\n            , Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n        return this.solve_interval(max_eval, f, min, max, min + 0.5 * (max - min));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval and return a tolerance interval surrounding\r\n\r\n     * the root.\r\n\r\n     *\r\n\r\n     * <p> It is required that the starting interval brackets a root or that the function\r\n\r\n     * value at either end point is 0.0.\r\n\r\n     *\r\n\r\n     * @param max_eval    Maximum number of evaluations.\r\n\r\n     * @param start_value start value to use. Must be in the interval [min, max].\r\n\r\n     * @param f          Function to solve.\r\n\r\n     * @param min        Lower bound for the interval.\r\n\r\n     * @param max     Upper bound for the interval. Must be greater than {@code min}.\r\n\r\n     * @return an interval [ta, tb] such that for some t in [ta, tb] f(t) == 0.0 or has a\r\n\r\n     * step wise discontinuity that crosses zero. Both end points also satisfy the\r\n\r\n     * convergence criteria so either one could be used as the root. That is the interval\r\n\r\n     * satisfies the condition (| tb - ta | &lt;= {@link #get_absolute_accuracy() absolute}\r\n\r\n     * accuracy + max(ta, tb) * {@link #get_relative_accuracy() relative} accuracy) or (\r\n\r\n     * max(|f(ta)|, |f(tb)|) &lt;= {@link #get_function_value_accuracy()}) or there are no\r\n\r\n     * floating point numbers between ta and tb. The width of the interval (tb - ta) may\r\n\r\n     * be zero.\r\n\r\n     * @ if the arguments do not satisfy the\r\n\r\n     *                                      requirements specified by the solver.\r\n\r\n     * @Math_Illegal_State_Exception    if the allowed number of evaluations is\r\n\r\n     *                                      exceeded.\r\n\r\n     */\r\n\r\n    Interval solve_interval(const int& max_eval, F f, const double& min,  const double& max,  double start_value)\r\n\r\n            , Math_Illegal_State_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * An interval of a function that brackets a root.\r\n\r\n     *\r\n\r\n     * <p> Contains two end points and the value of the function at the two end points.\r\n\r\n     *\r\n\r\n     * @see #solve_interval(int, Univariate_Function, double, double, double)\r\n\r\n     */\r\n\r\n    class Interval \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Abscissa on the left end of the interval. */\r\n\r\n        private const double left_abscissa;\r\n\r\n        /** Function value at {@link #left_abscissa}. */\r\n\r\n        private const double left_value;\r\n\r\n        /** Abscissa on the right end of the interval, >= {@link #left_abscissa}. */\r\n\r\n        private const double right_abscissa;\r\n\r\n        /** Function value at {@link #right_abscissa}. */\r\n\r\n        private const double right_value;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Construct a interval with the given end points.\r\n\r\n         *\r\n\r\n         * @param left_abscissa  is the abscissa value at the left side of the interval.\r\n\r\n         * @param left_value     is the function value at {@code left_abscissa}.\r\n\r\n         * @param right_abscissa is the abscissa value on the right side of the interval.\r\n\r\n         *                      Must be greater than or equal to {@code left_abscissa}.\r\n\r\n         * @param right_value    is the function value at {@code right_abscissa}.\r\n\r\n         */\r\n\r\n        public Interval(const double left_abscissa, const double left_value, const double right_abscissa, const double right_value) \r\n\r\n        {\r\n\r\n            this.left_abscissa = left_abscissa;\r\n\r\n            this.left_value = left_value;\r\n\r\n            this.right_abscissa = right_abscissa;\r\n\r\n            this.right_value = right_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the left abscissa.\r\n\r\n         *\r\n\r\n         * @return abscissa of the start of the interval.\r\n\r\n         */\r\n\r\n        public double get_left_abscissa() \r\n\r\n        {\r\n\r\n            return left_abscissa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the right abscissa.\r\n\r\n         *\r\n\r\n         * @return abscissa of the end of the interval.\r\n\r\n         */\r\n\r\n        public double get_right_abscissa() \r\n\r\n        {\r\n\r\n            return right_abscissa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the function value at {@link #get_left_abscissa()}.\r\n\r\n         *\r\n\r\n         * @return value of the function at the start of the interval.\r\n\r\n         */\r\n\r\n        public double get_left_value() \r\n\r\n        {\r\n\r\n            return left_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the function value at {@link #get_right_abscissa()}.\r\n\r\n         *\r\n\r\n         * @return value of the function at the end of the interval.\r\n\r\n         */\r\n\r\n        public double get_right_value() \r\n\r\n        {\r\n\r\n            return right_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the abscissa corresponding to the allowed side.\r\n\r\n         *\r\n\r\n         * @param allowed side of the root.\r\n\r\n         * @return the abscissa on the selected side of the root.\r\n\r\n         */\r\n\r\n        public double get_side(const Allowed_Solution allowed) \r\n\r\n        {\r\n\r\n            const double x_a = this.get_left_abscissa();\r\n\r\n            const double y_a = this.get_left_value();\r\n\r\n            const double x_b = this.get_right_abscissa();\r\n\r\n            switch (allowed) \r\n\r\n            {\r\n\r\n                case ANY_SIDE:\r\n\r\n                    const double& abs_ya = std::abs(this.get_left_value());\r\n\r\n                    const double& abs_y_b = std::abs(this.get_right_value());\r\n\r\n                    return abs_ya < abs_y_b ? x_a : x_b;\r\n\r\n                case LEFT_SIDE:\r\n\r\n                    return x_a;\r\n\r\n                case RIGHT_SIDE:\r\n\r\n                    return x_b;\r\n\r\n                case BELOW_SIDE:\r\n\r\n                    return (y_a <= 0) ? x_a : x_b;\r\n\r\n                case ABOVE_SIDE:\r\n\r\n                    return (y_a < 0) ? x_b : x_a;\r\n\r\n                default:\r\n\r\n                    // this should never happen\r\n\r\n                    throw Math_Runtime_Exception.create_internal_error();\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n