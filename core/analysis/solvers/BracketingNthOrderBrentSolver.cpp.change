/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : a modification of the <a\r\n\r\n * href="http://mathworld.wolfram.com/Brents_method.html"> Brent algorithm</a>.\r\n\r\n * <p>\r\n\r\n * The changes with respect to the original Brent algorithm are:\r\n\r\n * <ul>\r\n\r\n *   <li>the returned value is chosen in the current interval according\r\n\r\n *   to user specified {@link Allowed_Solution},</li>\r\n\r\n *   <li>the maximal order for the invert polynomial root search is\r\n\r\n *   user-specified instead of being invert quadratic only</li>\r\n\r\n * </ul><p>\r\n\r\n * The given interval must bracket the root.</p>\r\n\r\n *\r\n\r\n */\r\n\r\nclass Bracketing_Nth_Order_Brent_Solver\r\n\r\n    extends Abstract_Univariate_Solver\r\n\r\n    : Bracketed_Univariate_Solver<Univariate_Function> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Default absolute accuracy. */\r\n\r\n    private static const double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\r\n\r\n\r\n\r\n    /** Default maximal order. */\r\n\r\n    private static const int DEFAULT_MAXIMAL_ORDER = 5;\r\n\r\n\r\n\r\n    /** Maximal aging triggering an attempt to balance the bracketing interval. */\r\n\r\n    private static const int MAXIMAL_AGING = 2;\r\n\r\n\r\n\r\n    /** Reduction factor for attempts to balance the bracketing interval. */\r\n\r\n    private static const double REDUCTION_FACTOR = 1.0 / 16.0;\r\n\r\n\r\n\r\n    /** Maximal order. */\r\n\r\n    private const int maximal_order;\r\n\r\n\r\n\r\n    /** The kinds of solutions that the algorithm may accept. */\r\n\r\n    private Allowed_Solution allowed;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)\r\n\r\n     */\r\n\r\n    public Bracketing_Nth_Order_Brent_Solver() \r\n\r\n    {\r\n\r\n        this(DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_MAXIMAL_ORDER);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param maximal_order maximal order.\r\n\r\n     * @exception  if maximal order is lower than 2\r\n\r\n     */\r\n\r\n    public Bracketing_Nth_Order_Brent_Solver(const double& absolute_accuracy, const int maximal_order)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(absolute_accuracy);\r\n\r\n        if (maximal_order < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, maximal_order, 2);\r\n\r\n        }\r\n\r\n        this.maximal_order = maximal_order;\r\n\r\n        this.allowed = Allowed_Solution.ANY_SIDE;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param maximal_order maximal order.\r\n\r\n     * @exception  if maximal order is lower than 2\r\n\r\n     */\r\n\r\n    public Bracketing_Nth_Order_Brent_Solver(const double relative_accuracy, const double& absolute_accuracy, const int maximal_order)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(relative_accuracy, absolute_accuracy);\r\n\r\n        if (maximal_order < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, maximal_order, 2);\r\n\r\n        }\r\n\r\n        this.maximal_order = maximal_order;\r\n\r\n        this.allowed = Allowed_Solution.ANY_SIDE;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param function_value_accuracy Function value accuracy.\r\n\r\n     * @param maximal_order maximal order.\r\n\r\n     * @exception  if maximal order is lower than 2\r\n\r\n     */\r\n\r\n    public Bracketing_Nth_Order_Brent_Solver(const double relative_accuracy, const double& absolute_accuracy, const double function_value_accuracy, const int maximal_order)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(relative_accuracy, absolute_accuracy, function_value_accuracy);\r\n\r\n        if (maximal_order < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, maximal_order, 2);\r\n\r\n        }\r\n\r\n        this.maximal_order = maximal_order;\r\n\r\n        this.allowed = Allowed_Solution.ANY_SIDE;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the maximal order.\r\n\r\n     * @return maximal order\r\n\r\n     */\r\n\r\n    public int get_maximal_order() \r\n\r\n    {\r\n\r\n        return maximal_order;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    protected double do_solve() \r\n\r\n    {\r\n\r\n        return do_solve_interval().get_side(allowed);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find a root and return the containing interval.\r\n\r\n     *\r\n\r\n     * @return an interval containing the root such that both end points meet the\r\n\r\n     * convergence criteria.\r\n\r\n     */\r\n\r\n    protected Interval do_solve_interval() \r\n\r\n    {\r\n\r\n        // prepare arrays with the first points\r\n\r\n        const std::vector<double> x = std::vector<double>(maximal_order + 1];\r\n\r\n        const std::vector<double> y = std::vector<double>(maximal_order + 1];\r\n\r\n        x[0] = get_min();\r\n\r\n        x[1] = get_start_value();\r\n\r\n        x[2] = get_max();\r\n\r\n        verify_interval(x[0], x[2]);\r\n\r\n        if (x[1] < x[0] || x[2] < x[1]) \r\n\r\n        {\r\n\r\n            throw (\r\n\r\n                    Localized_Core_Formats.START_POINT_NOT_IN_INTERVAL, x[1], x[0], x[2]);\r\n\r\n        }\r\n\r\n\r\n\r\n        // evaluate initial guess\r\n\r\n        y[1] = compute_objective_value(x[1]);\r\n\r\n        if (y[1] == 0.0) \r\n\r\n        {\r\n\r\n            // return the initial guess if it is a perfect root.\r\n\r\n            return Interval(x[1], y[1], x[1], y[1]);\r\n\r\n        }\r\n\r\n\r\n\r\n        // evaluate first  endpoint\r\n\r\n        y[0] = compute_objective_value(x[0]);\r\n\r\n        if (y[0] == 0.0) \r\n\r\n        {\r\n\r\n            // return the first endpoint if it is a perfect root.\r\n\r\n            return Interval(x[0], y[0], x[0], y[0]);\r\n\r\n        }\r\n\r\n\r\n\r\n        int nb_points;\r\n\r\n        int sign_change_index;\r\n\r\n        if (y[0] * y[1] < 0) \r\n\r\n        {\r\n\r\n\r\n\r\n            // reduce interval if it brackets the root\r\n\r\n            nb_points        = 2;\r\n\r\n            sign_change_index = 1;\r\n\r\n\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            // evaluate second endpoint\r\n\r\n            y[2] = compute_objective_value(x[2]);\r\n\r\n            if (y[2] == 0.0) \r\n\r\n            {\r\n\r\n                // return the second endpoint if it is a perfect root.\r\n\r\n                return Interval(x[2], y[2], x[2], y[2]);\r\n\r\n            }\r\n\r\n\r\n\r\n            if (y[1] * y[2] < 0) \r\n\r\n            {\r\n\r\n                // use all computed point as a start sampling array for solving\r\n\r\n                nb_points        = 3;\r\n\r\n                sign_change_index = 2;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, x[0], x[2], y[0], y[2]);\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // prepare a work array for inverse polynomial interpolation\r\n\r\n        const std::vector<double> tmp_x = std::vector<double>(x.size()];\r\n\r\n\r\n\r\n        // current tightest bracketing of the root\r\n\r\n        double x_a    = x[sign_change_index - 1];\r\n\r\n        double y_a    = y[sign_change_index - 1];\r\n\r\n        double abs_ya = std::abs(y_a);\r\n\r\n        int aging_a   = 0;\r\n\r\n        double x_b    = x[sign_change_index];\r\n\r\n        double yB    = y[sign_change_index];\r\n\r\n        double abs_y_b = std::abs(yB);\r\n\r\n        int aging_b   = 0;\r\n\r\n\r\n\r\n        // search loop\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n\r\n\r\n            // check convergence of bracketing interval\r\n\r\n            const double x_tol = get_absolute_accuracy() +\r\n\r\n                                get_relative_accuracy() * std::max(std::abs(x_a), std::abs(x_b));\r\n\r\n            if (x_b - x_a <= x_tol ||\r\n\r\n                    std::max(abs_ya, abs_y_b) < get_function_value_accuracy() ||\r\n\r\n                    Precision.equals(x_a, x_b, 1)) \r\n\r\n                    {\r\n\r\n                return Interval(x_a, y_a, x_b, yB);\r\n\r\n            }\r\n\r\n\r\n\r\n            // target for the next evaluation point\r\n\r\n            double target_y;\r\n\r\n            if (aging_a >= MAXIMAL_AGING) \r\n\r\n            {\r\n\r\n                // we keep updating the high bracket, try to compensate this\r\n\r\n                const int p{ aging_a - MAXIMAL_AGING };\r\n\r\n                const double weight_a = (1 << p) - 1;\r\n\r\n                const double weight_b = p + 1;\r\n\r\n                target_y = (weight_a * y_a - weight_b * REDUCTION_FACTOR * yB) / (weight_a + weight_b);\r\n\r\n            }\r\n\r\nelse if (aging_b >= MAXIMAL_AGING) \r\n\r\n            {\r\n\r\n                // we keep updating the low bracket, try to compensate this\r\n\r\n                const int p = aging_b - MAXIMAL_AGING;\r\n\r\n                const double weight_a{ p + 1 };\r\n\r\n                const double weight_b{ (1 << p) - 1 };\r\n\r\n                target_y = (weight_b * yB - weight_a * REDUCTION_FACTOR * y_a) / (weight_a + weight_b);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // bracketing is balanced, try to find the root itself\r\n\r\n                target_y = 0;\r\n\r\n            }\r\n\r\n\r\n\r\n            // make a few attempts to guess a root, double next_x;\r\n\r\n            int start = 0;\r\n\r\n            int end   = nb_points;\r\n\r\n            do \r\n\r\n            {\r\n\r\n\r\n\r\n                // guess a value for current target, using inverse polynomial interpolation\r\n\r\n                System.arraycopy(x, start, tmp_x, start, end - start);\r\n\r\n                next_x = guess_x(target_y, tmp_x, y, start, end);\r\n\r\n\r\n\r\n                if (!((next_x > x_a) && (next_x < x_b))) \r\n\r\n                {\r\n\r\n                    // the guessed root is not strictly inside of the tightest bracketing interval\r\n\r\n\r\n\r\n                    // the guessed root is either not strictly inside the interval or it\r\n\r\n                    // is a NaN (which occurs when some sampling points share the same y)\r\n\r\n                    // we try again with a lower interpolation order\r\n\r\n                    if (sign_change_index - start >= end - sign_change_index) \r\n\r\n                    {\r\n\r\n                        // we have more points before the sign change, drop the lowest point\r\n\r\n                        ++start;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // we have more points after sign change, drop the highest point\r\n\r\n                        --end;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    // we need to do one more attempt\r\n\r\n                    next_x = std::numeric_limits<double>::quiet_NaN();\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n            } while (std::isnan(next_x) && (end - start > 1));\r\n\r\n\r\n\r\n            if (std::isnan(next_x)) \r\n\r\n            {\r\n\r\n                // fall back to bisection\r\n\r\n                next_x = x_a + 0.5 * (x_b - x_a);\r\n\r\n                start = sign_change_index - 1;\r\n\r\n                end   = sign_change_index;\r\n\r\n            }\r\n\r\n\r\n\r\n            // evaluate the function at the guessed root\r\n\r\n            const double next_y = compute_objective_value(next_x);\r\n\r\n            if (next_y == 0.0 || std::abs(next_y) < get_function_value_accuracy() && allowed == Allowed_Solution.ANY_SIDE) \r\n\r\n            {\r\n\r\n                // we have either:\r\n\r\n                // - an exact root, so we don't we don't need to bother about the allowed solutions setting\r\n\r\n                // - or an approximate root and we know allowed solutions setting if to retrieve the value closest to zero\r\n\r\n                return Interval(next_x, next_y, next_x, next_y);\r\n\r\n            }\r\n\r\n\r\n\r\n            if ((nb_points > 2) && (end - start != nb_points)) \r\n\r\n            {\r\n\r\n\r\n\r\n                // we have been forced to ignore some points to keep bracketing, // they are probably too far from the root, drop them from now on\r\n\r\n                nb_points = end - start;\r\n\r\n                System.arraycopy(x, start, x, 0, nb_points);\r\n\r\n                System.arraycopy(y, start, y, 0, nb_points);\r\n\r\n                sign_change_index -= start;\r\n\r\n\r\n\r\n            }\r\n\r\nelse  if (nb_points == x.size()) \r\n\r\n            {\r\n\r\n\r\n\r\n                // we have to drop one point in order to insert the one\r\n\r\n                nb_points--;\r\n\r\n\r\n\r\n                // keep the tightest bracketing interval as centered as possible\r\n\r\n                if (sign_change_index >= (x.size() + 1) / 2) \r\n\r\n                {\r\n\r\n                    // we drop the lowest point, we have to shift the arrays and the index\r\n\r\n                    System.arraycopy(x, 1, x, 0, nb_points);\r\n\r\n                    System.arraycopy(y, 1, y, 0, nb_points);\r\n\r\n                    --sign_change_index;\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            // insert the last computed point\r\n\r\n            //(by construction, we know it lies inside the tightest bracketing interval)\r\n\r\n            System.arraycopy(x, sign_change_index, x, sign_change_index + 1, nb_points - sign_change_index);\r\n\r\n            x[sign_change_index] = next_x;\r\n\r\n            System.arraycopy(y, sign_change_index, y, sign_change_index + 1, nb_points - sign_change_index);\r\n\r\n            y[sign_change_index] = next_y;\r\n\r\n            ++nb_points;\r\n\r\n\r\n\r\n            // update the bracketing interval\r\n\r\n            if (next_y * y_a <= 0) \r\n\r\n            {\r\n\r\n                // the sign change occurs before the inserted point\r\n\r\n                x_b = next_x;\r\n\r\n                yB = next_y;\r\n\r\n                abs_y_b = std::abs(yB);\r\n\r\n                ++aging_a;\r\n\r\n                aging_b = 0;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // the sign change occurs after the inserted point\r\n\r\n                x_a = next_x;\r\n\r\n                y_a = next_y;\r\n\r\n                abs_ya = std::abs(y_a);\r\n\r\n                aging_a = 0;\r\n\r\n                ++aging_b;\r\n\r\n\r\n\r\n                // update the sign change index\r\n\r\n                sign_change_index++;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\r\n\r\n     * <p>\r\n\r\n     * The x value is guessed by evaluating polynomial Q(y) at y = target_y, where Q\r\n\r\n     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>), * Q(y<sub>i</sub>) = x<sub>i</sub>.\r\n\r\n     * </p>\r\n\r\n     * @param target_y target value for y\r\n\r\n     * @param x reference points abscissas for interpolation, * note that this array <em>is</em> modified during computation\r\n\r\n     * @param y reference points ordinates for interpolation\r\n\r\n     * @param start start index of the points to consider (inclusive)\r\n\r\n     * @param end end index of the points to consider (exclusive)\r\n\r\n     * @return guessed root (will be a NaN if two points share the same y)\r\n\r\n     */\r\n\r\n    private double guess_x(const double target_y, const std::vector<double> x, const std::vector<double> y, const int start, const int end) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute Q Newton coefficients by divided differences\r\n\r\n        for (int i = start; i < end - 1; ++i) \r\n\r\n        {\r\n\r\n            const int delta = i + 1 - start;\r\n\r\n            for (int j = end - 1; j > i; --j) \r\n\r\n            {\r\n\r\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // evaluate Q(target_y)\r\n\r\n        double x0{};\r\n\r\n        for (int j = end - 1; j >= start; --j) \r\n\r\n        {\r\n\r\n            x0 = x[j] + x0 * (target_y - y[j]);\r\n\r\n        }\r\n\r\n\r\n\r\n        return x0;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public double solve(const int& max_eval, const Univariate_Function& f, const double& min,  const double& max,  Allowed_Solution allowed_solution)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        this.allowed = allowed_solution;\r\n\r\n        return super.solve(max_eval, f, min, max);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public double solve(const int& max_eval, const Univariate_Function& f, const double& min,  const double& max, const double& start_value, Allowed_Solution allowed_solution)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        this.allowed = allowed_solution;\r\n\r\n        return super.solve(max_eval, f, min, max, start_value);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Interval solve_interval(const int max_eval, const Univariate_Function& f, const double& min,  const double& max,  const double start_value)\r\n\r\n            , Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n        setup(max_eval, f, min, max, start_value);\r\n\r\n        this.allowed = null;\r\n\r\n        return do_solve_interval();\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n