/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.Incrementor;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : a modification of the <a\r\n\r\n * href="http://mathworld.wolfram.com/Brents_method.html"> Brent algorithm</a>.\r\n\r\n * <p>\r\n\r\n * The changes with respect to the original Brent algorithm are:\r\n\r\n * <ul>\r\n\r\n *   <li>the returned value is chosen in the current interval according\r\n\r\n *   to user specified {@link Allowed_Solution}</li>\r\n\r\n *   <li>the maximal order for the invert polynomial root search is\r\n\r\n *   user-specified instead of being invert quadratic only</li>\r\n\r\n * </ul><p>\r\n\r\n * The given interval must bracket the root.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldBracketing_Nth_Order_Brent_Solver\r\n\r\n    : Bracketed_Real_Field_Univariate_Solver<T> \r\n\r\n    {\r\n\r\n\r\n\r\n   /** Maximal aging triggering an attempt to balance the bracketing interval. */\r\n\r\n    private static const int MAXIMAL_AGING = 2;\r\n\r\n\r\n\r\n    /** Field to which the elements belong. */\r\n\r\n    private const Field<T> field;\r\n\r\n\r\n\r\n    /** Maximal order. */\r\n\r\n    private const int maximal_order;\r\n\r\n\r\n\r\n    /** Function value accuracy. */\r\n\r\n    private const T function_value_accuracy;\r\n\r\n\r\n\r\n    /** Absolute accuracy. */\r\n\r\n    private const T absolute_accuracy;\r\n\r\n\r\n\r\n    /** Relative accuracy. */\r\n\r\n    private const T relative_accuracy;\r\n\r\n\r\n\r\n    /** Evaluations counter. */\r\n\r\n    private Incrementor evaluations;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param function_value_accuracy Function value accuracy.\r\n\r\n     * @param maximal_order maximal order.\r\n\r\n     * @exception  if maximal order is lower than 2\r\n\r\n     */\r\n\r\n    public FieldBracketing_Nth_Order_Brent_Solver(const T relative_accuracy, const T absolute_accuracy, const T function_value_accuracy, const int maximal_order)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (maximal_order < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, maximal_order, 2);\r\n\r\n        }\r\n\r\n        this.field                 = relative_accuracy.get_field();\r\n\r\n        this.maximal_order          = maximal_order;\r\n\r\n        this.absolute_accuracy      = absolute_accuracy;\r\n\r\n        this.relative_accuracy      = relative_accuracy;\r\n\r\n        this.function_value_accuracy = function_value_accuracy;\r\n\r\n        this.evaluations           = Incrementor();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the maximal order.\r\n\r\n     * @return maximal order\r\n\r\n     */\r\n\r\n    public int get_maximal_order() \r\n\r\n    {\r\n\r\n        return maximal_order;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the maximal number of function evaluations.\r\n\r\n     *\r\n\r\n     * @return the maximal number of function evaluations.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public int get_max_evaluations() \r\n\r\n    {\r\n\r\n        return evaluations.get_maximal_count();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the number of evaluations of the objective function.\r\n\r\n     * The number of evaluations corresponds to the last call to the\r\n\r\n     * {@code optimize} method. It is 0 if the method has not been\r\n\r\n     * called yet.\r\n\r\n     *\r\n\r\n     * @return the number of evaluations of the objective function.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public int get_evaluations() \r\n\r\n    {\r\n\r\n        return evaluations.get_count();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the absolute accuracy.\r\n\r\n     * @return absolute accuracy\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T get_absolute_accuracy() \r\n\r\n    {\r\n\r\n        return absolute_accuracy;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the relative accuracy.\r\n\r\n     * @return relative accuracy\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T get_relative_accuracy() \r\n\r\n    {\r\n\r\n        return relative_accuracy;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the function accuracy.\r\n\r\n     * @return function accuracy\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T get_function_value_accuracy() \r\n\r\n    {\r\n\r\n        return function_value_accuracy;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return a value where the function is zero.\r\n\r\n     * @exception Null_Argument_Exception if f is null.\r\n\r\n     * @exception  if root cannot be bracketed\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T solve(const int max_eval, const Calculus_Field_Univariate_Function<T> f, const T min, const T max, const Allowed_Solution allowed_solution)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        return solve(max_eval, f, min, max, min.add(max).divide(2), allowed_solution);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval, start at {@code start_value}.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param start_value Start value to use.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return a value where the function is zero.\r\n\r\n     * @exception Null_Argument_Exception if f is null.\r\n\r\n     * @exception  if root cannot be bracketed\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T solve(const int max_eval, const Calculus_Field_Univariate_Function<T> f, const T min, const T max, const T start_value, const Allowed_Solution allowed_solution)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        // find interval containing root\r\n\r\n        return solve_interval(max_eval, f, min, max, start_value).get_side(allowed_solution);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Interval<T> solve_interval(const int& max_eval, Calculus_Field_Univariate_Function<T> f, T min, T max, T start_value)\r\n\r\n            , Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n\r\n\r\n        // Checks.\r\n\r\n        //Math_Utils::check_not_null(f);\r\n\r\n\r\n\r\n        // Reset.\r\n\r\n        evaluations = evaluations.with_maximal_count(max_eval);\r\n\r\n        T zero = field.get_zero();\r\n\r\n        T nan  = zero.add(Double.NaN);\r\n\r\n\r\n\r\n        // prepare arrays with the first points\r\n\r\n        const std::vector<T> x = Math_Arrays::build_array(field, maximal_order + 1);\r\n\r\n        const std::vector<T> y = Math_Arrays::build_array(field, maximal_order + 1);\r\n\r\n        x[0] = min;\r\n\r\n        x[1] = start_value;\r\n\r\n        x[2] = max;\r\n\r\n\r\n\r\n        // evaluate initial guess\r\n\r\n        evaluations.increment();\r\n\r\n        y[1] = f.value(x[1]);\r\n\r\n        if (y[1].get_real() == 0.0) \r\n\r\n        {\r\n\r\n            // return the initial guess if it is a perfect root.\r\n\r\n            return Interval<>(x[1], y[1], x[1], y[1]);\r\n\r\n        }\r\n\r\n\r\n\r\n        // evaluate first endpoint\r\n\r\n        evaluations.increment();\r\n\r\n        y[0] = f.value(x[0]);\r\n\r\n        if (y[0].get_real() == 0.0) \r\n\r\n        {\r\n\r\n            // return the first endpoint if it is a perfect root.\r\n\r\n            return Interval<>(x[0], y[0], x[0], y[0]);\r\n\r\n        }\r\n\r\n\r\n\r\n        int nb_points;\r\n\r\n        int sign_change_index;\r\n\r\n        if (y[0].multiply(y[1]).get_real() < 0) \r\n\r\n        {\r\n\r\n\r\n\r\n            // reduce interval if it brackets the root\r\n\r\n            nb_points        = 2;\r\n\r\n            sign_change_index = 1;\r\n\r\n\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            // evaluate second endpoint\r\n\r\n            evaluations.increment();\r\n\r\n            y[2] = f.value(x[2]);\r\n\r\n            if (y[2].get_real() == 0.0) \r\n\r\n            {\r\n\r\n                // return the second endpoint if it is a perfect root.\r\n\r\n                return Interval<>(x[2], y[2], x[2], y[2]);\r\n\r\n            }\r\n\r\n\r\n\r\n            if (y[1].multiply(y[2]).get_real() < 0) \r\n\r\n            {\r\n\r\n                // use all computed point as a start sampling array for solving\r\n\r\n                nb_points        = 3;\r\n\r\n                sign_change_index = 2;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, x[0].get_real(), x[2].get_real(), y[0].get_real(), y[2].get_real());\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // prepare a work array for inverse polynomial interpolation\r\n\r\n        const std::vector<T> tmp_x = Math_Arrays::build_array(field, x.size());\r\n\r\n\r\n\r\n        // current tightest bracketing of the root\r\n\r\n        T x_a    = x[sign_change_index - 1];\r\n\r\n        T y_a    = y[sign_change_index - 1];\r\n\r\n        T abs_x_a = x_a.abs();\r\n\r\n        T abs_ya = y_a.abs();\r\n\r\n        int aging_a   = 0;\r\n\r\n        T x_b    = x[sign_change_index];\r\n\r\n        T yB    = y[sign_change_index];\r\n\r\n        T abs_x_b = x_b.abs();\r\n\r\n        T abs_y_b = yB.abs();\r\n\r\n        int aging_b   = 0;\r\n\r\n\r\n\r\n        // search loop\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n\r\n\r\n            // check convergence of bracketing interval\r\n\r\n            T max_x = abs_x_a.subtract(abs_x_b).get_real() < 0 ? abs_x_b : abs_x_a;\r\n\r\n            T max_y = abs_ya.subtract(abs_y_b).get_real() < 0 ? abs_y_b : abs_ya;\r\n\r\n            const T x_tol = absolute_accuracy.add(relative_accuracy.multiply(max_x));\r\n\r\n            const T midpoint = x_a.add(x_b.subtract(x_a).divide(2));\r\n\r\n            if (x_b.subtract(x_a).subtract(x_tol).get_real() <= 0 ||\r\n\r\n                max_y.subtract(function_value_accuracy).get_real() < 0 ||\r\n\r\n                    x_a.equals(midpoint) || x_b.equals(midpoint)) \r\n\r\n                    {\r\n\r\n                return Interval<>(x_a, y_a, x_b, yB);\r\n\r\n            }\r\n\r\n\r\n\r\n            // target for the next evaluation point\r\n\r\n            T target_y;\r\n\r\n            if (aging_a >= MAXIMAL_AGING) \r\n\r\n            {\r\n\r\n                // we keep updating the high bracket, try to compensate this\r\n\r\n                target_y = yB.divide(16).negate();\r\n\r\n            }\r\n\r\nelse if (aging_b >= MAXIMAL_AGING) \r\n\r\n            {\r\n\r\n                // we keep updating the low bracket, try to compensate this\r\n\r\n                target_y = y_a.divide(16).negate();\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // bracketing is balanced, try to find the root itself\r\n\r\n                target_y = zero;\r\n\r\n            }\r\n\r\n\r\n\r\n            // make a few attempts to guess a root, T next_x;\r\n\r\n            int start = 0;\r\n\r\n            int end   = nb_points;\r\n\r\n            do \r\n\r\n            {\r\n\r\n\r\n\r\n                // guess a value for current target, using inverse polynomial interpolation\r\n\r\n                System.arraycopy(x, start, tmp_x, start, end - start);\r\n\r\n                next_x = guess_x(target_y, tmp_x, y, start, end);\r\n\r\n\r\n\r\n                if (!((next_x.subtract(x_a).get_real() > 0) && (next_x.subtract(x_b).get_real() < 0))) \r\n\r\n                {\r\n\r\n                    // the guessed root is not strictly inside of the tightest bracketing interval\r\n\r\n\r\n\r\n                    // the guessed root is either not strictly inside the interval or it\r\n\r\n                    // is a NaN (which occurs when some sampling points share the same y)\r\n\r\n                    // we try again with a lower interpolation order\r\n\r\n                    if (sign_change_index - start >= end - sign_change_index) \r\n\r\n                    {\r\n\r\n                        // we have more points before the sign change, drop the lowest point\r\n\r\n                        ++start;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        // we have more points after sign change, drop the highest point\r\n\r\n                        --end;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    // we need to do one more attempt\r\n\r\n                    next_x = nan;\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n            } while (std::isnan(next_x.get_real()) && (end - start > 1));\r\n\r\n\r\n\r\n            if (std::isnan(next_x.get_real())) \r\n\r\n            {\r\n\r\n                // fall back to bisection\r\n\r\n                next_x = x_a.add(x_b.subtract(x_a).divide(2));\r\n\r\n                start = sign_change_index - 1;\r\n\r\n                end   = sign_change_index;\r\n\r\n            }\r\n\r\n\r\n\r\n            // evaluate the function at the guessed root\r\n\r\n            evaluations.increment();\r\n\r\n            const T next_y = f.value(next_x);\r\n\r\n            if (next_y.get_real() == 0.0) \r\n\r\n            {\r\n\r\n                // we have found an exact root, since it is not an approximation\r\n\r\n                // we don't need to bother about the allowed solutions setting\r\n\r\n                return Interval<>(next_x, next_y, next_x, next_y);\r\n\r\n            }\r\n\r\n\r\n\r\n            if ((nb_points > 2) && (end - start != nb_points)) \r\n\r\n            {\r\n\r\n\r\n\r\n                // we have been forced to ignore some points to keep bracketing, // they are probably too far from the root, drop them from now on\r\n\r\n                nb_points = end - start;\r\n\r\n                System.arraycopy(x, start, x, 0, nb_points);\r\n\r\n                System.arraycopy(y, start, y, 0, nb_points);\r\n\r\n                sign_change_index -= start;\r\n\r\n\r\n\r\n            }\r\n\r\nelse  if (nb_points == x.size()) \r\n\r\n            {\r\n\r\n\r\n\r\n                // we have to drop one point in order to insert the one\r\n\r\n                nb_points--;\r\n\r\n\r\n\r\n                // keep the tightest bracketing interval as centered as possible\r\n\r\n                if (sign_change_index >= (x.size() + 1) / 2) \r\n\r\n                {\r\n\r\n                    // we drop the lowest point, we have to shift the arrays and the index\r\n\r\n                    System.arraycopy(x, 1, x, 0, nb_points);\r\n\r\n                    System.arraycopy(y, 1, y, 0, nb_points);\r\n\r\n                    --sign_change_index;\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            // insert the last computed point\r\n\r\n            //(by construction, we know it lies inside the tightest bracketing interval)\r\n\r\n            System.arraycopy(x, sign_change_index, x, sign_change_index + 1, nb_points - sign_change_index);\r\n\r\n            x[sign_change_index] = next_x;\r\n\r\n            System.arraycopy(y, sign_change_index, y, sign_change_index + 1, nb_points - sign_change_index);\r\n\r\n            y[sign_change_index] = next_y;\r\n\r\n            ++nb_points;\r\n\r\n\r\n\r\n            // update the bracketing interval\r\n\r\n            if (next_y.multiply(y_a).get_real() <= 0) \r\n\r\n            {\r\n\r\n                // the sign change occurs before the inserted point\r\n\r\n                x_b = next_x;\r\n\r\n                yB = next_y;\r\n\r\n                abs_y_b = yB.abs();\r\n\r\n                ++aging_a;\r\n\r\n                aging_b = 0;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // the sign change occurs after the inserted point\r\n\r\n                x_a = next_x;\r\n\r\n                y_a = next_y;\r\n\r\n                abs_ya = y_a.abs();\r\n\r\n                aging_a = 0;\r\n\r\n                ++aging_b;\r\n\r\n\r\n\r\n                // update the sign change index\r\n\r\n                sign_change_index++;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\r\n\r\n     * <p>\r\n\r\n     * The x value is guessed by evaluating polynomial Q(y) at y = target_y, where Q\r\n\r\n     * is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>), * Q(y<sub>i</sub>) = x<sub>i</sub>.\r\n\r\n     * </p>\r\n\r\n     * @param target_y target value for y\r\n\r\n     * @param x reference points abscissas for interpolation, * note that this array <em>is</em> modified during computation\r\n\r\n     * @param y reference points ordinates for interpolation\r\n\r\n     * @param start start index of the points to consider (inclusive)\r\n\r\n     * @param end end index of the points to consider (exclusive)\r\n\r\n     * @return guessed root (will be a NaN if two points share the same y)\r\n\r\n     */\r\n\r\n    private T guess_x(const T target_y, const std::vector<T> x, const std::vector<T> y, const int start, const int end) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute Q Newton coefficients by divided differences\r\n\r\n        for (int i = start; i < end - 1; ++i) \r\n\r\n        {\r\n\r\n            const int delta = i + 1 - start;\r\n\r\n            for (int j = end - 1; j > i; --j) \r\n\r\n            {\r\n\r\n                x[j] = x[j].subtract(x[j-1]).divide(y[j].subtract(y[j - delta]));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // evaluate Q(target_y)\r\n\r\n        T x0 = field.get_zero();\r\n\r\n        for (int j = end - 1; j >= start; --j) \r\n\r\n        {\r\n\r\n            x0 = x[j].add(x0.multiply(target_y.subtract(y[j])));\r\n\r\n        }\r\n\r\n\r\n\r\n        return x0;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n