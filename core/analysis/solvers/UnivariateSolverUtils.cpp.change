/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Utility routines for {@link Univariate_Solver} objects.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Univariate_Solver_Utils \r\n\r\n{\r\n\r\n    /**\r\n\r\n     * Class contains only static methods.\r\n\r\n     */\r\n\r\n    private Univariate_Solver_Utils() {}\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Convenience method to find a zero of a univariate real function.  A default\r\n\r\n     * solver is used.\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param x0 Lower bound for the interval.\r\n\r\n     * @param x1 Upper bound for the interval.\r\n\r\n     * @return a value where the function is zero.\r\n\r\n     * @ if the function has the same sign at the\r\n\r\n     * endpoints.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static double solve(Univariate_Function function, double x0, double x1)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n        const Univariate_Solver solver = Brent_Solver();\r\n\r\n        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Convenience method to find a zero of a univariate real function.  A default\r\n\r\n     * solver is used.\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param x0 Lower bound for the interval.\r\n\r\n     * @param x1 Upper bound for the interval.\r\n\r\n     * @param absolute_accuracy Accuracy to be used by the solver.\r\n\r\n     * @return a value where the function is zero.\r\n\r\n     * @ if the function has the same sign at the\r\n\r\n     * endpoints.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static double solve(Univariate_Function function, double x0, double x1, double absolute_accuracy)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n        const Univariate_Solver solver = Brent_Solver(absolute_accuracy);\r\n\r\n        return solver.solve(Integer.MAX_VALUE, function, x0, x1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Force a root found by a non-bracketing solver to lie on a specified side, * as if the solver were a bracketing one.\r\n\r\n     *\r\n\r\n     * @param max_eval maximal number of evaluations of the function\r\n\r\n     * (evaluations already done for finding the root should have already been subtracted\r\n\r\n     * from this number)\r\n\r\n     * @param f function to solve\r\n\r\n     * @param bracketing bracketing solver to use for shifting the root\r\n\r\n     * @param base_root original root found by a previous non-bracketing solver\r\n\r\n     * @param min minimal bound of the search interval\r\n\r\n     * @param max maximal bound of the search interval\r\n\r\n     * @param allowed_solution the kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return a root approximation, on the specified side of the exact root\r\n\r\n     * @ if the function has the same sign at the\r\n\r\n     * endpoints.\r\n\r\n     */\r\n\r\n    public static double force_side(const int max_eval, const Univariate_Function& f, const Bracketed_Univariate_Solver<Univariate_Function> bracketing, const double base_root, const double& min,  const double& max,  const Allowed_Solution allowed_solution)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        if (allowed_solution == Allowed_Solution.ANY_SIDE) \r\n\r\n        {\r\n\r\n            // no further bracketing required\r\n\r\n            return base_root;\r\n\r\n        }\r\n\r\n\r\n\r\n        // find a very small interval bracketing the root\r\n\r\n        const double step = std::max(bracketing.get_absolute_accuracy(), std::abs(base_root * bracketing.get_relative_accuracy()));\r\n\r\n        double x_lo        = std::max(min, base_root - step);\r\n\r\n        double f_lo        = f.value(x_lo);\r\n\r\n        double x_hi        = std::min(max, base_root + step);\r\n\r\n        double f_hi        = f.value(x_hi);\r\n\r\n        int remaining_eval = max_eval - 2;\r\n\r\n        while (remaining_eval > 0) \r\n\r\n        {\r\n\r\n\r\n\r\n            if ((f_lo >= 0 && f_hi <= 0) || (f_lo <= 0 && f_hi >= 0)) \r\n\r\n            {\r\n\r\n                // compute the root on the selected side\r\n\r\n                return bracketing.solve(remaining_eval, f, x_lo, x_hi, base_root, allowed_solution);\r\n\r\n            }\r\n\r\n\r\n\r\n            // try increasing the interval\r\n\r\n            bool change_lo = false;\r\n\r\n            bool change_hi = false;\r\n\r\n            if (f_lo < f_hi) \r\n\r\n            {\r\n\r\n                // increasing function\r\n\r\n                if (f_lo >= 0) \r\n\r\n                {\r\n\r\n                    change_lo = true;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    change_hi = true;\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse if (f_lo > f_hi) \r\n\r\n            {\r\n\r\n                // decreasing function\r\n\r\n                if (f_lo <= 0) \r\n\r\n                {\r\n\r\n                    change_lo = true;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    change_hi = true;\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // unknown variation\r\n\r\n                change_lo = true;\r\n\r\n                change_hi = true;\r\n\r\n            }\r\n\r\n\r\n\r\n            // update the lower bound\r\n\r\n            if (change_lo) \r\n\r\n            {\r\n\r\n                x_lo = std::max(min, x_lo - step);\r\n\r\n                f_lo  = f.value(x_lo);\r\n\r\n                remaining_eval--;\r\n\r\n            }\r\n\r\n\r\n\r\n            // update the higher bound\r\n\r\n            if (change_hi) \r\n\r\n            {\r\n\r\n                x_hi = std::min(max, x_hi + step);\r\n\r\n                f_hi  = f.value(x_hi);\r\n\r\n                remaining_eval--;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        throw (Localized_Core_Formats.FAILED_BRACKETING, x_lo, x_hi, f_lo, f_hi, max_eval - remaining_eval, max_eval, base_root, min, max);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method simply calls {@link #bracket(Univariate_Function, double, double, double, * double, double, int) bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}\r\n\r\n     * with {@code q} and {@code r} set to 1.0 and {@code maximum_iterations} set to {@code Integer.MAX_VALUE}.\r\n\r\n     * <p>\r\n\r\n     * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\r\n\r\n     * iterations to throw a {@code Math_Illegal_State_Exception.}  Unless you are\r\n\r\n     * confident that there is a root between {@code lower_bound} and\r\n\r\n     * {@code upper_bound} near {@code initial}, it is better to use\r\n\r\n     * {@link #bracket(Univariate_Function, double, double, double, double,double, int)\r\n\r\n     * bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}, * explicitly specifying the maximum number of iterations.</p>\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value)\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @return a two-element array holding a and b.\r\n\r\n     * @ if a root cannot be bracketed.\r\n\r\n     * @ if {@code maximum_iterations <= 0}.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static std::vector<double> bracket(Univariate_Function function, double initial, double lower_bound, double upper_bound)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        return bracket(function, initial, lower_bound, upper_bound, 1.0, 1.0, Integer.MAX_VALUE);\r\n\r\n    }\r\n\r\n\r\n\r\n     /**\r\n\r\n     * This method simply calls {@link #bracket(Univariate_Function, double, double, double, * double, double, int) bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}\r\n\r\n     * with {@code q} and {@code r} set to 1.0.\r\n\r\n     * @param function Function.\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value).\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @param maximum_iterations Maximum number of iterations to perform\r\n\r\n     * @return a two element array holding a and b.\r\n\r\n     * @ if the algorithm fails to find a and b\r\n\r\n     * satisfying the desired conditions.\r\n\r\n     * @ if {@code maximum_iterations <= 0}.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static std::vector<double> bracket(Univariate_Function function, double initial, double lower_bound, double upper_bound, int maximum_iterations)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        return bracket(function, initial, lower_bound, upper_bound, 1.0, 1.0, maximum_iterations);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method attempts to find two values a and b satisfying <ul>\r\n\r\n     * <li> {@code lower_bound <= a < initial < b <= upper_bound} </li>\r\n\r\n     * <li> {@code f(a) * f(b) <= 0} </li>\r\n\r\n     * </ul>\r\n\r\n     * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\r\n\r\n     * and {@code b} bracket a root of {@code f}.\r\n\r\n     * <p>\r\n\r\n     * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\r\n\r\n     * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\), * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\r\n\r\n     * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\r\n\r\n     * The algorithm stops when one of the following happens: <ul>\r\n\r\n     * <li> at least one positive and one negative value have been found --  success!</li>\r\n\r\n     * <li> both endpoints have reached their respective limits --  </li>\r\n\r\n     * <li> {@code maximum_iterations} iterations elapse --  </li></ul>\r\n\r\n     * <p>\r\n\r\n     * If different signs are found at first iteration ({@code k=1}), then the returned\r\n\r\n     * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\r\n\r\n     * iteration {@code k>1}, then the returned interval will be either\r\n\r\n     * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\r\n\r\n     * with these parameters will therefore start with the smallest bracketing interval known\r\n\r\n     * at this step.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\r\n\r\n     * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\r\n\r\n     * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\r\n\r\n     * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\r\n\r\n     * additive parameter {@code q} should never be set to zero, otherwise the interval would\r\n\r\n     * degenerate to the single initial point for all values of {@code k}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * As a rule of thumb, when the location of the root is expected to be approximately known\r\n\r\n     * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\r\n\r\n     * order of magnitude of the error margin. When the location of the root is really a wild guess, * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\r\n\r\n     * length at each iteration) and {@code q} should be set according to half the initial\r\n\r\n     * search interval length.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\r\n\r\n     * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\r\n\r\n     * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\r\n\r\n     * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\r\n\r\n     * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\r\n\r\n     * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\r\n\r\n     * bracketing interval.\r\n\r\n     * </p>\r\n\r\n     * @param function function to check\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value).\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @param q additive offset used to compute bounds sequence (must be strictly positive)\r\n\r\n     * @param r multiplicative factor used to compute bounds sequence\r\n\r\n     * @param maximum_iterations Maximum number of iterations to perform\r\n\r\n     * @return a two element array holding the bracketing values.\r\n\r\n     * @exception  if function cannot be bracketed in the search interval\r\n\r\n     */\r\n\r\n    public static std::vector<double> bracket(const Univariate_Function function, const double initial, const double lower_bound, const double upper_bound, const double q, const double r, const int maximum_iterations)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n\r\n\r\n        if (q <= 0)  \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, q, 0);\r\n\r\n        }\r\n\r\n        if (maximum_iterations <= 0)  \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INVALID_MAX_ITERATIONS, maximum_iterations);\r\n\r\n        }\r\n\r\n        verify_sequence(lower_bound, initial, upper_bound);\r\n\r\n\r\n\r\n        // initialize the recurrence\r\n\r\n        double a     = initial;\r\n\r\n        double b     = initial;\r\n\r\n        double fa    = std::numeric_limits<double>::quiet_NaN();\r\n\r\n        double fb    = std::numeric_limits<double>::quiet_NaN();\r\n\r\n        double delta = 0;\r\n\r\n\r\n\r\n        for (const int& num_iterations = 0;\r\n\r\n             (num_iterations < maximum_iterations) && (a > lower_bound || b < upper_bound);\r\n\r\n             ++num_iterations) \r\n\r\n             {\r\n\r\n\r\n\r\n            const double previous_a  = a;\r\n\r\n            const double previous_fa = fa;\r\n\r\n            const double previous_b  = b;\r\n\r\n            const double previous_fb = fb;\r\n\r\n\r\n\r\n            delta = r * delta + q;\r\n\r\n            a     = std::max(initial - delta, lower_bound);\r\n\r\n            b     = std::min(initial + delta, upper_bound);\r\n\r\n            fa    = function.value(a);\r\n\r\n            fb    = function.value(b);\r\n\r\n\r\n\r\n            if (num_iterations == 0) \r\n\r\n            {\r\n\r\n                // at first iteration, we don't have a previous interval\r\n\r\n                // we simply compare both sides of the initial interval\r\n\r\n                if (fa * fb <= 0) \r\n\r\n                {\r\n\r\n                    // the first interval already brackets a root\r\n\r\n                    return std::vector<double> { a, b };\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // we have a previous interval with constant sign and expand it, // we expect sign changes to occur at boundaries\r\n\r\n                if (fa * previous_fa <= 0) \r\n\r\n                {\r\n\r\n                    // sign change detected at near lower bound\r\n\r\n                    return std::vector<double> { a, previous_a };\r\n\r\n                }\r\n\r\nelse if (fb * previous_fb <= 0) \r\n\r\n                {\r\n\r\n                    // sign change detected at near upper bound\r\n\r\n                    return std::vector<double> { previous_b, b };\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // no bracketing found\r\n\r\n        throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, a, b, fa, fb);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method simply calls {@link #bracket(Calculus_Field_Univariate_Function, * Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element, * Calculus_Field_Element, int) bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}\r\n\r\n     * with {@code q} and {@code r} set to 1.0 and {@code maximum_iterations} set to {@code Integer.MAX_VALUE}.\r\n\r\n     * <p>\r\n\r\n     * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\r\n\r\n     * iterations to throw a {@code Math_Illegal_State_Exception.}  Unless you are\r\n\r\n     * confident that there is a root between {@code lower_bound} and\r\n\r\n     * {@code upper_bound} near {@code initial}, it is better to use\r\n\r\n     * {@link #bracket(Univariate_Function, double, double, double, double,double, int)\r\n\r\n     * bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}, * explicitly specifying the maximum number of iterations.</p>\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value)\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return a two-element array holding a and b.\r\n\r\n     * @ if a root cannot be bracketed.\r\n\r\n     * @ if {@code maximum_iterations <= 0}.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  std::vector<T> bracket(Calculus_Field_Univariate_Function<T> function, T initial, T lower_bound, T upper_bound)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        return bracket(function, initial, lower_bound, upper_bound, initial.get_field().get_one(), initial.get_field().get_one(), Integer.MAX_VALUE);\r\n\r\n    }\r\n\r\n\r\n\r\n     /**\r\n\r\n     * This method simply calls {@link #bracket(Calculus_Field_Univariate_Function, * Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element, * Calculus_Field_Element, int) bracket(function, initial, lower_bound, upper_bound, q, r, maximum_iterations)}\r\n\r\n     * with {@code q} and {@code r} set to 1.0.\r\n\r\n     * @param function Function.\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value).\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @param maximum_iterations Maximum number of iterations to perform\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return a two element array holding a and b.\r\n\r\n     * @ if the algorithm fails to find a and b\r\n\r\n     * satisfying the desired conditions.\r\n\r\n     * @ if {@code maximum_iterations <= 0}.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  std::vector<T> bracket(Calculus_Field_Univariate_Function<T> function, T initial, T lower_bound, T upper_bound, int maximum_iterations)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        return bracket(function, initial, lower_bound, upper_bound, initial.get_field().get_one(), initial.get_field().get_one(), maximum_iterations);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * This method attempts to find two values a and b satisfying <ul>\r\n\r\n     * <li> {@code lower_bound <= a < initial < b <= upper_bound} </li>\r\n\r\n     * <li> {@code f(a) * f(b) <= 0} </li>\r\n\r\n     * </ul>\r\n\r\n     * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\r\n\r\n     * and {@code b} bracket a root of {@code f}.\r\n\r\n     * <p>\r\n\r\n     * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\r\n\r\n     * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\), * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\r\n\r\n     * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\r\n\r\n     * The algorithm stops when one of the following happens: <ul>\r\n\r\n     * <li> at least one positive and one negative value have been found --  success!</li>\r\n\r\n     * <li> both endpoints have reached their respective limits --  </li>\r\n\r\n     * <li> {@code maximum_iterations} iterations elapse --  </li></ul>\r\n\r\n     * <p>\r\n\r\n     * If different signs are found at first iteration ({@code k=1}), then the returned\r\n\r\n     * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\r\n\r\n     * iteration {@code k>1}, then the returned interval will be either\r\n\r\n     * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\r\n\r\n     * with these parameters will therefore start with the smallest bracketing interval known\r\n\r\n     * at this step.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\r\n\r\n     * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\r\n\r\n     * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\r\n\r\n     * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\r\n\r\n     * additive parameter {@code q} should never be set to zero, otherwise the interval would\r\n\r\n     * degenerate to the single initial point for all values of {@code k}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * As a rule of thumb, when the location of the root is expected to be approximately known\r\n\r\n     * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\r\n\r\n     * order of magnitude of the error margin. When the location of the root is really a wild guess, * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\r\n\r\n     * length at each iteration) and {@code q} should be set according to half the initial\r\n\r\n     * search interval length.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\r\n\r\n     * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\r\n\r\n     * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\r\n\r\n     * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\r\n\r\n     * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\r\n\r\n     * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\r\n\r\n     * bracketing interval.\r\n\r\n     * </p>\r\n\r\n     * @param function function to check\r\n\r\n     * @param initial Initial midpoint of interval being expanded to\r\n\r\n     * bracket a root.\r\n\r\n     * @param lower_bound Lower bound (a is never lower than this value).\r\n\r\n     * @param upper_bound Upper bound (b never is greater than this\r\n\r\n     * value).\r\n\r\n     * @param q additive offset used to compute bounds sequence (must be strictly positive)\r\n\r\n     * @param r multiplicative factor used to compute bounds sequence\r\n\r\n     * @param maximum_iterations Maximum number of iterations to perform\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return a two element array holding the bracketing values.\r\n\r\n     * @exception  if function cannot be bracketed in the search interval\r\n\r\n     * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  std::vector<T> bracket(const Calculus_Field_Univariate_Function<T> function, const T initial, const T lower_bound, const T upper_bound, const T q, const T r, const int maximum_iterations)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n\r\n\r\n        if (q.get_real() <= 0)  \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, q, 0);\r\n\r\n        }\r\n\r\n        if (maximum_iterations <= 0)  \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INVALID_MAX_ITERATIONS, maximum_iterations);\r\n\r\n        }\r\n\r\n        verify_sequence(lower_bound.get_real(), initial.get_real(), upper_bound.get_real());\r\n\r\n\r\n\r\n        // initialize the recurrence\r\n\r\n        T a     = initial;\r\n\r\n        T b     = initial;\r\n\r\n        T fa    = null;\r\n\r\n        T fb    = null;\r\n\r\n        T delta = initial.get_field().get_zero();\r\n\r\n\r\n\r\n        for (const int& num_iterations = 0;\r\n\r\n             (num_iterations < maximum_iterations) &&\r\n\r\n             (a.get_real() > lower_bound.get_real() || b.get_real() < upper_bound.get_real());\r\n\r\n             ++num_iterations) \r\n\r\n             {\r\n\r\n\r\n\r\n            const T previous_a  = a;\r\n\r\n            const T previous_fa = fa;\r\n\r\n            const T previous_b  = b;\r\n\r\n            const T previous_fb = fb;\r\n\r\n\r\n\r\n            delta = r.multiply(delta).add(q);\r\n\r\n            a     = max(initial.subtract(delta), lower_bound);\r\n\r\n            b     = min(initial.add(delta), upper_bound);\r\n\r\n            fa    = function.value(a);\r\n\r\n            fb    = function.value(b);\r\n\r\n\r\n\r\n            if (num_iterations == 0) \r\n\r\n            {\r\n\r\n                // at first iteration, we don't have a previous interval\r\n\r\n                // we simply compare both sides of the initial interval\r\n\r\n                if (fa.multiply(fb).get_real() <= 0) \r\n\r\n                {\r\n\r\n                    // the first interval already brackets a root\r\n\r\n                    const std::vector<T> interval = Math_Arrays::build_array(initial.get_field(), 2);\r\n\r\n                    interval[0] = a;\r\n\r\n                    interval[1] = b;\r\n\r\n                    return interval;\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // we have a previous interval with constant sign and expand it, // we expect sign changes to occur at boundaries\r\n\r\n                if (fa.multiply(previous_fa).get_real() <= 0) \r\n\r\n                {\r\n\r\n                    // sign change detected at near lower bound\r\n\r\n                    const std::vector<T> interval = Math_Arrays::build_array(initial.get_field(), 2);\r\n\r\n                    interval[0] = a;\r\n\r\n                    interval[1] = previous_a;\r\n\r\n                    return interval;\r\n\r\n                }\r\n\r\nelse if (fb.multiply(previous_fb).get_real() <= 0) \r\n\r\n                {\r\n\r\n                    // sign change detected at near upper bound\r\n\r\n                    const std::vector<T> interval = Math_Arrays::build_array(initial.get_field(), 2);\r\n\r\n                    interval[0] = previous_b;\r\n\r\n                    interval[1] = b;\r\n\r\n                    return interval;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // no bracketing found\r\n\r\n        throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, a.get_real(), b.get_real(), fa.get_real(), fb.get_real());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the maximum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return b if a is lesser or equal to b, a otherwise\r\n\r\n     * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private static  T max(const T& a, const T& b) \r\n\r\n    {\r\n\r\n        return (a.subtract(b).get_real() <= 0) ? b : a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the minimum of two values\r\n\r\n     * @param a first value\r\n\r\n     * @param b second value\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return a if a is lesser or equal to b, b otherwise\r\n\r\n     * @since 1.2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private static  T min(const T& a, const T& b) \r\n\r\n    {\r\n\r\n        return (a.subtract(b).get_real() <= 0) ? a : b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the midpoint of two values.\r\n\r\n     *\r\n\r\n     * @param a first value.\r\n\r\n     * @param b second value.\r\n\r\n     * @return the midpoint.\r\n\r\n     */\r\n\r\n    public static double midpoint(const double& a, double b) \r\n\r\n    {\r\n\r\n        return (a + b) * 0.5;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check whether the interval bounds bracket a root. That is, if the\r\n\r\n     * values at the endpoints are not equal to zero, then the function takes\r\n\r\n     * opposite signs at the endpoints.\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param lower Lower endpoint.\r\n\r\n     * @param upper Upper endpoint.\r\n\r\n     * @return {@code true} if the function values have opposite signs at the\r\n\r\n     * given points.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static bool is_bracketing(Univariate_Function function, const double lower, const double upper)\r\n\r\n        Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n        const double f_lo = function.value(lower);\r\n\r\n        const double f_hi = function.value(upper);\r\n\r\n        return (f_lo >= 0 && f_hi <= 0) || (f_lo <= 0 && f_hi >= 0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check whether the arguments form a (strictly) increasing sequence.\r\n\r\n     *\r\n\r\n     * @param start First number.\r\n\r\n     * @param mid Second number.\r\n\r\n     * @param end Third number.\r\n\r\n     * @return {@code true} if the arguments form an increasing sequence.\r\n\r\n     */\r\n\r\n    public static bool is_sequence(const double start, const double mid, const double end) \r\n\r\n    {\r\n\r\n        return (start < mid) && (mid < end);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the endpoints specify an interval.\r\n\r\n     *\r\n\r\n     * @param lower Lower endpoint.\r\n\r\n     * @param upper Upper endpoint.\r\n\r\n     * @ if {@code lower >= upper}.\r\n\r\n     */\r\n\r\n    public static void verify_interval(const double lower, const double upper)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (lower >= upper) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.ENDPOINTS_NOT_AN_INTERVAL, lower, upper, false);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that {@code lower < initial < upper}.\r\n\r\n     *\r\n\r\n     * @param lower Lower endpoint.\r\n\r\n     * @param initial Initial value.\r\n\r\n     * @param upper Upper endpoint.\r\n\r\n     * @ if {@code lower >= initial} or\r\n\r\n     * {@code initial >= upper}.\r\n\r\n     */\r\n\r\n    public static void verify_sequence(const double lower, const double initial, const double upper)\r\n\r\n         \r\n\r\n        {\r\n\r\n        verify_interval(lower, initial);\r\n\r\n        verify_interval(initial, upper);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the endpoints specify an interval and the end points\r\n\r\n     * bracket a root.\r\n\r\n     *\r\n\r\n     * @param function Function.\r\n\r\n     * @param lower Lower endpoint.\r\n\r\n     * @param upper Upper endpoint.\r\n\r\n     * @ if the function has the same sign at the\r\n\r\n     * endpoints.\r\n\r\n     * @Null_Argument_Exception if {@code function} is {@code null}.\r\n\r\n     */\r\n\r\n    public static void verify_bracketing(Univariate_Function function, const double lower, const double upper)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(function, Localized_Core_Formats.FUNCTION);\r\n\r\n        verify_interval(lower, upper);\r\n\r\n        if (!is_bracketing(function, lower, upper)) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, lower, upper, function.value(lower), function.value(upper));\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n