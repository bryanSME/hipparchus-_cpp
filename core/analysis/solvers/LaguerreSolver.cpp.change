/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.polynomials.Polynomial_Function;\r\n\r\n//import org.hipparchus.complex.std::complex<double>;\r\n\r\n//import org.hipparchus.complex.std::complex<double>_Utils;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * Implements the <a href="http://mathworld.wolfram.com/Laguerres_method.html">\r\n\r\n * Laguerre's Method</a> for root finding of real coefficient polynomials.\r\n\r\n * For reference, see\r\n\r\n * <blockquote>\r\n\r\n *  <b>A First Course in Numerical Analysis</b>, *  ISBN 048641454X, chapter 8.\r\n\r\n * </blockquote>\r\n\r\n * Laguerre's method is global in the sense that it can start with any initial\r\n\r\n * approximation and be able to solve all roots from that point.\r\n\r\n * The algorithm requires a bracketing condition.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Laguerre_Solver extends AbstractPolynomial_Solver \r\n\r\n{\r\n\r\n    /** Default absolute accuracy. */\r\n\r\n    private static const double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\r\n\r\n    /** std::complex<double> solver. */\r\n\r\n    private const std::complex<double>_Solver complex_solver = std::complex<double>_Solver();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver with default accuracy (1e-6).\r\n\r\n     */\r\n\r\n    public Laguerre_Solver() \r\n\r\n    {\r\n\r\n        this(DEFAULT_ABSOLUTE_ACCURACY);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Laguerre_Solver(double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Laguerre_Solver(double relative_accuracy, double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     * @param function_value_accuracy Function value accuracy.\r\n\r\n     */\r\n\r\n    public Laguerre_Solver(double relative_accuracy, double absolute_accuracy, double function_value_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy, function_value_accuracy);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public double do_solve()\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        const double min = get_min();\r\n\r\n        const double max = get_max();\r\n\r\n        const double initial = get_start_value();\r\n\r\n        const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n        verify_sequence(min, initial, max);\r\n\r\n\r\n\r\n        // Return the initial guess if it is good enough.\r\n\r\n        const double y_initial = compute_objective_value(initial);\r\n\r\n        if (std::abs(y_initial) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return initial;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Return the first endpoint if it is good enough.\r\n\r\n        const double y_min = compute_objective_value(min);\r\n\r\n        if (std::abs(y_min) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return min;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Reduce interval if min and initial bracket the root.\r\n\r\n        if (y_initial * y_min < 0) \r\n\r\n        {\r\n\r\n            return laguerre(min, initial);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Return the second endpoint if it is good enough.\r\n\r\n        const double y_max = compute_objective_value(max);\r\n\r\n        if (std::abs(y_max) <= function_value_accuracy) \r\n\r\n        {\r\n\r\n            return max;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Reduce interval if initial and max bracket the root.\r\n\r\n        if (y_initial * y_max < 0) \r\n\r\n        {\r\n\r\n            return laguerre(initial, max);\r\n\r\n        }\r\n\r\n\r\n\r\n        throw (Localized_Core_Formats.NOT_BRACKETING_INTERVAL, min, max, y_min, y_max);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find a real root in the given interval.\r\n\r\n     *\r\n\r\n     * Despite the bracketing condition, the root returned by\r\n\r\n     * {@link Laguerre_Solver.std::complex<double>_Solver#solve(std::complex<double>[],std::complex<double>)} may\r\n\r\n     * not be a real zero inside {@code [min, max]}.\r\n\r\n     * For example, <code> p(x) = x<sup>3</sup> + 1, </code>\r\n\r\n     * with {@code min = -2}, {@code max = 2}, {@code initial = 0}.\r\n\r\n     * When it occurs, this code calls\r\n\r\n     * {@link Laguerre_Solver.std::complex<double>_Solver#solve_all(std::complex<double>[],std::complex<double>)}\r\n\r\n     * in order to obtain all roots and picks up one real root.\r\n\r\n     *\r\n\r\n     * @param lo Lower bound of the search interval.\r\n\r\n     * @param hi Higher bound of the search interval.\r\n\r\n     * @return the point at which the function value is zero.\r\n\r\n     */\r\n\r\n    private double laguerre(const double& lo, const double& hi) \r\n\r\n    {\r\n\r\n        const std::complex<double> c[] = std::complex<double>_Utils.convert_to_complex(get_coefficients());\r\n\r\n\r\n\r\n        const std::complex<double> initial = std::complex<double>(0.5 * (lo + hi), 0);\r\n\r\n        const std::complex<double> z = complex_solver.solve(c, initial);\r\n\r\n        if (complex_solver.is_root(lo, hi, z)) \r\n\r\n        {\r\n\r\n            return z.get_real();\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            double r = std::numeric_limits<double>::quiet_NaN();\r\n\r\n            // Solve all roots and select the one we are seeking.\r\n\r\n            std::vector<std::complex<double>>root = complex_solver.solve_all(c, initial);\r\n\r\n            for (int i{}; i < root.size(); i++) \r\n\r\n            {\r\n\r\n                if (complex_solver.is_root(lo, hi, root[i])) \r\n\r\n                {\r\n\r\n                    r = root[i].get_real();\r\n\r\n                    break;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return r;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find all complex roots for the polynomial with the given\r\n\r\n     * coefficients, starting from the given initial value.\r\n\r\n     * <p>\r\n\r\n     * Note: This method is not part of the API of {@link BaseUnivariate_Solver}.</p>\r\n\r\n     *\r\n\r\n     * @param coefficients Polynomial coefficients.\r\n\r\n     * @param initial Start value.\r\n\r\n     * @return the point at which the function value is zero.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception\r\n\r\n     * if the maximum number of evaluations is exceeded.\r\n\r\n     * @Null_Argument_Exception if the {@code coefficients} is\r\n\r\n     * {@code null}.\r\n\r\n     * @ if the {@code coefficients} array is empty.\r\n\r\n     */\r\n\r\n    public std::vector<std::complex<double>>solve_all_complex(std::vector<double> coefficients, double initial)\r\n\r\n        , Null_Argument_Exception, Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        setup(Integer.MAX_VALUE, Polynomial_Function(coefficients), -INFINITY, INFINITY, initial);\r\n\r\n        return complex_solver.solve_all(std::complex<double>_Utils.convert_to_complex(coefficients), std::complex<double>(initial, 0.0));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find a complex root for the polynomial with the given coefficients, * starting from the given initial value.\r\n\r\n     * <p>\r\n\r\n     * Note: This method is not part of the API of {@link BaseUnivariate_Solver}.</p>\r\n\r\n     *\r\n\r\n     * @param coefficients Polynomial coefficients.\r\n\r\n     * @param initial Start value.\r\n\r\n     * @return the point at which the function value is zero.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception\r\n\r\n     * if the maximum number of evaluations is exceeded.\r\n\r\n     * @Null_Argument_Exception if the {@code coefficients} is\r\n\r\n     * {@code null}.\r\n\r\n     * @ if the {@code coefficients} array is empty.\r\n\r\n     */\r\n\r\n    public std::complex<double> solve_complex(std::vector<double> coefficients, double initial)\r\n\r\n        , Null_Argument_Exception, Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        setup(Integer.MAX_VALUE, Polynomial_Function(coefficients), -INFINITY, INFINITY, initial);\r\n\r\n        return complex_solver.solve(std::complex<double>_Utils.convert_to_complex(coefficients), std::complex<double>(initial, 0.0));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Class for searching all (complex) roots.\r\n\r\n     */\r\n\r\n    private class std::complex<double>_Solver \r\n\r\n    {\r\n\r\n        /**\r\n\r\n         * Check whether the given complex root is actually a real zero\r\n\r\n         * in the given interval, within the solver tolerance level.\r\n\r\n         *\r\n\r\n         * @param min Lower bound for the interval.\r\n\r\n         * @param max Upper bound for the interval.\r\n\r\n         * @param z std::complex<double> root.\r\n\r\n         * @return {@code true} if z is a real zero.\r\n\r\n         */\r\n\r\n        public bool is_root(double min, const double& max,  std::complex<double> z) \r\n\r\n        {\r\n\r\n            if (is_sequence(min, z.get_real(), max)) \r\n\r\n            {\r\n\r\n                const double z_abs = z.norm();\r\n\r\n                double tolerance = std::max(get_relative_accuracy() * z_abs, get_absolute_accuracy());\r\n\r\n                return (std::abs(z.get_imaginary()) <= tolerance) ||\r\n\r\n                     (z_abs <= get_function_value_accuracy());\r\n\r\n            }\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Find all complex roots for the polynomial with the given\r\n\r\n         * coefficients, starting from the given initial value.\r\n\r\n         *\r\n\r\n         * @param coefficients Polynomial coefficients.\r\n\r\n         * @param initial Start value.\r\n\r\n         * @return the point at which the function value is zero.\r\n\r\n         * @org.hipparchus.exception.Math_Illegal_State_Exception\r\n\r\n         * if the maximum number of evaluations is exceeded.\r\n\r\n         * @Null_Argument_Exception if the {@code coefficients} is\r\n\r\n         * {@code null}.\r\n\r\n         * @ if the {@code coefficients} array is empty.\r\n\r\n         */\r\n\r\n        public std::vector<std::complex<double>>solve_all(std::complex<double> coefficients[], std::complex<double> initial)\r\n\r\n            , Null_Argument_Exception, Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n            if (coefficients == null) \r\n\r\n            {\r\n\r\n                throw Null_Argument_Exception();\r\n\r\n            }\r\n\r\n            const int n = coefficients.size() - 1;\r\n\r\n            if (n == 0) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.POLYNOMIAL);\r\n\r\n            }\r\n\r\n            // Coefficients for deflated polynomial.\r\n\r\n            const std::complex<double> c[] = std::complex<double>[n + 1];\r\n\r\n            for (int i{}; i <= n; i++) \r\n\r\n            {\r\n\r\n                c[i] = coefficients[i];\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve individual roots successively.\r\n\r\n            const std::complex<double> root[] = std::complex<double>[n];\r\n\r\n            for (int i{}; i < n; i++) \r\n\r\n            {\r\n\r\n                const std::complex<double> subarray[] = std::complex<double>[n - i + 1];\r\n\r\n                System.arraycopy(c, 0, subarray, 0, subarray.size());\r\n\r\n                root[i] = solve(subarray, initial);\r\n\r\n                // Polynomial deflation using synthetic division.\r\n\r\n                std::complex<double> newc = c[n - i];\r\n\r\n                std::complex<double> oldc;\r\n\r\n                for (int j = n - i - 1; j >= 0; j--) \r\n\r\n                {\r\n\r\n                    oldc = c[j];\r\n\r\n                    c[j] = newc;\r\n\r\n                    newc = oldc.add(newc.multiply(root[i]));\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return root;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Find a complex root for the polynomial with the given coefficients, * starting from the given initial value.\r\n\r\n         *\r\n\r\n         * @param coefficients Polynomial coefficients.\r\n\r\n         * @param initial Start value.\r\n\r\n         * @return the point at which the function value is zero.\r\n\r\n         * @org.hipparchus.exception.Math_Illegal_State_Exception\r\n\r\n         * if the maximum number of evaluations is exceeded.\r\n\r\n         * @Null_Argument_Exception if the {@code coefficients} is\r\n\r\n         * {@code null}.\r\n\r\n         * @ if the {@code coefficients} array is empty.\r\n\r\n         */\r\n\r\n        public std::complex<double> solve(std::complex<double> coefficients[], std::complex<double> initial)\r\n\r\n            , Null_Argument_Exception, Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n            if (coefficients == null) \r\n\r\n            {\r\n\r\n                throw Null_Argument_Exception();\r\n\r\n            }\r\n\r\n\r\n\r\n            const int n = coefficients.size() - 1;\r\n\r\n            if (n == 0) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.POLYNOMIAL);\r\n\r\n            }\r\n\r\n\r\n\r\n            const double& absolute_accuracy = get_absolute_accuracy();\r\n\r\n            const double relative_accuracy = get_relative_accuracy();\r\n\r\n            const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n            const std::complex<double> n_c  = std::complex<double>(n, 0);\r\n\r\n            const std::complex<double> n1C = std::complex<double>(n - 1, 0);\r\n\r\n\r\n\r\n            std::complex<double> z = initial;\r\n\r\n            std::complex<double> oldz = std::complex<double>(INFINITY, INFINITY);\r\n\r\n            while (true) \r\n\r\n            {\r\n\r\n                // Compute pv (polynomial value), dv (derivative value), and\r\n\r\n                // d2v (second derivative value) simultaneously.\r\n\r\n                std::complex<double> pv = coefficients[n];\r\n\r\n                std::complex<double> dv = std::complex<double>.ZERO;\r\n\r\n                std::complex<double> d2v = std::complex<double>.ZERO;\r\n\r\n                for (int j = n-1; j >= 0; j--) \r\n\r\n                {\r\n\r\n                    d2v = dv.add(z.multiply(d2v));\r\n\r\n                    dv = pv.add(z.multiply(dv));\r\n\r\n                    pv = coefficients[j].add(z.multiply(pv));\r\n\r\n                }\r\n\r\n                d2v = d2v.multiply(new std::complex<double>(2.0, 0.0));\r\n\r\n\r\n\r\n                // Check for convergence.\r\n\r\n                const double& tolerance = std::max(relative_accuracy * z.norm(), absolute_accuracy);\r\n\r\n                if ((z.subtract(oldz)).norm() <= tolerance) \r\n\r\n                {\r\n\r\n                    return z;\r\n\r\n                }\r\n\r\n                if (pv.norm() <= function_value_accuracy) \r\n\r\n                {\r\n\r\n                    return z;\r\n\r\n                }\r\n\r\n\r\n\r\n                // Now pv != 0, calculate the approximation.\r\n\r\n                const std::complex<double> G = dv.divide(pv);\r\n\r\n                const std::complex<double> G2 = G.multiply(G);\r\n\r\n                const std::complex<double> H = G2.subtract(d2v.divide(pv));\r\n\r\n                const std::complex<double> delta = n1C.multiply((n_c.multiply(H)).subtract(G2));\r\n\r\n                // Choose a denominator larger in magnitude.\r\n\r\n                const std::complex<double> delta_sqrt = delta.sqrt();\r\n\r\n                const std::complex<double> dplus = G.add(delta_sqrt);\r\n\r\n                const std::complex<double> dminus = G.subtract(delta_sqrt);\r\n\r\n                const std::complex<double> denominator = dplus.norm() > dminus.norm() ? dplus : dminus;\r\n\r\n                // Perturb z if denominator is zero, for instance, // p(x) = x^3 + 1, z = 0.\r\n\r\n                if (denominator.is_zero()) \r\n\r\n                {\r\n\r\n                    z = z.add(new std::complex<double>(absolute_accuracy, absolute_accuracy));\r\n\r\n                    oldz = std::complex<double>(INFINITY, INFINITY);\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    oldz = z;\r\n\r\n                    z = z.subtract(n_c.divide(denominator));\r\n\r\n                }\r\n\r\n                increment_evaluation_count();\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n