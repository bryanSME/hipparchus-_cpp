/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.solvers;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n\r\n\r\n/** Interface for {@link Univariate_Solver (univariate real) root-finding\r\n\r\n * algorithms} that maintain a bracketed solution. There are several advantages\r\n\r\n * to having such root-finding algorithms:\r\n\r\n * <ul>\r\n\r\n *  <li>The bracketed solution guarantees that the root is kept within the\r\n\r\n *      interval. As such, these algorithms generally also guarantee\r\n\r\n *      convergence.</li>\r\n\r\n *  <li>The bracketed solution means that we have the opportunity to only\r\n\r\n *      return roots that are greater than or equal to the actual root, or\r\n\r\n *      are less than or equal to the actual root. That is, we can control\r\n\r\n *      whether under-approximations and over-approximations are\r\n\r\n *      {@link Allowed_Solution allowed solutions}. Other root-finding\r\n\r\n *      algorithms can usually only guarantee that the solution (the root that\r\n\r\n *      was found) is around the actual root.</li>\r\n\r\n * </ul>\r\n\r\n *\r\n\r\n * <p>For backwards compatibility, all root-finding algorithms must have\r\n\r\n * {@link Allowed_Solution#ANY_SIDE ANY_SIDE} as default for the allowed\r\n\r\n * solutions.</p>\r\n\r\n *\r\n\r\n * @see Allowed_Solution\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Bracketed_Real_Field_Univariate_Solver \r\n\r\n{\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the maximum number of function evaluations.\r\n\r\n     *\r\n\r\n     * @return the maximum number of function evaluations.\r\n\r\n     */\r\n\r\n    int get_max_evaluations();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the number of evaluations of the objective function.\r\n\r\n     * The number of evaluations corresponds to the last call to the\r\n\r\n     * {@code optimize} method. It is 0 if the method has not been\r\n\r\n     * called yet.\r\n\r\n     *\r\n\r\n     * @return the number of evaluations of the objective function.\r\n\r\n     */\r\n\r\n    int get_evaluations();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the absolute accuracy of the solver.  Solutions returned by the\r\n\r\n     * solver should be accurate to this tolerance, i.e., if &epsilon; is the\r\n\r\n     * absolute accuracy of the solver and {@code v} is a value returned by\r\n\r\n     * one of the {@code solve} methods, then a root of the function should\r\n\r\n     * exist somewhere in the interval ({@code v} - &epsilon;, {@code v} + &epsilon;).\r\n\r\n     *\r\n\r\n     * @return the absolute accuracy.\r\n\r\n     */\r\n\r\n    T get_absolute_accuracy();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the relative accuracy of the solver.  The contract for relative\r\n\r\n     * accuracy is the same as {@link #get_absolute_accuracy()}, but using\r\n\r\n     * relative, rather than absolute error.  If &rho; is the relative accuracy\r\n\r\n     * configured for a solver and {@code v} is a value returned, then a root\r\n\r\n     * of the function should exist somewhere in the interval\r\n\r\n     * ({@code v} - &rho; {@code v}, {@code v} + &rho; {@code v}).\r\n\r\n     *\r\n\r\n     * @return the relative accuracy.\r\n\r\n     */\r\n\r\n    T get_relative_accuracy();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the function value accuracy of the solver.  If {@code v} is\r\n\r\n     * a value returned by the solver for a function {@code f}, * then by contract, {@code |f(v)|} should be less than or equal to\r\n\r\n     * the function value accuracy configured for the solver.\r\n\r\n     *\r\n\r\n     * @return the function value accuracy.\r\n\r\n     */\r\n\r\n    T get_function_value_accuracy();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return A value where the function is zero.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if the arguments do not satisfy the requirements specified by the solver.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception if\r\n\r\n     * the allowed number of evaluations is exceeded.\r\n\r\n     */\r\n\r\n    T solve(const int& max_eval, Calculus_Field_Univariate_Function<T> f, T min, T max, Allowed_Solution allowed_solution);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval, start at {@code start_value}.\r\n\r\n     * A solver may require that the interval brackets a single zero root.\r\n\r\n     * Solvers that do require bracketing should be able to handle the case\r\n\r\n     * where one of the endpoints is itself a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f Function to solve.\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param start_value Start value to use.\r\n\r\n     * @param allowed_solution The kind of solutions that the root-finding algorithm may\r\n\r\n     * accept as solutions.\r\n\r\n     * @return A value where the function is zero.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if the arguments do not satisfy the requirements specified by the solver.\r\n\r\n     * @org.hipparchus.exception.Math_Illegal_State_Exception if\r\n\r\n     * the allowed number of evaluations is exceeded.\r\n\r\n     */\r\n\r\n    T solve(const int& max_eval, Calculus_Field_Univariate_Function<T> f, T min, T max, T start_value, Allowed_Solution allowed_solution);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval and return a tolerance interval surrounding\r\n\r\n     * the root.\r\n\r\n     *\r\n\r\n     * <p> It is required that the starting interval brackets a root.\r\n\r\n     *\r\n\r\n     * @param max_eval Maximum number of evaluations.\r\n\r\n     * @param f       Function to solve.\r\n\r\n     * @param min     Lower bound for the interval. f(min) != 0.0.\r\n\r\n     * @param max     Upper bound for the interval. f(max) != 0.0.\r\n\r\n     * @return an interval [ta, tb] such that for some t in [ta, tb] f(t) == 0.0 or has a\r\n\r\n     * step wise discontinuity that crosses zero. Both end points also satisfy the\r\n\r\n     * convergence criteria so either one could be used as the root. That is the interval\r\n\r\n     * satisfies the condition (| tb - ta | &lt;= {@link #get_absolute_accuracy() absolute}\r\n\r\n     * accuracy + max(ta, tb) * {@link #get_relative_accuracy() relative} accuracy) or (\r\n\r\n     * max(|f(ta)|, |f(tb)|) &lt;= {@link #get_function_value_accuracy()}) or there are no\r\n\r\n     * numbers in the field between ta and tb. The width of the interval (tb - ta) may be\r\n\r\n     * zero.\r\n\r\n     * @ if the arguments do not satisfy the\r\n\r\n     *                                      requirements specified by the solver.\r\n\r\n     * @Math_Illegal_State_Exception    if the allowed number of evaluations is\r\n\r\n     *                                      exceeded.\r\n\r\n     */\r\n\r\n    default Interval<T> solve_interval(const int& max_eval, Calculus_Field_Univariate_Function<T> f, T min, T max)\r\n\r\n            , Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n        return this.solve_interval(max_eval, f, min, max, min.add(max.subtract(min).multiply(0.5)));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Solve for a zero in the given interval and return a tolerance interval surrounding\r\n\r\n     * the root.\r\n\r\n     *\r\n\r\n     * <p> It is required that the starting interval brackets a root.\r\n\r\n     *\r\n\r\n     * @param max_eval    Maximum number of evaluations.\r\n\r\n     * @param start_value start value to use.\r\n\r\n     * @param f          Function to solve.\r\n\r\n     * @param min        Lower bound for the interval. f(min) != 0.0.\r\n\r\n     * @param max        Upper bound for the interval. f(max) != 0.0.\r\n\r\n     * @return an interval [ta, tb] such that for some t in [ta, tb] f(t) == 0.0 or has a\r\n\r\n     * step wise discontinuity that crosses zero. Both end points also satisfy the\r\n\r\n     * convergence criteria so either one could be used as the root. That is the interval\r\n\r\n     * satisfies the condition (| tb - ta | &lt;= {@link #get_absolute_accuracy() absolute}\r\n\r\n     * accuracy + max(ta, tb) * {@link #get_relative_accuracy() relative} accuracy) or (\r\n\r\n     * max(|f(ta)|, |f(tb)|) &lt;= {@link #get_function_value_accuracy()}) or numbers in the\r\n\r\n     * field between ta and tb. The width of the interval (tb - ta) may be zero.\r\n\r\n     * @ if the arguments do not satisfy the\r\n\r\n     *                                      requirements specified by the solver.\r\n\r\n     * @Math_Illegal_State_Exception    if the allowed number of evaluations is\r\n\r\n     *                                      exceeded.\r\n\r\n     */\r\n\r\n    Interval<T> solve_interval(const int& max_eval, Calculus_Field_Univariate_Function<T> f, T min, T max, T start_value)\r\n\r\n            , Math_Illegal_State_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * An interval of a function that brackets a root.\r\n\r\n     * <p>\r\n\r\n     * Contains two end points and the value of the function at the two end points.\r\n\r\n     *\r\n\r\n     * @see #solve_interval(int, Calculus_Field_Univariate_Function, Calculus_Field_Element, * Calculus_Field_Element)\r\n\r\n     * @param <T> the element type\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    class Interval \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Abscissa on the left end of the interval. */\r\n\r\n        private const T left_abscissa;\r\n\r\n        /** Function value at {@link #left_abscissa}. */\r\n\r\n        private const T left_value;\r\n\r\n        /** Abscissa on the right end of the interval, >= {@link #left_abscissa}. */\r\n\r\n        private const T right_abscissa;\r\n\r\n        /** Function value at {@link #right_abscissa}. */\r\n\r\n        private const T right_value;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Construct a interval with the given end points.\r\n\r\n         *\r\n\r\n         * @param left_abscissa  is the abscissa value at the left side of the interval.\r\n\r\n         * @param left_value     is the function value at {@code left_abscissa}.\r\n\r\n         * @param right_abscissa is the abscissa value on the right side of the interval.\r\n\r\n         *                      Must be greater than or equal to {@code left_abscissa}.\r\n\r\n         * @param right_value    is the function value at {@code right_abscissa}.\r\n\r\n         */\r\n\r\n        public Interval(const T left_abscissa, const T left_value, const T right_abscissa, const T right_value) \r\n\r\n        {\r\n\r\n            this.left_abscissa = left_abscissa;\r\n\r\n            this.left_value = left_value;\r\n\r\n            this.right_abscissa = right_abscissa;\r\n\r\n            this.right_value = right_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the left abscissa.\r\n\r\n         *\r\n\r\n         * @return abscissa of the start of the interval.\r\n\r\n         */\r\n\r\n        public T get_left_abscissa() \r\n\r\n        {\r\n\r\n            return left_abscissa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the right abscissa.\r\n\r\n         *\r\n\r\n         * @return abscissa of the end of the interval.\r\n\r\n         */\r\n\r\n        public T get_right_abscissa() \r\n\r\n        {\r\n\r\n            return right_abscissa;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the function value at {@link #get_left_abscissa()}.\r\n\r\n         *\r\n\r\n         * @return value of the function at the start of the interval.\r\n\r\n         */\r\n\r\n        public T get_left_value() \r\n\r\n        {\r\n\r\n            return left_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the function value at {@link #get_right_abscissa()}.\r\n\r\n         *\r\n\r\n         * @return value of the function at the end of the interval.\r\n\r\n         */\r\n\r\n        public T get_right_value() \r\n\r\n        {\r\n\r\n            return right_value;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the abscissa corresponding to the allowed side.\r\n\r\n         *\r\n\r\n         * @param allowed side of the root.\r\n\r\n         * @return the abscissa on the selected side of the root.\r\n\r\n         */\r\n\r\n        public T get_side(const Allowed_Solution allowed) \r\n\r\n        {\r\n\r\n            const T x_a = this.get_left_abscissa();\r\n\r\n            const T y_a = this.get_left_value();\r\n\r\n            const T x_b = this.get_right_abscissa();\r\n\r\n            switch (allowed) \r\n\r\n            {\r\n\r\n                case ANY_SIDE:\r\n\r\n                    const T abs_ya = this.get_left_value().abs();\r\n\r\n                    const T abs_y_b = this.get_right_value().abs();\r\n\r\n                    return abs_ya.subtract(abs_y_b).get_real() < 0 ? x_a : x_b;\r\n\r\n                case LEFT_SIDE:\r\n\r\n                    return x_a;\r\n\r\n                case RIGHT_SIDE:\r\n\r\n                    return x_b;\r\n\r\n                case BELOW_SIDE:\r\n\r\n                    return (y_a.get_real() <= 0) ? x_a : x_b;\r\n\r\n                case ABOVE_SIDE:\r\n\r\n                    return (y_a.get_real() < 0) ? x_b : x_a;\r\n\r\n                default:\r\n\r\n                    // this should never happen\r\n\r\n                    throw Math_Runtime_Exception.create_internal_error();\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n