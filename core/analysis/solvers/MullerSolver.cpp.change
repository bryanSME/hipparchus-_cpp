/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the <a href="http://mathworld.wolfram.com/Mullers_method.html">\r\n\r\n * Muller's Method</a> for root finding of real univariate functions. For\r\n\r\n * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477, * chapter 3.\r\n\r\n * <p>\r\n\r\n * Muller's method applies to both real and complex functions, but here we\r\n\r\n * restrict ourselves to real functions.\r\n\r\n * This class differs from {@link Muller_Solver} in the way it avoids complex\r\n\r\n * operations.</p><p>\r\n\r\n * Muller's original method would have function evaluation at complex point.\r\n\r\n * sin_ce our f(x) is real, we have to find ways to avoid that. Bracketing\r\n\r\n * condition is one way to go: by requiring bracketing in every iteration, * the newly computed approximation is guaranteed to be real.</p>\r\n\r\n * <p>\r\n\r\n * Normally Muller's method converges quadratically in the vicinity of a\r\n\r\n * zero, however it may be very slow in regions far away from zeros. For\r\n\r\n * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\r\n\r\n * bisection as a safety backup if it performs very poorly.</p>\r\n\r\n * <p>\r\n\r\n * The formulas here use divided differences directly.</p>\r\n\r\n *\r\n\r\n * @see Muller_Solver2\r\n\r\n */\r\n\r\nclass Muller_Solver extends Abstract_Univariate_Solver \r\n\r\n{\r\n\r\n\r\n\r\n    /** Default absolute accuracy. */\r\n\r\n    private static const double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a solver with default accuracy (1e-6).\r\n\r\n     */\r\n\r\n    public Muller_Solver() \r\n\r\n    {\r\n\r\n        this(DEFAULT_ABSOLUTE_ACCURACY);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Muller_Solver(double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(absolute_accuracy);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Construct a solver.\r\n\r\n     *\r\n\r\n     * @param relative_accuracy Relative accuracy.\r\n\r\n     * @param absolute_accuracy Absolute accuracy.\r\n\r\n     */\r\n\r\n    public Muller_Solver(double relative_accuracy, double absolute_accuracy) \r\n\r\n    {\r\n\r\n        super(relative_accuracy, absolute_accuracy);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    protected double do_solve()\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        const double min = get_min();\r\n\r\n        const double max = get_max();\r\n\r\n        const double initial = get_start_value();\r\n\r\n\r\n\r\n        const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n        verify_sequence(min, initial, max);\r\n\r\n\r\n\r\n        // check for zeros before verifying bracketing\r\n\r\n        const double f_min = compute_objective_value(min);\r\n\r\n        if (std::abs(f_min) < function_value_accuracy) \r\n\r\n        {\r\n\r\n            return min;\r\n\r\n        }\r\n\r\n        const double f_max = compute_objective_value(max);\r\n\r\n        if (std::abs(f_max) < function_value_accuracy) \r\n\r\n        {\r\n\r\n            return max;\r\n\r\n        }\r\n\r\n        const double f_initial = compute_objective_value(initial);\r\n\r\n        if (std::abs(f_initial) <  function_value_accuracy) \r\n\r\n        {\r\n\r\n            return initial;\r\n\r\n        }\r\n\r\n\r\n\r\n        verify_bracketing(min, max);\r\n\r\n\r\n\r\n        if (is_bracketing(min, initial)) \r\n\r\n        {\r\n\r\n            return solve(min, initial, f_min, f_initial);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return solve(initial, max, f_initial, f_max);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find a real root in the given interval.\r\n\r\n     *\r\n\r\n     * @param min Lower bound for the interval.\r\n\r\n     * @param max Upper bound for the interval.\r\n\r\n     * @param f_min function value at the lower bound.\r\n\r\n     * @param f_max function value at the upper bound.\r\n\r\n     * @return the point at which the function value is zero.\r\n\r\n     * @Math_Illegal_State_Exception if the allowed number of calls to\r\n\r\n     * the function to be solved has been exhausted.\r\n\r\n     */\r\n\r\n    private double solve(double min, const double& max,  double f_min, double f_max)\r\n\r\n        Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        const double relative_accuracy = get_relative_accuracy();\r\n\r\n        const double& absolute_accuracy = get_absolute_accuracy();\r\n\r\n        const double function_value_accuracy = get_function_value_accuracy();\r\n\r\n\r\n\r\n        // [x0, x2] is the bracketing interval in each iteration\r\n\r\n        // x1 is the last approximation and an interpolation point in (x0, x2)\r\n\r\n        // x is the root approximation and x1 for next round\r\n\r\n        // d01, d12, d012 are divided differences\r\n\r\n\r\n\r\n        double x0 = min;\r\n\r\n        double y0 = f_min;\r\n\r\n        double x2 = max;\r\n\r\n        double y2 = f_max;\r\n\r\n        double x1 = 0.5 * (x0 + x2);\r\n\r\n        double y1 = compute_objective_value(x1);\r\n\r\n\r\n\r\n        double oldx = INFINITY;\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n            // Muller's method employs quadratic interpolation through\r\n\r\n            // x0, x1, x2 and x is the zero of the interpolating parabola.\r\n\r\n            // Due to bracketing condition, this parabola must have two\r\n\r\n            // real roots and we choose one in [x0, x2] to be x.\r\n\r\n            const double d01 = (y1 - y0) / (x1 - x0);\r\n\r\n            const double d12 = (y2 - y1) / (x2 - x1);\r\n\r\n            const double d012 = (d12 - d01) / (x2 - x0);\r\n\r\n            const double c1 = d01 + (x1 - x0) * d012;\r\n\r\n            const double delta = c1 * c1 - 4 * y1 * d012;\r\n\r\n            const double xplus = x1 + (-2.0 * y1) / (c1 + std::sqrt(delta));\r\n\r\n            const double xminus = x1 + (-2.0 * y1) / (c1 - std::sqrt(delta));\r\n\r\n            // xplus and xminus are two roots of parabola and at least\r\n\r\n            // one of them should lie in (x0, x2)\r\n\r\n            const double x = is_sequence(x0, xplus, x2) ? xplus : xminus;\r\n\r\n            const double y = compute_objective_value(x);\r\n\r\n\r\n\r\n            // check for convergence\r\n\r\n            const double& tolerance = std::max(relative_accuracy * std::abs(x), absolute_accuracy);\r\n\r\n            if (std::abs(x - oldx) <= tolerance ||\r\n\r\n                std::abs(y) <= function_value_accuracy) \r\n\r\n                {\r\n\r\n                return x;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Bisect if convergence is too slow. Bisection would waste\r\n\r\n            // our calculation of x, hopefully it won't happen often.\r\n\r\n            // the real number equality test x == x1 is intentional and\r\n\r\n            // completes the proximity tests above it\r\n\r\n            bool bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\r\n\r\n                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\r\n\r\n                             (x == x1);\r\n\r\n            // prepare the bracketing interval for next iteration\r\n\r\n            if (!bisect) \r\n\r\n            {\r\n\r\n                x0 = x < x1 ? x0 : x1;\r\n\r\n                y0 = x < x1 ? y0 : y1;\r\n\r\n                x2 = x > x1 ? x2 : x1;\r\n\r\n                y2 = x > x1 ? y2 : y1;\r\n\r\n                x1 = x; y1 = y;\r\n\r\n                oldx = x;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                double xm = 0.5 * (x0 + x2);\r\n\r\n                double ym = compute_objective_value(xm);\r\n\r\n                if (FastMath.signum(y0) + FastMath.signum(ym) == 0.0) \r\n\r\n                {\r\n\r\n                    x2 = xm; y2 = ym;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    x0 = xm; y0 = ym;\r\n\r\n                }\r\n\r\n                x1 = 0.5 * (x0 + x2);\r\n\r\n                y1 = compute_objective_value(x1);\r\n\r\n                oldx = INFINITY;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n