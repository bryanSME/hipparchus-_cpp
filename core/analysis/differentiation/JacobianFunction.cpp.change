/*\r\n\r\n\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n\r\n\r\n * limitations under the License.\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.differentiation;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Multivariate_Matrix_Function;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Class representing the Jacobian of a multivariate vector function.\r\n\r\n\r\n\r\n * <p>\r\n\r\n\r\n\r\n * The rows iterate on the model functions while the columns iterate on the parameters; thus, * the numbers of rows is equal to the dimension of the underlying function vector\r\n\r\n\r\n\r\n * value and the number of columns is equal to the number of free parameters of\r\n\r\n\r\n\r\n * the underlying function.\r\n\r\n\r\n\r\n * </p>\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\nclass Jacobian_Function : Multivariate_Matrix_Function \r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Underlying vector-valued function. */\r\n\r\n\r\n\r\n    private const MultivariateDifferentiableVector_function f;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n\r\n\r\n     * @param f underlying vector-valued function\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public Jacobian_Function(const MultivariateDifferentiableVector_function f) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        this.f = f;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public std::vector<std::vector<double>> value(std::vector<double> point) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // set up parameters\r\n\r\n\r\n\r\n        const DS_Factory factory = DS_Factory(point.size(), 1);\r\n\r\n\r\n\r\n        const Derivative_Structure[] ds_x = Derivative_Structure[point.size()];\r\n\r\n\r\n\r\n        for (int i{}; i < point.size(); ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            ds_x[i] = factory.variable(i, point[i]);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // compute the derivatives\r\n\r\n\r\n\r\n        const Derivative_Structure[] ds_y = f.value(ds_x);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // extract the Jacobian\r\n\r\n\r\n\r\n        const std::vector<std::vector<double>> y = std::vector<double>(ds_y.size()][point.size()];\r\n\r\n\r\n\r\n        const std::vector<int> orders = int[point.size()];\r\n\r\n\r\n\r\n        for (int i{}; i < ds_y.size(); ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            for (int j{}; j < point.size(); ++j) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                orders[j] = 1;\r\n\r\n\r\n\r\n                y[i][j] = ds_y[i].get_partial_derivative(orders);\r\n\r\n\r\n\r\n                orders[j] = 0;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return y;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n