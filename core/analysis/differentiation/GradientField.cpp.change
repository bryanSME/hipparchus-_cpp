/*\r\n\r\n\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n\r\n\r\n * limitations under the License.\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.differentiation;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import java.util.concurrent.atomic.Atomic_Reference;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Field for {@link Gradient} instances.\r\n\r\n\r\n\r\n * @since 1.7\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\nclass Gradient_Field : Field<Gradient> \r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Array of all fields created so far. */\r\n\r\n\r\n\r\n    private static Atomic_Reference<Gradient_Field[]> fields = Atomic_Reference<>(null);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Zero constant. */\r\n\r\n\r\n\r\n    private const Gradient zero;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** One constant. */\r\n\r\n\r\n\r\n    private const Gradient one;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Associated factory for conversions to {@link Derivative_Structure}. */\r\n\r\n\r\n\r\n    private const DS_Factory factory;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Private constructor.\r\n\r\n\r\n\r\n     * @param parameters number of free parameters\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    private Gradient_Field(const int parameters) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        zero    = Gradient(0.0, std::vector<double>(parameters]);\r\n\r\n\r\n\r\n        one     = Gradient(1.0, std::vector<double>(parameters]);\r\n\r\n\r\n\r\n        factory = DS_Factory(parameters, 1);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the field for number of free parameters.\r\n\r\n\r\n\r\n     * @param parameters number of free parameters\r\n\r\n\r\n\r\n     * @return cached field\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public static Gradient_Field get_field(const int& parameters) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // get the cached fields\r\n\r\n\r\n\r\n        const Gradient_Field[] cache = fields.get();\r\n\r\n\r\n\r\n        if (cache != null && cache.size() > parameters && cache[parameters] != null) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            // the field has already been created\r\n\r\n\r\n\r\n            return cache[parameters];\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // we need to create a field\r\n\r\n\r\n\r\n        const int max_parameters = std::max(parameters, cache == null ? 0 : cache.size());\r\n\r\n\r\n\r\n        const Gradient_Field[] new_cache = Gradient_Field[max_parameters + 1];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (cache != null) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            // preserve the already created fields\r\n\r\n\r\n\r\n            System.arraycopy(cache, 0, new_cache, 0, cache.size());\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // create the field\r\n\r\n\r\n\r\n        new_cache[parameters] = Gradient_Field(parameters);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // atomically reset the cached fileds array\r\n\r\n\r\n\r\n        fields.compare_and_set(cache, new_cache);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return new_cache[parameters];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Gradient get_one() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return one;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Gradient get_zero() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return zero;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Class<Gradient> get_runtime_class() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Gradient.class;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the factory for converting to {@link Derivative_Structure}.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * This factory is used only for conversions. {@code Gradient} by\r\n\r\n\r\n\r\n     * itself does not rely at all on {@link DS_Factory}, {@link DS_Compiler}\r\n\r\n\r\n\r\n     * or {@link Derivative_Structure} for its computation. For this reason, * the factory here is hidden and this method is //package private, so\r\n\r\n\r\n\r\n     * only {@link Gradient#to_derivative_structure()} can call it on an\r\n\r\n\r\n\r\n     * existing {@link Gradient} instance\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @return factory for conversions\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    DS_Factory get_conversion_factory() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return factory;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public bool equals(const Object& other) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return this == other;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public int hash_code() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return 0x26ca1af0;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n