/*\r\n\r\n\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n\r\n\r\n * limitations under the License.\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n\r\n\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.differentiation;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Matrix_Function;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Vector_Function;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Univariate functions differentiator using finite differences.\r\n\r\n\r\n\r\n * <p>\r\n\r\n\r\n\r\n * This class creates some wrapper objects around regular\r\n\r\n\r\n\r\n * {@link Univariate_Function univariate functions} (or {@link\r\n\r\n\r\n\r\n * Univariate_Vector_Function univariate vector functions} or {@link\r\n\r\n\r\n\r\n * Univariate_Matrix_Function univariate matrix functions}). These\r\n\r\n\r\n\r\n * wrapper objects compute derivatives in addition to function\r\n\r\n\r\n\r\n * values.\r\n\r\n\r\n\r\n * </p>\r\n\r\n\r\n\r\n * <p>\r\n\r\n\r\n\r\n * The wrapper objects work by calling the underlying function on\r\n\r\n\r\n\r\n * a sampling grid around the current point and performing polynomial\r\n\r\n\r\n\r\n * interpolation. A finite differences scheme with n points is\r\n\r\n\r\n\r\n * theoretically able to compute derivatives up to order n-1, but\r\n\r\n\r\n\r\n * it is generally better to have a slight margin. The step size must\r\n\r\n\r\n\r\n * also be small enough in order for the polynomial approximation to\r\n\r\n\r\n\r\n * be good in the current point neighborhood, but it should not be too\r\n\r\n\r\n\r\n * small because numerical instability appears quickly (there are several\r\n\r\n\r\n\r\n * differences of close points). Choosing the number of points and\r\n\r\n\r\n\r\n * the step size is highly problem dependent.\r\n\r\n\r\n\r\n * </p>\r\n\r\n\r\n\r\n * <p>\r\n\r\n\r\n\r\n * As an example of good and bad settings, lets consider the quintic\r\n\r\n\r\n\r\n * polynomial function {@code f(x) = (x-1)*(x-0.5)*x*(x+0.5)*(x+1)}.\r\n\r\n\r\n\r\n * sin_ce it is a polynomial, finite differences with at least 6 points\r\n\r\n\r\n\r\n * should theoretically recover the exact same polynomial and hence\r\n\r\n\r\n\r\n * compute accurate derivatives for any order. However, due to numerical\r\n\r\n\r\n\r\n * errors, we get the following results for a 7 points finite differences\r\n\r\n\r\n\r\n * for abscissae in the [-10, 10] range:\r\n\r\n\r\n\r\n * <ul>\r\n\r\n\r\n\r\n *   <li>step size = 0.25, second order derivative error about 9.97e-10</li>\r\n\r\n\r\n\r\n *   <li>step size = 0.25, fourth order derivative error about 5.43e-8</li>\r\n\r\n\r\n\r\n *   <li>step size = 1.0e-6, second order derivative error about 148</li>\r\n\r\n\r\n\r\n *   <li>step size = 1.0e-6, fourth order derivative error about 6.35e+14</li>\r\n\r\n\r\n\r\n * </ul>\r\n\r\n\r\n\r\n * <p>\r\n\r\n\r\n\r\n * This example shows that the small step size is really bad, even simply\r\n\r\n\r\n\r\n * for second order derivative!</p>\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\nclass Finite_Differences_Differentiator\r\n\r\n\r\n\r\n    : Univariate_Function_differentiator, Univariate_Vector_Function_differentiator, Univariate_Matrix_Function_differentiator\r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Serializable UID. */\r\n\r\n\r\n\r\n    private static const long serial_version_uid = 20120917L;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Number of points to use. */\r\n\r\n\r\n\r\n    private const int& nb_points;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Step size. */\r\n\r\n\r\n\r\n    private const double step_size;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Half sample span. */\r\n\r\n\r\n\r\n    private const double half_sample_span;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Lower bound for independent variable. */\r\n\r\n\r\n\r\n    private const double t_min;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Upper bound for independent variable. */\r\n\r\n\r\n\r\n    private const double t_max;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n\r\n\r\n     * Build a differentiator with number of points and step size when independent variable is unbounded.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * Beware that wrong settings for the finite differences differentiator\r\n\r\n\r\n\r\n     * can lead to highly unstable and inaccurate results, especially for\r\n\r\n\r\n\r\n     * high derivation orders. Using very small step sizes is often a\r\n\r\n\r\n\r\n     * <em>bad</em> idea.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @param nb_points number of points to use\r\n\r\n\r\n\r\n     * @param step_size step size (gap between each point)\r\n\r\n\r\n\r\n     * @exception  if {@code stepsize <= 0} (note that\r\n\r\n\r\n\r\n     * {@link } extends {@link })\r\n\r\n\r\n\r\n     * @exception  {@code nb_point <= 1}\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public Finite_Differences_Differentiator(const int& nb_points, const double step_size)\r\n\r\n\r\n\r\n         \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n        this(nb_points, step_size, -INFINITY, INFINITY);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n\r\n\r\n     * Build a differentiator with number of points and step size when independent variable is bounded.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * When the independent variable is bounded (t_lower &lt; t &lt; t_upper), the sampling\r\n\r\n\r\n\r\n     * points used for differentiation will be adapted to ensure the constraint holds\r\n\r\n\r\n\r\n     * even near the boundaries. This means the sample will not be centered anymore in\r\n\r\n\r\n\r\n     * these cases. At an extreme case, computing derivatives exactly at the lower bound\r\n\r\n\r\n\r\n     * will lead the sample to be entirely on the right side of the derivation point.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * Note that the boundaries are considered to be excluded for function evaluation.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * Beware that wrong settings for the finite differences differentiator\r\n\r\n\r\n\r\n     * can lead to highly unstable and inaccurate results, especially for\r\n\r\n\r\n\r\n     * high derivation orders. Using very small step sizes is often a\r\n\r\n\r\n\r\n     * <em>bad</em> idea.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @param nb_points number of points to use\r\n\r\n\r\n\r\n     * @param step_size step size (gap between each point)\r\n\r\n\r\n\r\n     * @param t_lower lower bound for independent variable (may be {@code -INFINITY}\r\n\r\n\r\n\r\n     * if there are no lower bounds)\r\n\r\n\r\n\r\n     * @param t_upper upper bound for independent variable (may be {@code INFINITY}\r\n\r\n\r\n\r\n     * if there are no upper bounds)\r\n\r\n\r\n\r\n     * @exception  if {@code stepsize <= 0} (note that\r\n\r\n\r\n\r\n     * {@link } extends {@link })\r\n\r\n\r\n\r\n     * @exception  {@code nb_point <= 1}\r\n\r\n\r\n\r\n     * @exception  {@code step_size * (nb_points - 1) >= t_upper - t_lower}\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public Finite_Differences_Differentiator(const int& nb_points, const double step_size, const double t_lower, const double t_upper)\r\n\r\n\r\n\r\n             \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (nb_points <= 1) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL, step_size, 1);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        this.nb_points = nb_points;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (step_size <= 0) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_SMALL_BOUND_EXCLUDED, step_size, 0);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        this.step_size = step_size;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        half_sample_span = 0.5 * step_size * (nb_points - 1);\r\n\r\n\r\n\r\n        if (2 * half_sample_span >= t_upper - t_lower) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, 2 * half_sample_span, t_upper - t_lower);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        const double safety = FastMath.ulp(half_sample_span);\r\n\r\n\r\n\r\n        this.t_min = t_lower + half_sample_span + safety;\r\n\r\n\r\n\r\n        this.t_max = t_upper - half_sample_span - safety;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n\r\n\r\n     * Get the number of points to use.\r\n\r\n\r\n\r\n     * @return number of points to use\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public int get_nb_points() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return nb_points;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n\r\n\r\n     * Get the step size.\r\n\r\n\r\n\r\n     * @return step size\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public double get_step_size() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return step_size;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n\r\n\r\n     * Evaluate derivatives from a sample.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * Evaluation is done using divided differences.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @param t evaluation abscissa value and derivatives\r\n\r\n\r\n\r\n     * @param t0 first sample point abscissa\r\n\r\n\r\n\r\n     * @param y function values sample {@code y[i] = f(t[i]) = f(t0 + i * step_size)}\r\n\r\n\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n\r\n\r\n     * @return value and derivatives at {@code t}\r\n\r\n\r\n\r\n     * @exception  if the requested derivation order\r\n\r\n\r\n\r\n     * is larger or equal to the number of points\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    private <T extends Derivative<T>> T evaluate(const T t, const double t0, const std::vector<double> y)\r\n\r\n\r\n\r\n         \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // create divided differences diagonal arrays\r\n\r\n\r\n\r\n        const std::vector<double> top    = std::vector<double>(nb_points];\r\n\r\n\r\n\r\n        const std::vector<double> bottom = std::vector<double>(nb_points];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        for (int i{}; i < nb_points; ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            // update the bottom diagonal of the divided differences array\r\n\r\n\r\n\r\n            bottom[i] = y[i];\r\n\r\n\r\n\r\n            for (int j{ 1 }; j <= i; ++j) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                bottom[i - j] = (bottom[i - j + 1] - bottom[i - j]) / (j * step_size);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            // update the top diagonal of the divided differences array\r\n\r\n\r\n\r\n            top[i] = bottom[0];\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // evaluate interpolation polynomial (represented by top diagonal) at t\r\n\r\n\r\n\r\n        T interpolation = t.get_field().get_zero();\r\n\r\n\r\n\r\n        T monomial      = null;\r\n\r\n\r\n\r\n        for (int i{}; i < nb_points; ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            if (i == 0) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                // start with monomial(t) = 1\r\n\r\n\r\n\r\n                monomial = t.get_field().get_one();\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                // monomial(t) = (t - t0) * (t - t1) * ... * (t - t(i-1))\r\n\r\n\r\n\r\n                const T delta_x = t.subtract(t0 + (i - 1) * step_size);\r\n\r\n\r\n\r\n                monomial = monomial.multiply(delta_x);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            interpolation = interpolation.add(monomial.multiply(top[i]));\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return interpolation;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n\r\n\r\n     * <p>The returned object cannot compute derivatives to arbitrary orders. The\r\n\r\n\r\n\r\n     * value function will throw a {@link } if the requested\r\n\r\n\r\n\r\n     * derivation order is larger or equal to the number of points.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Differentiable_Function differentiate(const Univariate_Function function) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Differentiable_Function() \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public double value(const double& x)  \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                return function.value(x);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public <T extends Derivative<T>> T value(T t)\r\n\r\n\r\n\r\n                 \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // check we can achieve the requested derivation order with the sample\r\n\r\n\r\n\r\n                if (t.get_order() >= nb_points) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    throw (Localized_Core_Formats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, t.get_order(), nb_points);\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample position, trying to be centered if possible\r\n\r\n\r\n\r\n                const double t0 = std::max(std::min(t.get_value(), t_max), t_min) - half_sample_span;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample points\r\n\r\n\r\n\r\n                const std::vector<double> y = std::vector<double>(nb_points];\r\n\r\n\r\n\r\n                for (int i{}; i < nb_points; ++i) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    y[i] = function.value(t0 + i * step_size);\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // evaluate derivatives\r\n\r\n\r\n\r\n                return evaluate(t, t0, y);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        };\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n\r\n\r\n     * <p>The returned object cannot compute derivatives to arbitrary orders. The\r\n\r\n\r\n\r\n     * value function will throw a {@link } if the requested\r\n\r\n\r\n\r\n     * derivation order is larger or equal to the number of points.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Differentiable_Vector_Function differentiate(const Univariate_Vector_Function function) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Differentiable_Vector_Function() \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public std::vector<double>value(const double& x)  \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                return function.value(x);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public <T extends Derivative<T>> std::vector<T> value(T t)\r\n\r\n\r\n\r\n                 \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // check we can achieve the requested derivation order with the sample\r\n\r\n\r\n\r\n                if (t.get_order() >= nb_points) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    throw (Localized_Core_Formats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, t.get_order(), nb_points);\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample position, trying to be centered if possible\r\n\r\n\r\n\r\n                const double t0 = std::max(std::min(t.get_value(), t_max), t_min) - half_sample_span;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample points\r\n\r\n\r\n\r\n                std::vector<std::vector<double>> y = null;\r\n\r\n\r\n\r\n                for (int i{}; i < nb_points; ++i) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    const std::vector<double>& v = function.value(t0 + i * step_size);\r\n\r\n\r\n\r\n                    if (i == 0) \r\n\r\n\r\n\r\n                    {\r\n\r\n\r\n\r\n                        y = std::vector<double>(v.size()][nb_points];\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                    for (int j{}; j < v.size(); ++j) \r\n\r\n\r\n\r\n                    {\r\n\r\n\r\n\r\n                        y[j][i] = v[j];\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // evaluate derivatives\r\n\r\n\r\n\r\n                const std::vector<T> value = Math_Arrays::build_array(t.get_field(), y.size());\r\n\r\n\r\n\r\n                for (int j{}; j < value.size(); ++j) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    value[j] = evaluate(t, t0, y[j]);\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                return value;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        };\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n\r\n\r\n     * <p>The returned object cannot compute derivatives to arbitrary orders. The\r\n\r\n\r\n\r\n     * value function will throw a {@link } if the requested\r\n\r\n\r\n\r\n     * derivation order is larger or equal to the number of points.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Differentiable_Matrix_Function differentiate(const Univariate_Matrix_Function function) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Differentiable_Matrix_Function() \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public std::vector<std::vector<double>>  value(const double& x)  \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                return function.value(x);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n\r\n\r\n            //override\r\n\r\n\r\n\r\n            public <T extends Derivative<T>> std::vector<std::vector<T>> value(T t)\r\n\r\n\r\n\r\n                 \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // check we can achieve the requested derivation order with the sample\r\n\r\n\r\n\r\n                if (t.get_order() >= nb_points) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    throw (Localized_Core_Formats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, t.get_order(), nb_points);\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample position, trying to be centered if possible\r\n\r\n\r\n\r\n                const double t0 = std::max(std::min(t.get_value(), t_max), t_min) - half_sample_span;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute sample points\r\n\r\n\r\n\r\n                std::vector<std::vector<double>>[] y = null;\r\n\r\n\r\n\r\n                for (int i{}; i < nb_points; ++i) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    const std::vector<std::vector<double>> v = function.value(t0 + i * step_size);\r\n\r\n\r\n\r\n                    if (i == 0) \r\n\r\n\r\n\r\n                    {\r\n\r\n\r\n\r\n                        y = std::vector<double>(v.size()][v[0].size()][nb_points];\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                    for (int j{}; j < v.size(); ++j) \r\n\r\n\r\n\r\n                    {\r\n\r\n\r\n\r\n                        for (int k{}; k < v[j].size(); ++k) \r\n\r\n\r\n\r\n                        {\r\n\r\n\r\n\r\n                            y[j][k][i] = v[j][k];\r\n\r\n\r\n\r\n                        }\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // evaluate derivatives\r\n\r\n\r\n\r\n                const std::vector<std::vector<T>> value = Math_Arrays::build_array(t.get_field(), y.size(), y[0].size());\r\n\r\n\r\n\r\n                for (int j{}; j < value.size(); ++j) \r\n\r\n\r\n\r\n                {\r\n\r\n\r\n\r\n                    for (int k{}; k < y[j].size(); ++k) \r\n\r\n\r\n\r\n                    {\r\n\r\n\r\n\r\n                        value[j][k] = evaluate(t, t0, y[j][k]);\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                return value;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        };\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n