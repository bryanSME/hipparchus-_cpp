/*\r\n\r\n\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n\r\n\r\n * limitations under the License.\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.analysis.differentiation;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import java.util.Hash_Map;\r\n\r\n\r\n\r\n//import java.util.Map;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Field for {@link Field_Univariate_Derivative_2} instances.\r\n\r\n\r\n\r\n * @param <T> the type of the function parameters and value\r\n\r\n\r\n\r\n * @since 1.7\r\n\r\n\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>class Field_Univariate_Derivative_2_Field : Field<Field_Univariate_Derivative_2<T>> \r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Cached fields. */\r\n\r\n\r\n\r\n    private static const Map<Field<?>, Field_Univariate_Derivative_2_Field<?>> CACHE = Hash_Map<>();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Zero constant. */\r\n\r\n\r\n\r\n    private const Field_Univariate_Derivative_2<T> zero;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** One constant. */\r\n\r\n\r\n\r\n    private const Field_Univariate_Derivative_2<T> one;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Associated factory for conversions to {@link Field_Derivative_Structure}. */\r\n\r\n\r\n\r\n    private const FDS_Factory<T> factory;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Private constructor for populating the cache.\r\n\r\n\r\n\r\n     * @param value_field field for the function parameters and value\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    private Field_Univariate_Derivative_2_Field(const Field<T> value_field) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        zero    = Field_Univariate_Derivative_2<>(value_field.get_zero(), value_field.get_zero(), value_field.get_zero());\r\n\r\n\r\n\r\n        one     = Field_Univariate_Derivative_2<>(value_field.get_one(), value_field.get_zero(), value_field.get_zero());\r\n\r\n\r\n\r\n        factory = FDS_Factory<>(value_field, 1, 2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the univariate derivative field corresponding to a value field.\r\n\r\n\r\n\r\n     * @param value_field field for the function parameters and value\r\n\r\n\r\n\r\n     * @param <T> the type of the function parameters and value\r\n\r\n\r\n\r\n     * @return univariate derivative field\r\n\r\n\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>    public static  Field_Univariate_Derivative_2_Field<T> get_univariate__derivative_2__field(const Field<T> value_field) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        synchronized (CACHE) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            Field_Univariate_Derivative_2_Field<?> cached = CACHE.get(value_field);\r\n\r\n\r\n\r\n            if (cached == null) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                cached = Field_Univariate_Derivative_2_Field<>(value_field);\r\n\r\n\r\n\r\n                CACHE.put(value_field, cached);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            //@Suppress_Warnings("unchecked")\r\n\r\n\r\n\r\n            const Field_Univariate_Derivative_2_Field<T> t_cached = (Field_Univariate_Derivative_2_Field<T>) cached;\r\n\r\n\r\n\r\n            return t_cached;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Field_Univariate_Derivative_2<T> get_one() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return one;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Field_Univariate_Derivative_2<T> get_zero() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return zero;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the factory for converting to {@link Derivative_Structure}.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * This factory is used only for conversions. {@code Univariate_Derivative_2} by\r\n\r\n\r\n\r\n     * itself does not rely at all on {@link DS_Factory}, {@link DS_Compiler}\r\n\r\n\r\n\r\n     * or {@link Derivative_Structure} for its computation. For this reason, * the factory here is hidden and this method is //package private, so\r\n\r\n\r\n\r\n     * only {@link Univariate_Derivative_2#to_derivative_structure()} can call it on an\r\n\r\n\r\n\r\n     * existing {@link Univariate_Derivative_2} instance\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @return factory for conversions\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    FDS_Factory<T> get_conversion_factory() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return factory;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Class<Field_Univariate_Derivative_2<T>> get_runtime_class() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return (Class<Field_Univariate_Derivative_2<T>>) zero.get_class();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public bool equals(const Object& other) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return this == other;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public int hash_code() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return 0x3f4b793e;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n