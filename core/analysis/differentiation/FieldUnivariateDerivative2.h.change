/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.differentiation;\r\n\r\n#include <cmath>\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n//import org.hipparchus.util.Field_Sinh_Cosh;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/** Class representing both the value and the differentials of a function.\r\n\r\n * <p>This class is a stripped-down version of {@link Field_Derivative_Structure}\r\n\r\n * with only one {@link Field_Derivative_Structure#get_free_parameters() free parameter}\r\n\r\n * and {@link Field_Derivative_Structure#get_order() derivation order} limited to two.\r\n\r\n * It should have less overhead than {@link Field_Derivative_Structure} in its domain.</p>\r\n\r\n * <p>This class is an implementation of Rall's numbers. Rall's numbers are an\r\n\r\n * extension to the real numbers used throughout mathematical expressions; they hold\r\n\r\n * the derivative together with the value of a function.</p>\r\n\r\n * <p>{@link Field_Univariate_Derivative_2} instances can be used directly thanks to\r\n\r\n * the arithmetic operators to the mathematical functions provided as\r\n\r\n * methods by this class (+, -, *, /, %, sin, cos ...).</p>\r\n\r\n * <p>Implementing complex expressions by hand using these classes is\r\n\r\n * a tedious and error-prone task but has the advantage of having no limitation\r\n\r\n * on the derivation order despite not requiring users to compute the derivatives by\r\n\r\n * themselves.</p>\r\n\r\n * <p>Instances of this class are guaranteed to be immutable.</p>\r\n\r\n * @param <T> the type of the function parameters and value\r\n\r\n * @see Derivative_Structure\r\n\r\n * @see Univariate_Derivative_1\r\n\r\n * @see Univariate_Derivative_2\r\n\r\n * @see Gradient\r\n\r\n * @see Field_Derivative_Structure\r\n\r\n * @see Field_Univariate_Derivative_1\r\n\r\n * @see Field_Gradient\r\n\r\n * @since 1.7\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>class Field_Univariate_Derivative_2 extends Field_Univariate_Derivative<T, Field_Univariate_Derivative_2<T>> \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Value of the function. */\r\n\r\n    const T my_f0;\r\n\r\n\r\n\r\n    /** First derivative of the function. */\r\n\r\n    const T my_f1;\r\n\r\n\r\n\r\n    /** Second derivative of the function. */\r\n\r\n    const T my_f2;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Build an instance with values and derivative.\r\n\r\n     * @param my_f0 value of the function\r\n\r\n     * @param my_f1 first derivative of the function\r\n\r\n     * @param my_f2 second derivative of the function\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2(const T& my_f0, const T& my_f1, const T& my_f2) : my_f0{ my_f0 }, my_f1{ m1 }, my_f2{ m2 } {};\r\n\r\n\r\n\r\n    /** Build an instance from a {@link Derivative_Structure}.\r\n\r\n     * @param ds derivative structure\r\n\r\n     * @exception  if either {@code ds} parameters\r\n\r\n     * is not 1 or {@code ds} order is not 2\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2(const Field_Derivative_Structure<T>& ds)  \r\n\r\n    {\r\n\r\n        Math_Utils::check_dimension(ds.get_free_parameters(), 1);\r\n\r\n        Math_Utils::check_dimension(ds.get_order(), 2);\r\n\r\n       my_f0 = ds.get_value();\r\n\r\n        my_f1 = ds.get_partial_derivative(1);\r\n\r\n        my_f2 = ds.get_partial_derivative(2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> new_instance(const double& value) \r\n\r\n    {\r\n\r\n        const T zero = my_f0.get_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(zero.new_instance(value), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    double get_real() const\r\n\r\n    {\r\n\r\n        return get_value().get_real();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the value part of the univariate derivative.\r\n\r\n     * @return value part of the univariate derivative\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    T get_value() const\r\n\r\n    {\r\n\r\n        return my_f0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a derivative from the univariate derivative.\r\n\r\n     * @param n derivation order (must be between 0 and {@link #get_order()}, both inclusive)\r\n\r\n     * @return n<sup>th</sup> derivative, or {@code NaN} if n is\r\n\r\n     * either negative or strictly larger than {@link #get_order()}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    T get_derivative(const int& n) const\r\n\r\n    {\r\n\r\n        switch (n) \r\n\r\n        {\r\n\r\n            case 0 :\r\n\r\n                return my_f0;\r\n\r\n            case 1 :\r\n\r\n                return my_f1;\r\n\r\n            case 2 :\r\n\r\n                return my_f2;\r\n\r\n            default :\r\n\r\n                throw (Localized_Core_Formats.DERIVATION_ORDER_NOT_ALLOWED, n);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the derivation order.\r\n\r\n     * @return derivation order\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    int get_order() const\r\n\r\n    {\r\n\r\n        return 2;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the first derivative.\r\n\r\n     * @return first derivative\r\n\r\n     * @see #get_value()\r\n\r\n     */\r\n\r\n    T get_first_derivative() const\r\n\r\n    {\r\n\r\n        return my_f1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the second derivative.\r\n\r\n     * @return second derivative\r\n\r\n     * @see #get_value()\r\n\r\n     * @see #get_first_derivative()\r\n\r\n     */\r\n\r\n    T get_second_derivative() const\r\n\r\n    {\r\n\r\n        return my_f2;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the {@link Field} the value and parameters of the function belongs to.\r\n\r\n     * @return {@link Field} the value and parameters of the function belongs to\r\n\r\n     */\r\n\r\n    Field<T> get_value_field() const\r\n\r\n    {\r\n\r\n        return my_f0.get_field();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Convert the instance to a {@link Field_Derivative_Structure}.\r\n\r\n     * @return derivative structure with same value and derivative as the instance\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Derivative_Structure<T> to_derivative_structure() \r\n\r\n    {\r\n\r\n        return get_field().get_conversion_factory().build(my_f0, my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** '+' operator.\r\n\r\n     * @param a right hand side parameter of the operator\r\n\r\n     * @return this+a\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> add(const T& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.add(a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> add(const double& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.add(a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> add(const Field_Univariate_Derivative_2<T>& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.add(a.f0), my_f1.add(a.f1), my_f2.add(a.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** '-' operator.\r\n\r\n     * @param a right hand side parameter of the operator\r\n\r\n     * @return this-a\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> subtract(const T& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.subtract(a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> subtract(const double& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.subtract(a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> subtract(const Field_Univariate_Derivative_2<T>& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.subtract(a.f0), my_f1.subtract(a.f1), my_f2.subtract(a.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** '&times;' operator.\r\n\r\n     * @param a right hand side parameter of the operator\r\n\r\n     * @return this&times;a\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> multiply(const T& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(a), my_f1.multiply(a), my_f2.multiply(a));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> multiply(const int& n) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(n), my_f1.multiply(n), my_f2.multiply(n));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> multiply(const double& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(a), my_f1.multiply(a), my_f2.multiply(a));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> multiply(const Field_Univariate_Derivative_2<T>& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(a.f0), a.f0.linear_combination(my_f1, a.f0, my_f0, a.f1), a.f0.linear_combination(f2, a.f0, my_f1.add(my_f1), a.f1, my_f0, a.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** '&divide;' operator.\r\n\r\n     * @param a right hand side parameter of the operator\r\n\r\n     * @return this&divide;a\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> divide(const T& a) \r\n\r\n    {\r\n\r\n        const T inv1 = a.reciprocal();\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(inv1), my_f1.multiply(inv1), my_f2.multiply(inv1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> divide(const double& a) \r\n\r\n    {\r\n\r\n        const double inv1 = 1.0 / a;\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(inv1), my_f1.multiply(inv1), my_f2.multiply(inv1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> divide(const Field_Univariate_Derivative_2<T>& a) \r\n\r\n    {\r\n\r\n        const T inv1 = a.f0.reciprocal();\r\n\r\n        const T inv2 = inv1.multiply(inv1);\r\n\r\n        const T inv3 = inv1.multiply(inv2);\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.multiply(inv1), a.f0.linear_combination(my_f1, a.f0, my_f0.negate(), a.f1).multiply(inv2), a.f0.linear_combination(f2, a.f0.multiply(a.f0), my_f1.multiply(-2), a.f0.multiply(a.f1), my_f0.add(my_f0), a.f1.multiply(a.f1), my_f0.negate(), a.f0.multiply(a.f2)).multiply(inv3));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** IEEE remainder operator.\r\n\r\n     * @param a right hand side parameter of the operator\r\n\r\n     * @return this - n &times; a where n is the closest integer to this/a\r\n\r\n     * (the even integer is chosen for n if this/a is halfway between two integers)\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> remainder(const T& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(std::remainder(my_f0, a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> remainder(const double& a) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(std::remainder(my_f0, a), my_f1, my_f2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> remainder(const Field_Univariate_Derivative_2<T>& a) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute k such that lhs % rhs = lhs - k rhs\r\n\r\n        const T rem = std::remainder(my_f0, a.f0);\r\n\r\n        const T k   = FastMath.rint(my_f0.subtract(rem).divide(a.f0));\r\n\r\n\r\n\r\n        return Field_Univariate_Derivative_2<>(rem, my_f1.subtract(k.multiply(a.f1)), my_f2.subtract(k.multiply(a.f2)));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> negate() \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(my_f0.negate(), my_f1.negate(), my_f2.negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> abs() \r\n\r\n    {\r\n\r\n        if (Double.double_to_long_bits(my_f0.get_real()) < 0) \r\n\r\n        {\r\n\r\n            // we use the bits representation to also handle -0.0\r\n\r\n            return negate();\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> ceil() \r\n\r\n    {\r\n\r\n        const T zero = my_f0.get_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.ceil(my_f0), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> floor() \r\n\r\n    {\r\n\r\n        const T zero = my_f0.get_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(std::floor(my_f0), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> rint() \r\n\r\n    {\r\n\r\n        const T zero = my_f0.get_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.rint(my_f0), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> sign() \r\n\r\n    {\r\n\r\n        const T zero = my_f0.get_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.sign(my_f0), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the instance with the sign of the argument.\r\n\r\n     * A NaN {@code sign} argument is treated as positive.\r\n\r\n     *\r\n\r\n     * @param sign the sign for the returned value\r\n\r\n     * @return the instance with the same sign as the {@code sign} argument\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> copy_sign(const T& sign) \r\n\r\n    {\r\n\r\n        long m = Double.double_to_long_bits(my_f0.get_real());\r\n\r\n        long s = Double.double_to_long_bits(sign.get_real());\r\n\r\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n        return negate(); // flip sign\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> copy_sign(const Field_Univariate_Derivative_2<T>& sign) \r\n\r\n    {\r\n\r\n        long m = Double.double_to_long_bits(my_f0.get_real());\r\n\r\n        long s = Double.double_to_long_bits(sign.f0.get_real());\r\n\r\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n        return negate(); // flip sign\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> copy_sign(const double sign) \r\n\r\n    {\r\n\r\n        long m = Double.double_to_long_bits(my_f0.get_real());\r\n\r\n        long s = Double.double_to_long_bits(sign);\r\n\r\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\r\n\r\n            return this;\r\n\r\n        }\r\n\r\n        return negate(); // flip sign\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int get_exponent() \r\n\r\n    {\r\n\r\n        return FastMath.get_exponent(my_f0.get_real());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> scalb(const int& n) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(std::scalbn(my_f0, n), std::scalbn(my_f1, n), std::scalbn(f2, n));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * The {@code ulp} function is a step function, hence all its derivatives are 0.\r\n\r\n     * </p>\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> ulp() \r\n\r\n    {\r\n\r\n        const T zero = get_value_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.ulp(my_f0), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> hypot(const Field_Univariate_Derivative_2<T>& y) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (Double.std::isinfinite(my_f0.get_real()) || Double.std::isinfinite(y.f0.get_real())) \r\n\r\n        {\r\n\r\n            const T zero = my_f0.get_field().get_zero();\r\n\r\n            return Field_Univariate_Derivative_2<>(my_f0.new_instance(INFINITY), zero, zero);\r\n\r\n        }\r\n\r\n        if (std::isnan(my_f0.get_real()) || std::isnan(y.f0.get_real())) \r\n\r\n        {\r\n\r\n            const T zero = my_f0.get_field().get_zero();\r\n\r\n            return Field_Univariate_Derivative_2<>(my_f0.new_instance(Double.NaN), zero, zero);\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        const int exp_x = get_exponent();\r\n\r\n        const int exp_y = y.get_exponent();\r\n\r\n        if (exp_x > exp_y + 27) \r\n\r\n        {\r\n\r\n            // y is neglectible with respect to x\r\n\r\n            return abs();\r\n\r\n        }\r\n\r\n        if (exp_y > exp_x + 27) \r\n\r\n        {\r\n\r\n            // x is neglectible with respect to y\r\n\r\n            return y.abs();\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        // find an intermediate scale to avoid both overflow and underflow\r\n\r\n        const int middle_exp = (exp_x + exp_y) / 2;\r\n\r\n\r\n\r\n        // scale parameters without losing precision\r\n\r\n        const Field_Univariate_Derivative_2<T>& scaled_x = scalb(-middle_exp);\r\n\r\n        const Field_Univariate_Derivative_2<T>& scaled_y = y.scalb(-middle_exp);\r\n\r\n\r\n\r\n        // compute scaled hypotenuse\r\n\r\n        const Field_Univariate_Derivative_2<T>& scaled_h = scaled_x.multiply(scaled_x).add(scaled_y.multiply(scaled_y)).sqrt();\r\n\r\n\r\n\r\n        // remove scaling\r\n\r\n        return scaled_h.scalb(middle_exp);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> reciprocal() \r\n\r\n    {\r\n\r\n        const T inv1 = my_f0.reciprocal();\r\n\r\n        const T inv2 = inv1.multiply(inv1);\r\n\r\n        const T inv3 = inv1.multiply(inv2);\r\n\r\n        return Field_Univariate_Derivative_2<>(inv1, my_f1.negate().multiply(inv2), my_f0.linear_combination(my_f1.add(my_f1), my_f1, my_f0.negate(), my_f2).multiply(inv3));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute composition of the instance by a function.\r\n\r\n     * @param g0 value of the function at the current point (i.e. at {@code g(get_value())})\r\n\r\n     * @param g1 first derivative of the function at the current point (i.e. at {@code g'(get_value())})\r\n\r\n     * @param g2 second derivative of the function at the current point (i.e. at {@code g''(get_value())})\r\n\r\n     * @return g(this)\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> compose(const T& g0, const T& g1, const T& g2) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(\r\n\r\n            g0, g1.multiply(my_f1),\r\n\r\n            my_f0.linear_combination(g1, my_f2, g2, my_f1.multiply(my_f1))\r\n\r\n        );\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> sqrt() \r\n\r\n    {\r\n\r\n        const T s = std::sqrt(my_f0);\r\n\r\n        return compose(s, s.add(s).reciprocal(), s.multiply(-4).multiply(my_f0).reciprocal());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> cbrt() \r\n\r\n    {\r\n\r\n        const T c  = std::cbrt(my_f0);\r\n\r\n        const T c2 = c.multiply(c);\r\n\r\n        return compose(c, c2.multiply(3).reciprocal(), c2.multiply(4.5).multiply(my_f0).reciprocal());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> root_n(const int& n) \r\n\r\n    {\r\n\r\n        if (n == 2) \r\n\r\n        {\r\n\r\n            return sqrt();\r\n\r\n        }\r\n\r\n        if (n == 3) \r\n\r\n        {\r\n\r\n            return cbrt();\r\n\r\n        }\r\n\r\n\r\n\r\n        const T r = std::pow(my_f0, 1.0 / n);\r\n\r\n        const T z = std::pow(r, n - 1).multiply(n);\r\n\r\n        return compose(r, z.reciprocal(), z.multiply(z).multiply(r).reciprocal().multiply(1 -n));\r\n\r\n       \r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2_Field<T> get_field() \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2_Field.get_univariate__derivative_2__field(my_f0.get_field());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute a<sup>x</sup> where a is a double and x a {@link Field_Univariate_Derivative_2}\r\n\r\n     * @param a number to exponentiate\r\n\r\n     * @param x power to apply\r\n\r\n     * @param <T> the type of the function parameters and value\r\n\r\n     * @return a<sup>x</sup>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>    static  Field_Univariate_Derivative_2<T> pow(const double& a, const Field_Univariate_Derivative_2<T>& x) \r\n\r\n    {\r\n\r\n        if (a == 0) \r\n\r\n        {\r\n\r\n            return x.get_field().get_zero();\r\n\r\n        }\r\n\r\n\r\n\r\n        const T      a_x    = std::pow(x.f0.new_instance(a), x.f0);\r\n\r\n        const double ln_a   = std::log(a);\r\n\r\n        const T      a_xln_a = a_x.multiply(ln_a);\r\n\r\n        return Field_Univariate_Derivative_2<>(a_x, a_xln_a.multiply(x.f1), a_xln_a.multiply(x.f1.multiply(x.f1).multiply(ln_a).add(x.f2)));\r\n\r\n        \r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> pow(const double& p) \r\n\r\n    {\r\n\r\n        if (p == 0) \r\n\r\n        {\r\n\r\n            return get_field().get_one();\r\n\r\n        }\r\n\r\n\r\n\r\n        const T my_f0_pm2 = std::pow(my_f0, p - 2);\r\n\r\n        const T my_f0_pm1 = my_f0_pm2.multiply(my_f0);\r\n\r\n        const T my_f0P   = my_f0_pm1.multiply(my_f0);\r\n\r\n        return compose(my_f0P, my_f0_pm1.multiply(p), my_f0_pm2.multiply(p * (p - 1)));\r\n\r\n        \r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> pow(const int& n) \r\n\r\n    {\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            return get_field().get_one();\r\n\r\n        }\r\n\r\n\r\n\r\n        const T my_f0_nm2 = std::pow(my_f0, n - 2);\r\n\r\n        const T my_f0_nm1 = my_f0_nm2.multiply(my_f0);\r\n\r\n        const T my_f0N   = my_f0_nm1.multiply(my_f0);\r\n\r\n        return compose(my_f0N, my_f0_nm1.multiply(n), my_f0_nm2.multiply(n * (n - 1)));\r\n\r\n        \r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> pow(const Field_Univariate_Derivative_2<T>& e) \r\n\r\n    {\r\n\r\n        return log().multiply(e).exp();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> exp() \r\n\r\n    {\r\n\r\n        const T exp = std::exp(my_f0);\r\n\r\n        return compose(exp, exp, exp);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> expm1() \r\n\r\n    {\r\n\r\n        const T exp   = std::exp(my_f0);\r\n\r\n        const T exp_m1 = std::expm1(my_f0);\r\n\r\n        return compose(exp_m1, exp, exp);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> log() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.reciprocal();\r\n\r\n        return compose(std::log(my_f0), inv, inv.multiply(inv).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> log1p() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.add(1).reciprocal();\r\n\r\n        return compose(std::log1p(my_f0), inv, inv.multiply(inv).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> log10() \r\n\r\n    {\r\n\r\n        const T inv_f0 = my_f0.reciprocal();\r\n\r\n        const T inv = inv_f0.divide(std::log(10.0));\r\n\r\n        return compose(std::log10(my_f0), inv, inv.multiply(inv_f0).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> cos() \r\n\r\n    {\r\n\r\n        const Field_Sin_Cos<T> sin_cos = Sin_Cos(my_f0);\r\n\r\n        return compose(sin_cos.cos(), sin_cos.sin().negate(), sin_cos.cos().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> sin() \r\n\r\n    {\r\n\r\n        const Field_Sin_Cos<T> sin_cos = Sin_Cos(my_f0);\r\n\r\n        return compose(sin_cos.sin(), sin_cos.cos(), sin_cos.sin().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Sin_Cos<Field_Univariate_Derivative_2<T>> sin_cos() \r\n\r\n    {\r\n\r\n        const Field_Sin_Cos<T> sin_cos = Sin_Cos(my_f0);\r\n\r\n        const T m_sin = sin_cos.sin().negate();\r\n\r\n        const T m_cos = sin_cos.cos().negate();\r\n\r\n        return Field_Sin_Cos<>(compose(sin_cos.sin(), sin_cos.cos(), m_sin), compose(sin_cos.cos(), m_sin, m_cos));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> tan() \r\n\r\n    {\r\n\r\n        const T tan  = std::tan(my_f0);\r\n\r\n        const T sec2 = tan.multiply(tan).add(1);\r\n\r\n        return compose(tan, sec2, sec2.add(sec2).multiply(tan));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> acos() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).negate().add(1).reciprocal();\r\n\r\n        const T mS  = inv.sqrt().negate();\r\n\r\n        return compose(std::acos(my_f0), mS, mS.multiply(my_f0).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> asin() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).negate().add(1).reciprocal();\r\n\r\n        const T s   = inv.sqrt();\r\n\r\n        return compose(std::asin(my_f0), s, s.multiply(my_f0).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> atan() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).add(1).reciprocal();\r\n\r\n        return compose(std::atan(my_f0), inv, my_f0.multiply(-2).multiply(inv).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> atan2(const Field_Univariate_Derivative_2<T>& x) \r\n\r\n    {\r\n\r\n        const T x2    = x.f0.multiply(x.f0);\r\n\r\n        const T my_f02   = my_f0.add(my_f0);\r\n\r\n        const T inv   = my_f0.multiply(my_f0).add(x2).reciprocal();\r\n\r\n        const T atan0 = std::atan2(my_f0, x.f0);\r\n\r\n        const T atan1 = my_f0.linear_combination(x.f0, my_f1, x.f1.negate(), my_f0).multiply(inv);\r\n\r\n        const T c     = my_f0.linear_combination(f2, x2, my_f1.multiply(-2), x.f0.multiply(x.f1), my_f02, x.f1.multiply(x.f1), my_f0.negate(), x.f0.multiply(x.f2)).multiply(inv);\r\n\r\n        return Field_Univariate_Derivative_2<>(atan0, atan1, c.subtract(my_f02.multiply(atan1).multiply(atan1)).divide(x.f0));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> cosh() \r\n\r\n    {\r\n\r\n        const T c = std::cosh(my_f0);\r\n\r\n        const T s = std::sinh(my_f0);\r\n\r\n        return compose(c, s, c);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> sinh() \r\n\r\n    {\r\n\r\n        const T c = std::cosh(my_f0);\r\n\r\n        const T s = std::sinh(my_f0);\r\n\r\n        return compose(s, c, s);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Sinh_Cosh<Field_Univariate_Derivative_2<T>> sinh_cosh() \r\n\r\n    {\r\n\r\n        const Field_Sinh_Cosh<T> sinh_cosh = std::sinh_cosh(my_f0);\r\n\r\n        return Field_Sinh_Cosh<>(compose(sinh_cosh.sinh(), sinh_cosh.cosh(), sinh_cosh.sinh()), compose(sinh_cosh.cosh(), sinh_cosh.sinh(), sinh_cosh.cosh()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> tanh() \r\n\r\n    {\r\n\r\n        const T tanh  = std::tanh(my_f0);\r\n\r\n        const T sech2 = tanh.multiply(tanh).negate().add(1);\r\n\r\n        return compose(tanh, sech2, sech2.multiply(-2).multiply(tanh));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> acosh() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).subtract(1).reciprocal();\r\n\r\n        const T s   = inv.sqrt();\r\n\r\n        return compose(std::acosh(my_f0), s, my_f0.negate().multiply(s).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> asinh() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).add(1).reciprocal();\r\n\r\n        const T s   = inv.sqrt();\r\n\r\n        return compose(std::asinh(my_f0), s, my_f0.negate().multiply(s).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> atanh() \r\n\r\n    {\r\n\r\n        const T inv = my_f0.multiply(my_f0).negate().add(1).reciprocal();\r\n\r\n        return compose(std::atanh(my_f0), inv, my_f0.add(my_f0).multiply(inv).multiply(inv));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> to_degrees() \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.to_degrees(my_f0), FastMath.to_degrees(my_f1), FastMath.to_degrees(f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> to_radians() \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(FastMath.to_radians(my_f0), FastMath.to_radians(my_f1), FastMath.to_radians(f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate Taylor expansion a univariate derivative.\r\n\r\n     * @param delta parameter offset \xce\x94x\r\n\r\n     * @return value of the Taylor expansion at x + \xce\x94x\r\n\r\n     */\r\n\r\n    T taylor(const double delta) \r\n\r\n    {\r\n\r\n        return my_f0.add(my_f1.add(f2.multiply(0.5 * delta)).multiply(delta));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate Taylor expansion a univariate derivative.\r\n\r\n     * @param delta parameter offset \xce\x94x\r\n\r\n     * @return value of the Taylor expansion at x + \xce\x94x\r\n\r\n     */\r\n\r\n    T taylor(const T& delta) \r\n\r\n    {\r\n\r\n        return my_f0.add(my_f1.add(f2.multiply(delta.multiply(0.5))).multiply(delta));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination.\r\n\r\n     * @param a Factors.\r\n\r\n     * @param b Factors.\r\n\r\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\r\n\r\n     * @ if arrays dimensions don't match\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const std::vector<T>& a, const std::vector<Field_Univariate_Derivative_2<T>&b) \r\n\r\n    {\r\n\r\n        // extract values and derivatives\r\n\r\n        const Field<T> field = b[0].f0.get_field();\r\n\r\n        const auto n  = b.size();\r\n\r\n        const std::vector<T> b0 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> b1 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> b2 = Math_Arrays::build_array(field, n);\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n            b0[i] = b[i].f0;\r\n\r\n            b1[i] = b[i].f1;\r\n\r\n            b2[i] = b[i].f2;\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Univariate_Derivative_2<>(b[0].f0.linear_combination(a, b0), b[0].f0.linear_combination(a, b1), b[0].f0.linear_combination(a, b2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const std::vector<Field_Univariate_Derivative_2<T>& a, const std::vector<Field_Univariate_Derivative_2<T>& b) \r\n\r\n    {\r\n\r\n        // extract values and derivatives\r\n\r\n        const Field<T> field = a[0].f0.get_field();\r\n\r\n        const int& n  = a.size();\r\n\r\n        const std::vector<T> a0 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> b0 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> a1 = Math_Arrays::build_array(field, 2 * n);\r\n\r\n        const std::vector<T> b1 = Math_Arrays::build_array(field, 2 * n);\r\n\r\n        std::vector<T> a2 = Math_Arrays::build_array(field, 3 * n);\r\n\r\n        std::vector<T> b2 = Math_Arrays::build_array(field, 3 * n);\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n            Field_Univariate_Derivative_2<T> ai = a[i];\r\n\r\n            Field_Univariate_Derivative_2<T> bi = b[i];\r\n\r\n            a0[i]         = ai.f0;\r\n\r\n            b0[i]         = bi.f0;\r\n\r\n            a1[2 * i]     = ai.f0;\r\n\r\n            a1[2 * i + 1] = ai.f1;\r\n\r\n            b1[2 * i]     = bi.f1;\r\n\r\n            b1[2 * i + 1] = bi.f0;\r\n\r\n            a2[3 * i]     = ai.f0;\r\n\r\n            a2[3 * i + 1] = ai.f1.add(ai.f1);\r\n\r\n            a2[3 * i + 2] = ai.f2;\r\n\r\n            b2[3 * i]     = bi.f2;\r\n\r\n            b2[3 * i + 1] = bi.f1;\r\n\r\n            b2[3 * i + 2] = bi.f0;\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Univariate_Derivative_2<>(a[0].f0.linear_combination(a0, b0), a[0].f0.linear_combination(a1, b1), a[0].f0.linear_combination(a2, b2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const std::vector<double>& a, const std::vector<Field_Univariate_Derivative_2<T>& b) \r\n\r\n    {\r\n\r\n\r\n\r\n        // extract values and derivatives\r\n\r\n        const Field<T> field = b[0].f0.get_field();\r\n\r\n        const int      n  = b.size();\r\n\r\n        const std::vector<T> b0 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> b1 = Math_Arrays::build_array(field, n);\r\n\r\n        const std::vector<T> b2 = Math_Arrays::build_array(field, n);\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n            b0[i] = b[i].f0;\r\n\r\n            b1[i] = b[i].f1;\r\n\r\n            b2[i] = b[i].f2;\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Univariate_Derivative_2<>(b[0].f0.linear_combination(a, b0), b[0].f0.linear_combination(a, b1), b[0].f0.linear_combination(a, b2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const Field_Univariate_Derivative_2<T>& a1, const Field_Univariate_Derivative_2<T>& b1, const Field_Univariate_Derivative_2<T>& a2, const Field_Univariate_Derivative_2<T>& b2) \r\n\r\n    {\r\n\r\n        const Field<T> field = a1.f0.get_field();\r\n\r\n        const std::vector<T>      u2    = Math_Arrays::build_array(field, 6);\r\n\r\n        const std::vector<T>      v2    = Math_Arrays::build_array(field, 6);\r\n\r\n        u2[0] = a1.f0;\r\n\r\n        u2[1] = a1.f1.add(a1.f1);\r\n\r\n        u2[2] = a1.f2;\r\n\r\n        u2[3] = a2.f0;\r\n\r\n        u2[4] = a2.f1.add(a2.f1);\r\n\r\n        u2[5] = a2.f2;\r\n\r\n        v2[0] = b1.f2;\r\n\r\n        v2[1] = b1.f1;\r\n\r\n        v2[2] = b1.f0;\r\n\r\n        v2[3] = b2.f2;\r\n\r\n        v2[4] = b2.f1;\r\n\r\n        v2[5] = b2.f0;\r\n\r\n        return Field_Univariate_Derivative_2<>(a1.f0.linear_combination(a1.f0, b1.f0, a2.f0, b2.f0), a1.f0.linear_combination(a1.f0, b1.f1, a1.f1, b1.f0, a2.f0, b2.f1, a2.f1, b2.f0), a1.f0.linear_combination(u2, v2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const double& a1, const Field_Univariate_Derivative_2<T>& b1, const double& a2, const Field_Univariate_Derivative_2<T>& b2) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(b1.f0.linear_combination(a1, b1.f0, a2, b2.f0), b1.f0.linear_combination(a1, b1.f1, a2, b2.f1), b1.f0.linear_combination(a1, b1.f2, a2, b2.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const Field_Univariate_Derivative_2<T>& a1, const Field_Univariate_Derivative_2<T>& b1, const Field_Univariate_Derivative_2<T>& a2, const Field_Univariate_Derivative_2<T>& b2, const Field_Univariate_Derivative_2<T>& a3, const Field_Univariate_Derivative_2<T>& b3) \r\n\r\n    {\r\n\r\n        const Field<T> field = a1.f0.get_field();\r\n\r\n        const std::vector<T>      u1     = Math_Arrays::build_array(field, 6);\r\n\r\n        const std::vector<T>      v1     = Math_Arrays::build_array(field, 6);\r\n\r\n        u1[0] = a1.f0;\r\n\r\n        u1[1] = a1.f1;\r\n\r\n        u1[2] = a2.f0;\r\n\r\n        u1[3] = a2.f1;\r\n\r\n        u1[4] = a3.f0;\r\n\r\n        u1[5] = a3.f1;\r\n\r\n        v1[0] = b1.f1;\r\n\r\n        v1[1] = b1.f0;\r\n\r\n        v1[2] = b2.f1;\r\n\r\n        v1[3] = b2.f0;\r\n\r\n        v1[4] = b3.f1;\r\n\r\n        v1[5] = b3.f0;\r\n\r\n        const std::vector<T>      u2     = Math_Arrays::build_array(field, 9);\r\n\r\n        const std::vector<T>      v2     = Math_Arrays::build_array(field, 9);\r\n\r\n        u2[0] = a1.f0;\r\n\r\n        u2[1] = a1.f1.add(a1.f1);\r\n\r\n        u2[2] = a1.f2;\r\n\r\n        u2[3] = a2.f0;\r\n\r\n        u2[4] = a2.f1.add(a2.f1);\r\n\r\n        u2[5] = a2.f2;\r\n\r\n        u2[6] = a3.f0;\r\n\r\n        u2[7] = a3.f1.add(a3.f1);\r\n\r\n        u2[8] = a3.f2;\r\n\r\n        v2[0] = b1.f2;\r\n\r\n        v2[1] = b1.f1;\r\n\r\n        v2[2] = b1.f0;\r\n\r\n        v2[3] = b2.f2;\r\n\r\n        v2[4] = b2.f1;\r\n\r\n        v2[5] = b2.f0;\r\n\r\n        v2[6] = b3.f2;\r\n\r\n        v2[7] = b3.f1;\r\n\r\n        v2[8] = b3.f0;\r\n\r\n        return Field_Univariate_Derivative_2<>(a1.f0.linear_combination(a1.f0, b1.f0, a2.f0, b2.f0, a3.f0, b3.f0), a1.f0.linear_combination(u1, v1), a1.f0.linear_combination(u2, v2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute a linear combination.\r\n\r\n     * @param a1 first factor of the first term\r\n\r\n     * @param b1 second factor of the first term\r\n\r\n     * @param a2 first factor of the second term\r\n\r\n     * @param b2 second factor of the second term\r\n\r\n     * @param a3 first factor of the third term\r\n\r\n     * @param b3 second factor of the third term\r\n\r\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\r\n\r\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\r\n\r\n     * @see #linear_combination(double, Field_Univariate_Derivative_2, double, Field_Univariate_Derivative_2)\r\n\r\n     * @see #linear_combination(double, Field_Univariate_Derivative_2, double, Field_Univariate_Derivative_2, double, Field_Univariate_Derivative_2, double, Field_Univariate_Derivative_2)\r\n\r\n     * @exception  if number of free parameters or orders are inconsistent\r\n\r\n     */\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const T& a1, const Field_Univariate_Derivative_2<T>& b1, const T a2, const Field_Univariate_Derivative_2<T>& b2, const T a3, const Field_Univariate_Derivative_2<T>& b3) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(b1.f0.linear_combination(a1, b1.f0, a2, b2.f0, a3, b3.f0), b1.f0.linear_combination(a1, b1.f1, a2, b2.f1, a3, b3.f1), b1.f0.linear_combination(a1, b1.f2, a2, b2.f2, a3, b3.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const double& a1, const Field_Univariate_Derivative_2<T>& b1, const double& a2, const Field_Univariate_Derivative_2<T>& b2, const double& a3, const Field_Univariate_Derivative_2<T>& b3) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(b1.f0.linear_combination(a1, b1.f0, a2, b2.f0, a3, b3.f0), b1.f0.linear_combination(a1, b1.f1, a2, b2.f1, a3, b3.f1), b1.f0.linear_combination(a1, b1.f2, a2, b2.f2, a3, b3.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const Field_Univariate_Derivative_2<T>& a1, const Field_Univariate_Derivative_2<T>& b1, const Field_Univariate_Derivative_2<T>& a2, const Field_Univariate_Derivative_2<T>& b2, const Field_Univariate_Derivative_2<T>& a3, const Field_Univariate_Derivative_2<T>& b3, const Field_Univariate_Derivative_2<T>& a4, const Field_Univariate_Derivative_2<T>& b4) \r\n\r\n    {\r\n\r\n        const Field<T> field = a1.f0.get_field();\r\n\r\n        const std::vector<T> u1 = Math_Arrays::build_array(field, 8);\r\n\r\n        const std::vector<T> v1 = Math_Arrays::build_array(field, 8);\r\n\r\n        u1[0] = a1.f0;\r\n\r\n        u1[1] = a1.f1;\r\n\r\n        u1[2] = a2.f0;\r\n\r\n        u1[3] = a2.f1;\r\n\r\n        u1[4] = a3.f0;\r\n\r\n        u1[5] = a3.f1;\r\n\r\n        u1[6] = a4.f0;\r\n\r\n        u1[7] = a4.f1;\r\n\r\n        v1[0] = b1.f1;\r\n\r\n        v1[1] = b1.f0;\r\n\r\n        v1[2] = b2.f1;\r\n\r\n        v1[3] = b2.f0;\r\n\r\n        v1[4] = b3.f1;\r\n\r\n        v1[5] = b3.f0;\r\n\r\n        v1[6] = b4.f1;\r\n\r\n        v1[7] = b4.f0;\r\n\r\n        const std::vector<T> u2 = Math_Arrays::build_array(field, 12);\r\n\r\n        const std::vector<T> v2 = Math_Arrays::build_array(field, 12);\r\n\r\n        u2[ 0] = a1.f0;\r\n\r\n        u2[ 1] = a1.f1.add(a1.f1);\r\n\r\n        u2[ 2] = a1.f2;\r\n\r\n        u2[ 3] = a2.f0;\r\n\r\n        u2[ 4] = a2.f1.add(a2.f1);\r\n\r\n        u2[ 5] = a2.f2;\r\n\r\n        u2[ 6] = a3.f0;\r\n\r\n        u2[ 7] = a3.f1.add(a3.f1);\r\n\r\n        u2[ 8] = a3.f2;\r\n\r\n        u2[ 9] = a4.f0;\r\n\r\n        u2[10] = a4.f1.add(a4.f1);\r\n\r\n        u2[11] = a4.f2;\r\n\r\n        v2[ 0] = b1.f2;\r\n\r\n        v2[ 1] = b1.f1;\r\n\r\n        v2[ 2] = b1.f0;\r\n\r\n        v2[ 3] = b2.f2;\r\n\r\n        v2[ 4] = b2.f1;\r\n\r\n        v2[ 5] = b2.f0;\r\n\r\n        v2[ 6] = b3.f2;\r\n\r\n        v2[ 7] = b3.f1;\r\n\r\n        v2[ 8] = b3.f0;\r\n\r\n        v2[ 9] = b4.f2;\r\n\r\n        v2[10] = b4.f1;\r\n\r\n        v2[11] = b4.f0;\r\n\r\n        return Field_Univariate_Derivative_2<>(a1.f0.linear_combination(a1.f0, b1.f0, a2.f0, b2.f0, a3.f0, b3.f0, a4.f0, b4.f0), a1.f0.linear_combination(u1, v1), a1.f0.linear_combination(u2, v2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> linear_combination(const double& a1, const Field_Univariate_Derivative_2<T>& b1, const double& a2, const Field_Univariate_Derivative_2<T>& b2, const double& a3, const Field_Univariate_Derivative_2<T>& b3, const double& a4, const Field_Univariate_Derivative_2<T>& b4) \r\n\r\n    {\r\n\r\n        return Field_Univariate_Derivative_2<>(b1.f0.linear_combination(a1, b1.f0, a2, b2.f0, a3, b3.f0, a4, b4.f0), b1.f0.linear_combination(a1, b1.f1, a2, b2.f1, a3, b3.f1, a4, b4.f1), b1.f0.linear_combination(a1, b1.f2, a2, b2.f2, a3, b3.f2, a4, b4.f2));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Univariate_Derivative_2<T> get_pi() \r\n\r\n    {\r\n\r\n        const T zero = get_value_field().get_zero();\r\n\r\n        return Field_Univariate_Derivative_2<>(zero.get_pi(), zero, zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Test for the equality of two univariate derivatives.\r\n\r\n     * <p>\r\n\r\n     * univariate derivatives are considered equal if they have the same derivatives.\r\n\r\n     * </p>\r\n\r\n     * @param other Object to test for equality to this\r\n\r\n     * @return true if two univariate derivatives are equal\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool equals(Object other) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (this == other) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (other instanceof Field_Univariate_Derivative_2) \r\n\r\n        {\r\n\r\n            //@Suppress_Warnings("unchecked")\r\n\r\n            const Field_Univariate_Derivative_2<T>& rhs = (Field_Univariate_Derivative_2<T>) other;\r\n\r\n            return my_f0.equals(rhs.f0) && my_f1.equals(rhs.f1) && my_f2.equals(rhs.f2);\r\n\r\n        }\r\n\r\n\r\n\r\n        return false;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a hash_code for the univariate derivative.\r\n\r\n     * @return a hash code value for this object\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    int hash_code() \r\n\r\n    {\r\n\r\n        return 317 - 41 * my_f0.hash_code() + 57 * my_f1.hash_code() - 103 * my_f2.hash_code();\r\n\r\n    }\r\n\r\n};\r\n\r\n