/*\r\n\r\n\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n\r\n\r\n *\r\n\r\n\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n\r\n\r\n * limitations under the License.\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Field_Sinh_Cosh;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Sin_Cos;\r\n\r\n\r\n\r\n//import org.hipparchus.util.Sinh_Cosh;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Class representing both the value and the differentials of a function.\r\n\r\n\r\n\r\n * <p>This class is a stripped-down version of {@link Derivative_Structure}\r\n\r\n\r\n\r\n * with only one {@link Derivative_Structure#get_free_parameters() free parameter}\r\n\r\n\r\n\r\n * and {@link Derivative_Structure#get_order() derivation order} also limited to two.\r\n\r\n\r\n\r\n * It should have less overhead than {@link Derivative_Structure} in its domain.</p>\r\n\r\n\r\n\r\n * <p>This class is an implementation of Rall's numbers. Rall's numbers are an\r\n\r\n\r\n\r\n * extension to the real numbers used throughout mathematical expressions; they hold\r\n\r\n\r\n\r\n * the derivative together with the value of a function.</p>\r\n\r\n\r\n\r\n * <p>{@link Univariate_Derivative_2} instances can be used directly thanks to\r\n\r\n\r\n\r\n * the arithmetic operators to the mathematical functions provided as\r\n\r\n\r\n\r\n * methods by this class (+, -, *, /, %, sin, cos ...).</p>\r\n\r\n\r\n\r\n * <p>Implementing complex expressions by hand using these classes is\r\n\r\n\r\n\r\n * a tedious and error-prone task but has the advantage of having no limitation\r\n\r\n\r\n\r\n * on the derivation order despite not requiring users to compute the derivatives by\r\n\r\n\r\n\r\n * themselves.</p>\r\n\r\n\r\n\r\n * <p>Instances of this class are guaranteed to be immutable.</p>\r\n\r\n\r\n\r\n * @see Derivative_Structure\r\n\r\n\r\n\r\n * @see Univariate_Derivative_2\r\n\r\n\r\n\r\n * @see Gradient\r\n\r\n\r\n\r\n * @see Field_Derivative_Structure\r\n\r\n\r\n\r\n * @see Field_Univariate_Derivative_2\r\n\r\n\r\n\r\n * @see Field_Univariate_Derivative_2\r\n\r\n\r\n\r\n * @see Field_Gradient\r\n\r\n\r\n\r\n * @since 1.7\r\n\r\n\r\n\r\n */\r\n\r\n\r\n\r\nclass Univariate_Derivative_2 extends Univariate_Derivative<Univariate_Derivative_2> \r\n\r\n\r\n\r\n{\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** The constant value of \xcf\x80 as a {@code Univariate_Derivative_2}.\r\n\r\n\r\n\r\n     * @since 2.0\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public static const Univariate_Derivative_2 PI = Univariate_Derivative_2(std::numbers::pi, 0.0, 0.0);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Serializable UID. */\r\n\r\n\r\n\r\n    private static const long serial_version_uid = 20200520L;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Value of the function. */\r\n\r\n\r\n\r\n    private const double f0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** First derivative of the function. */\r\n\r\n\r\n\r\n    private const double f1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Second derivative of the function. */\r\n\r\n\r\n\r\n    private const double f2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Build an instance with values and derivative.\r\n\r\n\r\n\r\n     * @param f0 value of the function\r\n\r\n\r\n\r\n     * @param f1 first derivative of the function\r\n\r\n\r\n\r\n     * @param f2 second derivative of the function\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public Univariate_Derivative_2(const double f0, const double f1, const double f2) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        this.f0 = f0;\r\n\r\n\r\n\r\n        this.f1 = f1;\r\n\r\n\r\n\r\n        this.f2 = f2;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Build an instance from a {@link Derivative_Structure}.\r\n\r\n\r\n\r\n     * @param ds derivative structure\r\n\r\n\r\n\r\n     * @exception  if either {@code ds} parameters\r\n\r\n\r\n\r\n     * is not 1 or {@code ds} order is not 2\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public Univariate_Derivative_2(const Derivative_Structure ds)  \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        Math_Utils::check_dimension(ds.get_free_parameters(), 1);\r\n\r\n\r\n\r\n        Math_Utils::check_dimension(ds.get_order(), 2);\r\n\r\n\r\n\r\n        this.f0 = ds.get_value();\r\n\r\n\r\n\r\n        this.f1 = ds.get_partial_derivative(1);\r\n\r\n\r\n\r\n        this.f2 = ds.get_partial_derivative(2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 new_instance(const double value) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(value, 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public double get_real() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return get_value();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public double get_value() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return f0;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public double get_derivative(const int& n) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        switch (n) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            case 0 :\r\n\r\n\r\n\r\n                return f0;\r\n\r\n\r\n\r\n            case 1 :\r\n\r\n\r\n\r\n                return f1;\r\n\r\n\r\n\r\n            case 2 :\r\n\r\n\r\n\r\n                return f2;\r\n\r\n\r\n\r\n            default :\r\n\r\n\r\n\r\n                throw (Localized_Core_Formats.DERIVATION_ORDER_NOT_ALLOWED, n);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public int get_order() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return 2;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the first derivative.\r\n\r\n\r\n\r\n     * @return first derivative\r\n\r\n\r\n\r\n     * @see #get_value()\r\n\r\n\r\n\r\n     * @see #get_second_derivative()\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public double get_first_derivative() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return f1;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the second derivative.\r\n\r\n\r\n\r\n     * @return second derivative\r\n\r\n\r\n\r\n     * @see #get_value()\r\n\r\n\r\n\r\n     * @see #get_first_derivative()\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public double get_second_derivative() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return f2;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Derivative_Structure to_derivative_structure() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return get_field().get_conversion_factory().build(f0, f1, f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 add(const double& a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 + a, f1, f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 add(const Univariate_Derivative_2 a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 + a.f0, f1 + a.f1, f2 + a.f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 subtract(const double& a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 - a, f1, f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 subtract(const Univariate_Derivative_2 a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 - a.f0, f1 - a.f1, f2 - a.f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 multiply(const int& n) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 * n, f1 * n, f2 * n);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 multiply(const double& a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 * a, f1 * a, f2 * a);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 multiply(const Univariate_Derivative_2 a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 * a.f0, Math_Arrays::linear_combination(f1, a.f0, f0, a.f1), Math_Arrays::linear_combination(f2, a.f0, 2 * f1, a.f1, f0, a.f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 divide(const double& a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv1 = 1.0 / a;\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 * inv1, f1 * inv1, f2 * inv1);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 divide(const Univariate_Derivative_2 a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv1 = 1.0 / a.f0;\r\n\r\n\r\n\r\n        const double inv2 = inv1 * inv1;\r\n\r\n\r\n\r\n        const double inv3 = inv1 * inv2;\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f0 * inv1, Math_Arrays::linear_combination(f1, a.f0, -f0, a.f1) * inv2, Math_Arrays::linear_combination(f2, a.f0 * a.f0, -2 * f1, a.f0 * a.f1, 2 * f0, a.f1 * a.f1, -f0, a.f0 * a.f2) * inv3);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 remainder(const double& a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(std::remainder(f0, a), f1, f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 remainder(const Univariate_Derivative_2 a) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // compute k such that lhs % rhs = lhs - k rhs\r\n\r\n\r\n\r\n        const double rem = std::remainder(f0, a.f0);\r\n\r\n\r\n\r\n        const double k   = FastMath.rint((f0 - rem) / a.f0);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(rem, f1 - k * a.f1, f2 - k * a.f2);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 negate() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(-f0, -f1, -f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 abs() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        if (Double.double_to_long_bits(f0) < 0) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            // we use the bits representation to also handle -0.0\r\n\r\n\r\n\r\n            return negate();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return this;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 ceil() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.ceil(f0), 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 floor() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(std::floor(f0), 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 rint() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.rint(f0), 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 sign() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.signum(f0), 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 copy_sign(const Univariate_Derivative_2 sign) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        long m = Double.double_to_long_bits(f0);\r\n\r\n\r\n\r\n        long s = Double.double_to_long_bits(sign.f0);\r\n\r\n\r\n\r\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\r\n\r\n\r\n\r\n            return this;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return negate(); // flip sign\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 copy_sign(const double sign) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        long m = Double.double_to_long_bits(f0);\r\n\r\n\r\n\r\n        long s = Double.double_to_long_bits(sign);\r\n\r\n\r\n\r\n        if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\r\n\r\n\r\n\r\n            return this;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return negate(); // flip sign\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public int get_exponent() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return FastMath.get_exponent(f0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 scalb(const int& n) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(std::scalbn(f0, n), std::scalbn(f1, n), std::scalbn(f2, n));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * The {@code ulp} function is a step function, hence all its derivatives are 0.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @since 2.0\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 ulp() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.ulp(f0), 0.0, 0.0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 hypot(const Univariate_Derivative_2 y) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (Double.std::isinfinite(f0) || Double.std::isinfinite(y.f0)) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return Univariate_Derivative_2(INFINITY, 0.0, 0.0);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse if (std::isnan(f0) || std::isnan(y.f0)) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return Univariate_Derivative_2(Double.NaN, 0.0, 0.0);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            const int exp_x = get_exponent();\r\n\r\n\r\n\r\n            const int exp_y = y.get_exponent();\r\n\r\n\r\n\r\n            if (exp_x > exp_y + 27) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                // y is neglectible with respect to x\r\n\r\n\r\n\r\n                return abs();\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\nelse if (exp_y > exp_x + 27) \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n                // x is neglectible with respect to y\r\n\r\n\r\n\r\n                return y.abs();\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n            {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // find an intermediate scale to avoid both overflow and underflow\r\n\r\n\r\n\r\n                const int middle_exp = (exp_x + exp_y) / 2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // scale parameters without losing precision\r\n\r\n\r\n\r\n                const Univariate_Derivative_2 scaled_x = scalb(-middle_exp);\r\n\r\n\r\n\r\n                const Univariate_Derivative_2 scaled_y = y.scalb(-middle_exp);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // compute scaled hypotenuse\r\n\r\n\r\n\r\n                const Univariate_Derivative_2 scaled_h =\r\n\r\n\r\n\r\n                        scaled_x.multiply(scaled_x).add(scaled_y.multiply(scaled_y)).sqrt();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                // remove scaling\r\n\r\n\r\n\r\n                return scaled_h.scalb(middle_exp);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 reciprocal() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv1 = 1.0 / f0;\r\n\r\n\r\n\r\n        const double inv2 = inv1 * inv1;\r\n\r\n\r\n\r\n        const double inv3 = inv1 * inv2;\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(inv1, -f1 * inv2, Math_Arrays::linear_combination(2 * f1, f1, -f0, f2) * inv3);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 compose(const double... f) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        Math_Utils::check_dimension(f.size(), get_order() + 1);\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(f[0], f[1] * f1, Math_Arrays::linear_combination(f[1], f2, f[2], f1 * f1));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 sqrt() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double s = std::sqrt(f0);\r\n\r\n\r\n\r\n        return compose(s, 1 / (2 * s), -1 / (4 * s * f0));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 cbrt() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double c  = std::cbrt(f0);\r\n\r\n\r\n\r\n        const double c2 = c * c;\r\n\r\n\r\n\r\n        return compose(c, 1 / (3 * c2), -1 / (4.5 * c2 * f0));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 root_n(const int& n) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == 2) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return sqrt();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse if (n == 3) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return cbrt();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const double r = std::pow(f0, 1.0 / n);\r\n\r\n\r\n\r\n            const double z = n * std::pow(r, n - 1);\r\n\r\n\r\n\r\n            return compose(r, 1 / z, (1 - n) / (z * z * r));\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2_Field get_field() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2_Field.get_instance();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Compute a<sup>x</sup> where a is a double and x a {@link Univariate_Derivative_2}\r\n\r\n\r\n\r\n     * @param a number to exponentiate\r\n\r\n\r\n\r\n     * @param x power to apply\r\n\r\n\r\n\r\n     * @return a<sup>x</sup>\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public static Univariate_Derivative_2 pow(const double& a, const Univariate_Derivative_2 x) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        if (a == 0) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return x.get_field().get_zero();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const double& a_x    = std::pow(a, x.f0);\r\n\r\n\r\n\r\n            const double ln_a   = std::log(a);\r\n\r\n\r\n\r\n            const double& a_xln_a = a_x * ln_a;\r\n\r\n\r\n\r\n            return Univariate_Derivative_2(a_x, a_xln_a * x.f1, a_xln_a * (x.f1 * x.f1 * ln_a + x.f2));\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 pow(const double& p) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        if (p == 0) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return get_field().get_one();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const double f0_pm2 = std::pow(f0, p - 2);\r\n\r\n\r\n\r\n            const double f0_pm1 = f0_pm2 * f0;\r\n\r\n\r\n\r\n            const double f0P   = f0_pm1 * f0;\r\n\r\n\r\n\r\n            return compose(f0P, p * f0_pm1, p * (p - 1) * f0_pm2);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 pow(const int& n) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        if (n == 0) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return get_field().get_one();\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\nelse \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const double f0_nm2 = std::pow(f0, n - 2);\r\n\r\n\r\n\r\n            const double f0_nm1 = f0_nm2 * f0;\r\n\r\n\r\n\r\n            const double f0N   = f0_nm1 * f0;\r\n\r\n\r\n\r\n            return compose(f0N, n * f0_nm1, n * (n - 1) * f0_nm2);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 pow(const Univariate_Derivative_2 e) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return log().multiply(e).exp();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 exp() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double exp = std::exp(f0);\r\n\r\n\r\n\r\n        return compose(exp, exp, exp);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 expm1() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double exp   = std::exp(f0);\r\n\r\n\r\n\r\n        const double exp_m1 = std::expm1(f0);\r\n\r\n\r\n\r\n        return compose(exp_m1, exp, exp);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 log() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / f0;\r\n\r\n\r\n\r\n        return compose(std::log(f0), inv, -inv * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 log1p() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / (1 + f0);\r\n\r\n\r\n\r\n        return compose(std::log1p(f0), inv, -inv * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 log10() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv_f0 = 1 / f0;\r\n\r\n\r\n\r\n        const double inv = inv_f0 / std::log(10.0);\r\n\r\n\r\n\r\n        return compose(std::log10(f0), inv, -inv * inv_f0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 cos() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const Sin_Cos sin_cos = Sin_Cos(f0);\r\n\r\n\r\n\r\n        return compose(sin_cos.cos(), -sin_cos.sin(), -sin_cos.cos());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 sin() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const Sin_Cos sin_cos = Sin_Cos(f0);\r\n\r\n\r\n\r\n        return compose(sin_cos.sin(), sin_cos.cos(), -sin_cos.sin());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Field_Sin_Cos<Univariate_Derivative_2> sin_cos() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const Sin_Cos sin_cos = Sin_Cos(f0);\r\n\r\n\r\n\r\n        return Field_Sin_Cos<>(compose(sin_cos.sin(),  sin_cos.cos(), -sin_cos.sin()), compose(sin_cos.cos(), -sin_cos.sin(), -sin_cos.cos()));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 tan() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double tan  = std::tan(f0);\r\n\r\n\r\n\r\n        const double sec2 = 1 + tan * tan;\r\n\r\n\r\n\r\n        return compose(tan, sec2, 2 * sec2 * tan);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 acos() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1.0 / (1 - f0 * f0);\r\n\r\n\r\n\r\n        const double mS  = -std::sqrt(inv);\r\n\r\n\r\n\r\n        return compose(std::acos(f0), mS, mS * f0 * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 asin() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1.0 / (1 - f0 * f0);\r\n\r\n\r\n\r\n        const double s   = std::sqrt(inv);\r\n\r\n\r\n\r\n        return compose(std::asin(f0), s, s * f0 * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 atan() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / (1 + f0 * f0);\r\n\r\n\r\n\r\n        return compose(std::atan(f0), inv, -2 * f0 * inv * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 atan2(const Univariate_Derivative_2 x) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double x2    = x.f0 * x.f0;\r\n\r\n\r\n\r\n        const double f02   = f0 + f0;\r\n\r\n\r\n\r\n        const double inv   = 1.0 / (f0 * f0 + x2);\r\n\r\n\r\n\r\n        const double& atan0 = std::atan2(f0, x.f0);\r\n\r\n\r\n\r\n        const double& atan1 = Math_Arrays::linear_combination(x.f0, f1, -x.f1, f0) * inv;\r\n\r\n\r\n\r\n        const double c     = Math_Arrays::linear_combination(f2, x2, -2 * f1, x.f0 * x.f1, f02, x.f1 * x.f1, -f0, x.f0 * x.f2) * inv;\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(atan0, atan1, (c - f02 * atan1 * atan1) / x.f0);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 cosh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double c = std::cosh(f0);\r\n\r\n\r\n\r\n        const double s = std::sinh(f0);\r\n\r\n\r\n\r\n        return compose(c, s, c);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 sinh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double c = std::cosh(f0);\r\n\r\n\r\n\r\n        const double s = std::sinh(f0);\r\n\r\n\r\n\r\n        return compose(s, c, s);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Field_Sinh_Cosh<Univariate_Derivative_2> sinh_cosh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const Sinh_Cosh sinh_cosh = std::sinh_cosh(f0);\r\n\r\n\r\n\r\n        return Field_Sinh_Cosh<>(compose(sinh_cosh.sinh(), sinh_cosh.cosh(), sinh_cosh.sinh()), compose(sinh_cosh.cosh(), sinh_cosh.sinh(), sinh_cosh.cosh()));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 tanh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double tanh  = std::tanh(f0);\r\n\r\n\r\n\r\n        const double sech2 = 1 - tanh * tanh;\r\n\r\n\r\n\r\n        return compose(tanh, sech2, -2 * sech2 * tanh);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 acosh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / (f0 * f0 - 1);\r\n\r\n\r\n\r\n        const double s   = std::sqrt(inv);\r\n\r\n\r\n\r\n        return compose(std::acosh(f0), s, -f0 * s * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 asinh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / (f0 * f0 + 1);\r\n\r\n\r\n\r\n        const double s   = std::sqrt(inv);\r\n\r\n\r\n\r\n        return compose(std::asinh(f0), s, -f0 * s * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 atanh() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        const double inv = 1 / (1 - f0 * f0);\r\n\r\n\r\n\r\n        return compose(std::atanh(f0), inv, 2 * f0 * inv * inv);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 to_degrees() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.to_degrees(f0), FastMath.to_degrees(f1), FastMath.to_degrees(f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 to_radians() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(FastMath.to_radians(f0), FastMath.to_radians(f1), FastMath.to_radians(f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Evaluate Taylor expansion a univariate derivative.\r\n\r\n\r\n\r\n     * @param delta parameter offset \xce\x94x\r\n\r\n\r\n\r\n     * @return value of the Taylor expansion at x + \xce\x94x\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    public double taylor(const double delta) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return f0 + delta * (f1 + 0.5 * delta * f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const Univariate_Derivative_2[] a, const Univariate_Derivative_2[] b) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // extract values and derivatives\r\n\r\n\r\n\r\n        const int      n  = a.size();\r\n\r\n\r\n\r\n        const std::vector<double> a0 = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> b0 = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> a1 = std::vector<double>(2 * n];\r\n\r\n\r\n\r\n        const std::vector<double> b1 = std::vector<double>(2 * n];\r\n\r\n\r\n\r\n        const std::vector<double> a2 = std::vector<double>(3 * n];\r\n\r\n\r\n\r\n        const std::vector<double> b2 = std::vector<double>(3 * n];\r\n\r\n\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const Univariate_Derivative_2 ai = a[i];\r\n\r\n\r\n\r\n            const Univariate_Derivative_2 bi = b[i];\r\n\r\n\r\n\r\n            a0[i]         = ai.f0;\r\n\r\n\r\n\r\n            b0[i]         = bi.f0;\r\n\r\n\r\n\r\n            a1[2 * i]     = ai.f0;\r\n\r\n\r\n\r\n            a1[2 * i + 1] = ai.f1;\r\n\r\n\r\n\r\n            b1[2 * i]     = bi.f1;\r\n\r\n\r\n\r\n            b1[2 * i + 1] = bi.f0;\r\n\r\n\r\n\r\n            a2[3 * i]     = ai.f0;\r\n\r\n\r\n\r\n            a2[3 * i + 1] = ai.f1 + ai.f1;\r\n\r\n\r\n\r\n            a2[3 * i + 2] = ai.f2;\r\n\r\n\r\n\r\n            b2[3 * i]     = bi.f2;\r\n\r\n\r\n\r\n            b2[3 * i + 1] = bi.f1;\r\n\r\n\r\n\r\n            b2[3 * i + 2] = bi.f0;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a0, b0), Math_Arrays::linear_combination(a1, b1), Math_Arrays::linear_combination(a2, b2));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const std::vector<double> a, const Univariate_Derivative_2[] b) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // extract values and derivatives\r\n\r\n\r\n\r\n        const int      n  = b.size();\r\n\r\n\r\n\r\n        const std::vector<double> b0 = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> b1 = std::vector<double>(n];\r\n\r\n\r\n\r\n        const std::vector<double> b2 = std::vector<double>(n];\r\n\r\n\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            b0[i] = b[i].f0;\r\n\r\n\r\n\r\n            b1[i] = b[i].f1;\r\n\r\n\r\n\r\n            b2[i] = b[i].f2;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a, b0), Math_Arrays::linear_combination(a, b1), Math_Arrays::linear_combination(a, b2));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const Univariate_Derivative_2 a1, const Univariate_Derivative_2 b1, const Univariate_Derivative_2 a2, const Univariate_Derivative_2 b2) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1.f0, b1.f0, a2.f0, b2.f0), Math_Arrays::linear_combination(a1.f0, b1.f1, a1.f1, b1.f0, a2.f0, b2.f1, a2.f1, b2.f0), Math_Arrays::linear_combination(std::vector<double> \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n                                                                          a1.f0, 2 * a1.f1, a1.f2, a2.f0, 2 * a2.f1, a2.f2\r\n\r\n\r\n\r\n                                                                      }, std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          b1.f2, b1.f1, b1.f0, b2.f2, b2.f1, b2.f0\r\n\r\n\r\n\r\n                                                                      }));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const double& a1, const Univariate_Derivative_2 b1, const double& a2, const Univariate_Derivative_2 b2) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1, b1.f0, a2, b2.f0), Math_Arrays::linear_combination(a1, b1.f1, a2, b2.f1), Math_Arrays::linear_combination(a1, b1.f2, a2, b2.f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const Univariate_Derivative_2 a1, const Univariate_Derivative_2 b1, const Univariate_Derivative_2 a2, const Univariate_Derivative_2 b2, const Univariate_Derivative_2 a3, const Univariate_Derivative_2 b3) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1.f0, b1.f0, a2.f0, b2.f0, a3.f0, b3.f0), Math_Arrays::linear_combination(std::vector<double> \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n                                                                          a1.f0, a1.f1, a2.f0, a2.f1, a3.f0, a3.f1\r\n\r\n\r\n\r\n                                                                      }, std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          b1.f1, b1.f0, b2.f1, b2.f0, b3.f1, b3.f0\r\n\r\n\r\n\r\n                                                                      }), Math_Arrays::linear_combination(std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          a1.f0, 2 * a1.f1, a1.f2, a2.f0, 2 * a2.f1, a2.f2, a3.f0, 2 * a3.f1, a3.f2\r\n\r\n\r\n\r\n                                                                      }, std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          b1.f2, b1.f1, b1.f0, b2.f2, b2.f1, b2.f0, b3.f2, b3.f1, b3.f0\r\n\r\n\r\n\r\n                                                                      }));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const double& a1, const Univariate_Derivative_2 b1, const double& a2, const Univariate_Derivative_2 b2, const double& a3, const Univariate_Derivative_2 b3) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1, b1.f0, a2, b2.f0, a3, b3.f0), Math_Arrays::linear_combination(a1, b1.f1, a2, b2.f1, a3, b3.f1), Math_Arrays::linear_combination(a1, b1.f2, a2, b2.f2, a3, b3.f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const Univariate_Derivative_2 a1, const Univariate_Derivative_2 b1, const Univariate_Derivative_2 a2, const Univariate_Derivative_2 b2, const Univariate_Derivative_2 a3, const Univariate_Derivative_2 b3, const Univariate_Derivative_2 a4, const Univariate_Derivative_2 b4) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1.f0, b1.f0, a2.f0, b2.f0, a3.f0, b3.f0, a4.f0, b4.f0), Math_Arrays::linear_combination(std::vector<double> \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n                                                                          a1.f0, a1.f1, a2.f0, a2.f1, a3.f0, a3.f1, a4.f0, a4.f1\r\n\r\n\r\n\r\n                                                                      }, std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          b1.f1, b1.f0, b2.f1, b2.f0, b3.f1, b3.f0, b4.f1, b4.f0\r\n\r\n\r\n\r\n                                                                      }), Math_Arrays::linear_combination(std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          a1.f0, 2 * a1.f1, a1.f2, a2.f0, 2 * a2.f1, a2.f2, a3.f0, 2 * a3.f1, a3.f2, a4.f0, 2 * a4.f1, a4.f2\r\n\r\n\r\n\r\n                                                                      }, std::vector<double> \r\n\r\n\r\n\r\n                                                                      {\r\n\r\n\r\n\r\n                                                                          b1.f2, b1.f1, b1.f0, b2.f2, b2.f1, b2.f0, b3.f2, b3.f1, b3.f0, b4.f2, b4.f1, b4.f0\r\n\r\n\r\n\r\n                                                                      }));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 linear_combination(const double& a1, const Univariate_Derivative_2 b1, const double& a2, const Univariate_Derivative_2 b2, const double& a3, const Univariate_Derivative_2 b3, const double& a4, const Univariate_Derivative_2 b4) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return Univariate_Derivative_2(Math_Arrays::linear_combination(a1, b1.f0, a2, b2.f0, a3, b3.f0, a4, b4.f0), Math_Arrays::linear_combination(a1, b1.f1, a2, b2.f1, a3, b3.f1, a4, b4.f1), Math_Arrays::linear_combination(a1, b1.f2, a2, b2.f2, a3, b3.f2, a4, b4.f2));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public Univariate_Derivative_2 get_pi() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return PI;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Test for the equality of two univariate derivatives.\r\n\r\n\r\n\r\n     * <p>\r\n\r\n\r\n\r\n     * univariate derivatives are considered equal if they have the same derivatives.\r\n\r\n\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @param other Object to test for equality to this\r\n\r\n\r\n\r\n     * @return true if two univariate derivatives are equal\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public bool equals(Object other) \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (this == other) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            return true;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        if (other instanceof Univariate_Derivative_2) \r\n\r\n\r\n\r\n        {\r\n\r\n\r\n\r\n            const Univariate_Derivative_2 rhs = (Univariate_Derivative_2) other;\r\n\r\n\r\n\r\n            return f0 == rhs.f0 && f1 == rhs.f1 && f2 == rhs.f2;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        return false;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /** Get a hash_code for the univariate derivative.\r\n\r\n\r\n\r\n     * @return a hash code value for this object\r\n\r\n\r\n\r\n     */\r\n\r\n\r\n\r\n    //override\r\n\r\n\r\n\r\n    public int hash_code() \r\n\r\n\r\n\r\n    {\r\n\r\n\r\n\r\n        return 317 - 41 * Double.hash_code(f0) + 57 * Double.hash_code(f1) - 103 * Double.hash_code(f2);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n