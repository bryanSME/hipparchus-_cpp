/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.polynomials;\r\n\r\n\r\n\r\n//import java.lang.reflect.Array;\r\n\r\n//import java.util.Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Represents a polynomial spline function.\r\n\r\n * <p>\r\n\r\n * A <strong>polynomial spline function</strong> consists of a set of\r\n\r\n * <i>interpolating polynomials</i> and an ascending array of domain\r\n\r\n * <i>knot points</i>, determining the intervals over which the spline function\r\n\r\n * is defined by the constituent polynomials.  The polynomials are assumed to\r\n\r\n * have been computed to match the values of another function at the knot\r\n\r\n * points.  The value consistency constraints are not currently enforced by\r\n\r\n * <code>Polynomial_Spline_Function</code> itself, but are assumed to hold among\r\n\r\n * the polynomials and knot points passed to the constructor.</p>\r\n\r\n * <p>\r\n\r\n * N.B.:  The polynomials in the <code>polynomials</code> property must be\r\n\r\n * centered on the knot points to compute the spline function values.\r\n\r\n * See below.</p>\r\n\r\n * <p>\r\n\r\n * The domain of the polynomial spline function is\r\n\r\n * <code>[smallest knot, largest knot]</code>.  Attempts to evaluate the\r\n\r\n * function at values outside of this range generate Illegal_Argument_Exceptions.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * The value of the polynomial spline function for an argument <code>x</code>\r\n\r\n * is computed as follows:\r\n\r\n * <ol>\r\n\r\n * <li>The knot array is searched to find the segment to which <code>x</code>\r\n\r\n * belongs.  If <code>x</code> is less than the smallest knot point or greater\r\n\r\n * than the largest one, an <code>Illegal_Argument_Exception</code>\r\n\r\n * is thrown.</li>\r\n\r\n * <li> Let <code>j</code> be the index of the largest knot point that is less\r\n\r\n * than or equal to <code>x</code>.  The value returned is\r\n\r\n * {@code polynomials[j](x - knot[j])}</li></ol>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 1.5\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Polynomial_Spline_Function : Calculus_Field_Univariate_Function<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Spline segment interval delimiters (knots).\r\n\r\n     * Size is n + 1 for n segments.\r\n\r\n     */\r\n\r\n    private const T knots[];\r\n\r\n\r\n\r\n    /**\r\n\r\n     * The polynomial functions that make up the spline.  The first element\r\n\r\n     * determines the value of the spline over the first subinterval, the\r\n\r\n     * second over the second, etc.   Spline function values are determined by\r\n\r\n     * evaluating these functions at {@code (x - knot[i])} where i is the\r\n\r\n     * knot segment to which x belongs.\r\n\r\n     */\r\n\r\n    private const Field_Polynomial_Function<T> polynomials[];\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Number of spline segments. It is equal to the number of polynomials and\r\n\r\n     * to the number of partition points - 1.\r\n\r\n     */\r\n\r\n    private const int& n;\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a polynomial spline function with the given segment delimiters\r\n\r\n     * and interpolating polynomials.\r\n\r\n     * The constructor copies both arrays and assigns the copies to the knots\r\n\r\n     * and polynomials properties, respectively.\r\n\r\n     *\r\n\r\n     * @param knots Spline segment interval delimiters.\r\n\r\n     * @param polynomials Polynomial functions that make up the spline.\r\n\r\n     * @Null_Argument_Exception if either of the input arrays is {@code null}.\r\n\r\n     * @ if knots has length less than 2.\r\n\r\n     * @ if {@code polynomials.size() != knots.size() - 1}.\r\n\r\n     * @ if the {@code knots} array is not strictly increasing.\r\n\r\n     *\r\n\r\n     */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    public Field_Polynomial_Spline_Function(const T knots[], const Field_Polynomial_Function<T> polynomials[])\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (knots == null ||\r\n\r\n            polynomials == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        if (knots.size() < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION, 2, knots.size(), false);\r\n\r\n        }\r\n\r\n        Math_Utils::check_dimension(polynomials.size(), knots.size() - 1);\r\n\r\n        Math_Arrays::check_order(knots);\r\n\r\n\r\n\r\n        this.n = knots.size() -1;\r\n\r\n        this.knots = knots.clone();\r\n\r\n        this.polynomials = (Field_Polynomial_Function<T>[]) Array.new_instance(Field_Polynomial_Function.class, n);\r\n\r\n        System.arraycopy(polynomials, 0, this.polynomials, 0, n);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the {@link Field} to which the instance belongs.\r\n\r\n     * @return {@link Field} to which the instance belongs\r\n\r\n     */\r\n\r\n    public Field<T> get_field() \r\n\r\n    {\r\n\r\n        return knots[0].get_field();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the value for the function.\r\n\r\n     * See {@link Field_Polynomial_Spline_Function} for details on the algorithm for\r\n\r\n     * computing the value of the function.\r\n\r\n     *\r\n\r\n     * @param v Point for which the function value should be computed.\r\n\r\n     * @return the value.\r\n\r\n     * @ if {@code v} is outside of the domain of the\r\n\r\n     * spline function (smaller than the smallest knot point or larger than the\r\n\r\n     * largest knot point).\r\n\r\n     */\r\n\r\n    public T value(const double v) \r\n\r\n    {\r\n\r\n        return value(get_field().get_zero().add(v));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the value for the function.\r\n\r\n     * See {@link Field_Polynomial_Spline_Function} for details on the algorithm for\r\n\r\n     * computing the value of the function.\r\n\r\n     *\r\n\r\n     * @param v Point for which the function value should be computed.\r\n\r\n     * @return the value.\r\n\r\n     * @ if {@code v} is outside of the domain of the\r\n\r\n     * spline function (smaller than the smallest knot point or larger than the\r\n\r\n     * largest knot point).\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T value(const T v) \r\n\r\n    {\r\n\r\n        Math_Utils::check_range_inclusive(v.get_real(), knots[0].get_real(), knots[n].get_real());\r\n\r\n        int i = Arrays.binary_search(knots, v);\r\n\r\n        if (i < 0) \r\n\r\n        {\r\n\r\n            i = -i - 2;\r\n\r\n        }\r\n\r\n        // This will handle the case where v is the last knot value\r\n\r\n        // There are only n-1 polynomials, so if v is the last knot\r\n\r\n        // then we will use the last polynomial to calculate the value.\r\n\r\n        if ( i >= polynomials.size() ) \r\n\r\n        {\r\n\r\n            i--;\r\n\r\n        }\r\n\r\n        return polynomials[i].value(v.subtract(knots[i]));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the number of spline segments.\r\n\r\n     * It is also the number of polynomials and the number of knot points - 1.\r\n\r\n     *\r\n\r\n     * @return the number of spline segments.\r\n\r\n     */\r\n\r\n    public int get_n() \r\n\r\n    {\r\n\r\n        return n;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a copy of the interpolating polynomials array.\r\n\r\n     * It returns a fresh copy of the array. Changes made to the copy will\r\n\r\n     * not affect the polynomials property.\r\n\r\n     *\r\n\r\n     * @return the interpolating polynomials.\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T>[] get_polynomials() \r\n\r\n    {\r\n\r\n        return polynomials.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get an array copy of the knot points.\r\n\r\n     * It returns a fresh copy of the array. Changes made to the copy\r\n\r\n     * will not affect the knots property.\r\n\r\n     *\r\n\r\n     * @return the knot points.\r\n\r\n     */\r\n\r\n    public std::vector<T> get_knots() \r\n\r\n    {\r\n\r\n        return knots.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Indicates whether a point is within the interpolation range.\r\n\r\n     *\r\n\r\n     * @param x Point.\r\n\r\n     * @return {@code true} if {@code x} is a valid point.\r\n\r\n     */\r\n\r\n    public bool is_valid_point(T x) \r\n\r\n    {\r\n\r\n        if (x.get_real() < knots[0].get_real() ||\r\n\r\n            x.get_real() > knots[n].get_real()) \r\n\r\n            {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Get the derivative of the polynomial spline function.\r\n\r\n     *\r\n\r\n     * @return the derivative function.\r\n\r\n     */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    public Field_Polynomial_Spline_Function<T> polynomial_spline_derivative() \r\n\r\n    {\r\n\r\n        Field_Polynomial_Function<T> derivative_polynomials[] =\r\n\r\n                        (Field_Polynomial_Function<T>[]) Array.new_instance(Field_Polynomial_Function.class, n);\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            derivative_polynomials[i] = polynomials[i].polynomial_derivative();\r\n\r\n        }\r\n\r\n        return Field_Polynomial_Spline_Function<>(knots, derivative_polynomials);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n