/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.polynomials;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Immutable representation of a real polynomial function with real coefficients.\r\n\r\n * <p>\r\n\r\n * <a href="http://mathworld.wolfram.com/Horners_method.html">Horner's Method</a>\r\n\r\n * is used to evaluate the function.</p>\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 1.5\r\n\r\n *\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Polynomial_Function : Calculus_Field_Univariate_Function<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /**\r\n\r\n     * The coefficients of the polynomial, ordered by degree -- i.e., * coefficients[0] is the constant term and coefficients[n] is the\r\n\r\n     * coefficient of x^n where n is the degree of the polynomial.\r\n\r\n     */\r\n\r\n    private const T coefficients[];\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a polynomial with the given coefficients.  The first element\r\n\r\n     * of the coefficients array is the constant term.  Higher degree\r\n\r\n     * coefficients follow in sequence.  The degree of the resulting polynomial\r\n\r\n     * is the index of the last non-null element of the array, or 0 if all elements\r\n\r\n     * are null.\r\n\r\n     * <p>\r\n\r\n     * The constructor makes a copy of the input array and assigns the copy to\r\n\r\n     * the coefficients property.</p>\r\n\r\n     *\r\n\r\n     * @param c Polynomial coefficients.\r\n\r\n     * @Null_Argument_Exception if {@code c} is {@code null}.\r\n\r\n     * @ if {@code c} is empty.\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function(const T c[])\r\n\r\n    {\r\n\r\n        super();\r\n\r\n        th_Utils.check_not_null(c);\r\n\r\n        int n = c.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        while ((n > 1) && (c[n - 1].get_real() == 0)) \r\n\r\n        {\r\n\r\n            --n;\r\n\r\n        }\r\n\r\n        this.coefficients = Math_Arrays::build_array(c[0].get_field(), n);\r\n\r\n        System.arraycopy(c, 0, this.coefficients, 0, n);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the value of the function for the given argument.\r\n\r\n     * <p>\r\n\r\n     *  The value returned is </p><p>\r\n\r\n     *  {@code coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]}\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param x Argument for which the function value should be computed.\r\n\r\n     * @return the value of the polynomial at the given point.\r\n\r\n     *\r\n\r\n     * @see org.hipparchus.analysis.Univariate_Function#valuestatic_cast<double>(\r\n\r\n     */\r\n\r\n    public T value(double x) \r\n\r\n    {\r\n\r\n       return evaluate(coefficients, get_field().get_zero().add(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the value of the function for the given argument.\r\n\r\n     * <p>\r\n\r\n     *  The value returned is </p><p>\r\n\r\n     *  {@code coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]}\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param x Argument for which the function value should be computed.\r\n\r\n     * @return the value of the polynomial at the given point.\r\n\r\n     *\r\n\r\n     * @see org.hipparchus.analysis.Univariate_Function#valuestatic_cast<double>(\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public T value(T x) \r\n\r\n    {\r\n\r\n       return evaluate(coefficients, x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the {@link Field} to which the instance belongs.\r\n\r\n     * @return {@link Field} to which the instance belongs\r\n\r\n     */\r\n\r\n    public Field<T> get_field() \r\n\r\n    {\r\n\r\n        return coefficients[0].get_field();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the degree of the polynomial.\r\n\r\n     *\r\n\r\n     * @return the degree of the polynomial.\r\n\r\n     */\r\n\r\n    public int degree() const \r\n\r\n    {\r\n\r\n        return coefficients.size() - 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a copy of the coefficients array.\r\n\r\n     * <p>\r\n\r\n     * Changes made to the returned copy will not affect the coefficients of\r\n\r\n     * the polynomial.</p>\r\n\r\n     *\r\n\r\n     * @return a fresh copy of the coefficients array.\r\n\r\n     */\r\n\r\n    public std::vector<T> get_coefficients() \r\n\r\n    {\r\n\r\n        return coefficients.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Uses Horner's Method to evaluate the polynomial with the given coefficients at\r\n\r\n     * the argument.\r\n\r\n     *\r\n\r\n     * @param coefficients Coefficients of the polynomial to evaluate.\r\n\r\n     * @param argument Input value.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the value of the polynomial.\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    protected static  T evaluate(std::vector<T> coefficients, T argument)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        T result = coefficients[n - 1];\r\n\r\n        for (int j = n - 2; j >= 0; j--) \r\n\r\n        {\r\n\r\n            result = argument.multiply(result).add(coefficients[j]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Add a polynomial to the instance.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to add.\r\n\r\n     * @return a polynomial which is the sum of the instance and {@code p}.\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> add(const Field_Polynomial_Function<T> p) \r\n\r\n    {\r\n\r\n        // identify the lowest degree polynomial\r\n\r\n        const int low_length  = std::min(coefficients.size(), p.coefficients.size());\r\n\r\n        const int high_length = std::max(coefficients.size(), p.coefficients.size());\r\n\r\n\r\n\r\n        // build the coefficients array\r\n\r\n        std::vector<T> new_coefficients = Math_Arrays::build_array(get_field(), high_length);\r\n\r\n        for (int i{}; i < low_length; ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = coefficients[i].add(p.coefficients[i]);\r\n\r\n        }\r\n\r\n        System.arraycopy((coefficients.size() < p.coefficients.size()) ?\r\n\r\n                         p.coefficients : coefficients, low_length, new_coefficients, low_length, high_length - low_length);\r\n\r\n\r\n\r\n        return Field_Polynomial_Function<>(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtract a polynomial from the instance.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to subtract.\r\n\r\n     * @return a polynomial which is the instance minus {@code p}.\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> subtract(const Field_Polynomial_Function<T> p) \r\n\r\n    {\r\n\r\n        // identify the lowest degree polynomial\r\n\r\n        int low_length  = std::min(coefficients.size(), p.coefficients.size());\r\n\r\n        int high_length = std::max(coefficients.size(), p.coefficients.size());\r\n\r\n\r\n\r\n        // build the coefficients array\r\n\r\n        std::vector<T> new_coefficients = Math_Arrays::build_array(get_field(), high_length);\r\n\r\n        for (int i{}; i < low_length; ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = coefficients[i].subtract(p.coefficients[i]);\r\n\r\n        }\r\n\r\n        if (coefficients.size() < p.coefficients.size()) \r\n\r\n        {\r\n\r\n            for (int i = low_length; i < high_length; ++i) \r\n\r\n            {\r\n\r\n                new_coefficients[i] = p.coefficients[i].negate();\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            System.arraycopy(coefficients, low_length, new_coefficients, low_length, high_length - low_length);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Polynomial_Function<>(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Negate the instance.\r\n\r\n     *\r\n\r\n     * @return a polynomial with all coefficients negated\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> negate() \r\n\r\n    {\r\n\r\n        const std::vector<T> new_coefficients = Math_Arrays::build_array(get_field(), coefficients.size());\r\n\r\n        for (int i{}; i < coefficients.size(); ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = coefficients[i].negate();\r\n\r\n        }\r\n\r\n        return Field_Polynomial_Function<>(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply the instance by a polynomial.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to multiply by.\r\n\r\n     * @return a polynomial equal to this times {@code p}\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> multiply(const Field_Polynomial_Function<T> p) \r\n\r\n    {\r\n\r\n        const Field<T> field = get_field();\r\n\r\n        const std::vector<T> new_coefficients = Math_Arrays::build_array(field, coefficients.size() + p.coefficients.size() - 1);\r\n\r\n\r\n\r\n        for (int i{}; i < new_coefficients.size(); ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = field.get_zero();\r\n\r\n            for (int j = std::max(0, i + 1 - p.coefficients.size());\r\n\r\n                 j < std::min(coefficients.size(), i + 1);\r\n\r\n                 ++j) \r\n\r\n                 {\r\n\r\n                new_coefficients[i] = new_coefficients[i].add(coefficients[j].multiply(p.coefficients[i-j]));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Polynomial_Function<>(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the coefficients of the derivative of the polynomial with the given coefficients.\r\n\r\n     *\r\n\r\n     * @param coefficients Coefficients of the polynomial to differentiate.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    protected static  std::vector<T> differentiate(std::vector<T> coefficients)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        const Field<T> field = coefficients[0].get_field();\r\n\r\n        const std::vector<T> result = Math_Arrays::build_array(field, std::max(1, n - 1));\r\n\r\n        if (n == 1) \r\n\r\n        {\r\n\r\n            result[0] = field.get_zero();\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            for (int i = n - 1; i > 0; i--) \r\n\r\n            {\r\n\r\n                result[i - 1] = coefficients[i].multiply(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an anti-derivative of this polynomial, with 0 constant term.\r\n\r\n     *\r\n\r\n     * @return a polynomial whose derivative has the same coefficients as this polynomial\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> anti_derivative() \r\n\r\n    {\r\n\r\n        const Field<T> field = get_field();\r\n\r\n        const int d = degree();\r\n\r\n        const std::vector<T> anti = Math_Arrays::build_array(field, d + 2);\r\n\r\n        anti[0] = field.get_zero();\r\n\r\n        for (int i{ 1 }; i <= d + 1; i++) \r\n\r\n        {\r\n\r\n            anti[i] = coefficients[i - 1].multiply(1.0 / i);\r\n\r\n        }\r\n\r\n        return Field_Polynomial_Function<>(anti);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the definite integral of this polymomial over the given interval.\r\n\r\n     * <p>\r\n\r\n     * [lower, upper] must describe a finite interval (neither can be infinite\r\n\r\n     * and lower must be less than or equal to upper).\r\n\r\n     *\r\n\r\n     * @param lower lower bound for the integration\r\n\r\n     * @param upper upper bound for the integration\r\n\r\n     * @return the integral of this polymomial over the given interval\r\n\r\n     * @ if the bounds do not describe a finite interval\r\n\r\n     */\r\n\r\n    public T integrate(const double lower, const double upper) \r\n\r\n    {\r\n\r\n        const T zero = get_field().get_zero();\r\n\r\n        return integrate(zero.add(lower), zero.add(upper));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the definite integral of this polymomial over the given interval.\r\n\r\n     * <p>\r\n\r\n     * [lower, upper] must describe a finite interval (neither can be infinite\r\n\r\n     * and lower must be less than or equal to upper).\r\n\r\n     *\r\n\r\n     * @param lower lower bound for the integration\r\n\r\n     * @param upper upper bound for the integration\r\n\r\n     * @return the integral of this polymomial over the given interval\r\n\r\n     * @ if the bounds do not describe a finite interval\r\n\r\n     */\r\n\r\n    public T integrate(const T lower, const T upper) \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(lower.get_real()) || Double.std::isinfinite(upper.get_real())) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INFINITE_BOUND);\r\n\r\n        }\r\n\r\n        if (lower.get_real() > upper.get_real()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND);\r\n\r\n        }\r\n\r\n        const Field_Polynomial_Function<T> anti = anti_derivative();\r\n\r\n        return anti.value(upper).subtract(anti.value(lower));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the derivative as a {@link Field_Polynomial_Function}.\r\n\r\n     *\r\n\r\n     * @return the derivative polynomial.\r\n\r\n     */\r\n\r\n    public Field_Polynomial_Function<T> polynomial_derivative() \r\n\r\n    {\r\n\r\n        return Field_Polynomial_Function<>(differentiate(coefficients));\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n