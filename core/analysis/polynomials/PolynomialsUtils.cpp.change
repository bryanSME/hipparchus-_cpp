/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.Hash_Map;\r\n\r\n//import java.util.List;\r\n\r\n//import java.util.Map;\r\n\r\n\r\n\r\n//import org.hipparchus.fraction.Big_Fraction;\r\n\r\n//import org.hipparchus.util.Combinatorics_Utils;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * A collection of static methods that operate on or return polynomials.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Polynomials_Utils \r\n\r\n{\r\n\r\n\r\n\r\n    /** Coefficients for Chebyshev polynomials. */\r\n\r\n    private static const List<Big_Fraction> CHEBYSHEV_COEFFICIENTS;\r\n\r\n\r\n\r\n    /** Coefficients for Hermite polynomials. */\r\n\r\n    private static const List<Big_Fraction> HERMITE_COEFFICIENTS;\r\n\r\n\r\n\r\n    /** Coefficients for Laguerre polynomials. */\r\n\r\n    private static const List<Big_Fraction> LAGUERRE_COEFFICIENTS;\r\n\r\n\r\n\r\n    /** Coefficients for Legendre polynomials. */\r\n\r\n    private static const List<Big_Fraction> LEGENDRE_COEFFICIENTS;\r\n\r\n\r\n\r\n    /** Coefficients for Jacobi polynomials. */\r\n\r\n    private static const Map<Jacobi_Key, List<Big_Fraction>> JACOBI_COEFFICIENTS;\r\n\r\n\r\n\r\n    static \r\n\r\n    {\r\n\r\n\r\n\r\n        // initialize recurrence for Chebyshev polynomials\r\n\r\n        // T0(X) = 1, T1(X) = 0 + 1 * X\r\n\r\n        CHEBYSHEV_COEFFICIENTS = Array_list<>();\r\n\r\n        CHEBYSHEV_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n        CHEBYSHEV_COEFFICIENTS.add(Big_Fraction.ZERO);\r\n\r\n        CHEBYSHEV_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n\r\n\r\n        // initialize recurrence for Hermite polynomials\r\n\r\n        // H0(X) = 1, H1(X) = 0 + 2 * X\r\n\r\n        HERMITE_COEFFICIENTS = Array_list<>();\r\n\r\n        HERMITE_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n        HERMITE_COEFFICIENTS.add(Big_Fraction.ZERO);\r\n\r\n        HERMITE_COEFFICIENTS.add(Big_Fraction.TWO);\r\n\r\n\r\n\r\n        // initialize recurrence for Laguerre polynomials\r\n\r\n        // L0(X) = 1, L1(X) = 1 - 1 * X\r\n\r\n        LAGUERRE_COEFFICIENTS = Array_list<>();\r\n\r\n        LAGUERRE_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n        LAGUERRE_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n        LAGUERRE_COEFFICIENTS.add(Big_Fraction.MINUS_ONE);\r\n\r\n\r\n\r\n        // initialize recurrence for Legendre polynomials\r\n\r\n        // P0(X) = 1, P1(X) = 0 + 1 * X\r\n\r\n        LEGENDRE_COEFFICIENTS = Array_list<>();\r\n\r\n        LEGENDRE_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n        LEGENDRE_COEFFICIENTS.add(Big_Fraction.ZERO);\r\n\r\n        LEGENDRE_COEFFICIENTS.add(Big_Fraction.ONE);\r\n\r\n\r\n\r\n        // initialize map for Jacobi polynomials\r\n\r\n        JACOBI_COEFFICIENTS = Hash_Map<>();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Private constructor, to prevent instantiation.\r\n\r\n     */\r\n\r\n    private Polynomials_Utils() \r\n\r\n    {\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Chebyshev polynomial of the first kind.\r\n\r\n     * <p><a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev\r\n\r\n     * polynomials of the first kind</a> are orthogonal polynomials.\r\n\r\n     * They can be defined by the following recurrence relations:</p><p>\r\n\r\n     * \\(\r\n\r\n     *    T_0(x) = 1 \\\r\n\r\n     *    T_1(x) = x \\\r\n\r\n     *    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\r\n\r\n     * \\)\r\n\r\n     * </p>\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @return Chebyshev polynomial of specified degree\r\n\r\n     */\r\n\r\n    public static Polynomial_Function create_chebyshev_polynomial(const int degree) \r\n\r\n    {\r\n\r\n        return build_polynomial(degree, CHEBYSHEV_COEFFICIENTS, Recurrence_Coefficients_Generator() \r\n\r\n        {\r\n\r\n            /** Fixed recurrence coefficients. */\r\n\r\n            private const Big_Fraction[] coeffs = { Big_Fraction.ZERO, Big_Fraction.TWO, Big_Fraction.ONE };\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Big_Fraction[] generate(const int& k) \r\n\r\n            {\r\n\r\n                return coeffs;\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Hermite polynomial.\r\n\r\n     * <p><a href="http://mathworld.wolfram.com/HermitePolynomial.html">Hermite\r\n\r\n     * polynomials</a> are orthogonal polynomials.\r\n\r\n     * They can be defined by the following recurrence relations:</p><p>\r\n\r\n     * \\(\r\n\r\n     *  H_0(x) = 1 \\\r\n\r\n     *  H_1(x) = 2x \\\r\n\r\n     *  H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x)\r\n\r\n     * \\)\r\n\r\n     * </p>\r\n\r\n\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @return Hermite polynomial of specified degree\r\n\r\n     */\r\n\r\n    public static Polynomial_Function create_hermite_polynomial(const int degree) \r\n\r\n    {\r\n\r\n        return build_polynomial(degree, HERMITE_COEFFICIENTS, Recurrence_Coefficients_Generator() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Big_Fraction[] generate(const int& k) \r\n\r\n            {\r\n\r\n                return Big_Fraction[] \r\n\r\n                {\r\n\r\n                        Big_Fraction.ZERO, Big_Fraction.TWO, Big_Fraction(2 * k)};\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Laguerre polynomial.\r\n\r\n     * <p><a href="http://mathworld.wolfram.com/LaguerrePolynomial.html">Laguerre\r\n\r\n     * polynomials</a> are orthogonal polynomials.\r\n\r\n     * They can be defined by the following recurrence relations:</p><p>\r\n\r\n     * \\(\r\n\r\n     *   L_0(x) = 1 \\\r\n\r\n     *   L_1(x) = 1 - x \\\r\n\r\n     *   (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x)\r\n\r\n     * \\)\r\n\r\n     * </p>\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @return Laguerre polynomial of specified degree\r\n\r\n     */\r\n\r\n    public static Polynomial_Function create_laguerre_polynomial(const int degree) \r\n\r\n    {\r\n\r\n        return build_polynomial(degree, LAGUERRE_COEFFICIENTS, Recurrence_Coefficients_Generator() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Big_Fraction[] generate(const int& k) \r\n\r\n            {\r\n\r\n                const int& k_p1 = k + 1;\r\n\r\n                return Big_Fraction[] \r\n\r\n                {\r\n\r\n                        Big_Fraction(2 * k + 1, k_p1), Big_Fraction(-1, k_p1), Big_Fraction(k, k_p1)};\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Legendre polynomial.\r\n\r\n     * <p><a href="http://mathworld.wolfram.com/LegendrePolynomial.html">Legendre\r\n\r\n     * polynomials</a> are orthogonal polynomials.\r\n\r\n     * They can be defined by the following recurrence relations:</p><p>\r\n\r\n     * \\(\r\n\r\n     *   P_0(x) = 1 \\\r\n\r\n     *   P_1(x) = x \\\r\n\r\n     *   (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x)\r\n\r\n     * \\)\r\n\r\n     * </p>\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @return Legendre polynomial of specified degree\r\n\r\n     */\r\n\r\n    public static Polynomial_Function create_legendre_polynomial(const int degree) \r\n\r\n    {\r\n\r\n        return build_polynomial(degree, LEGENDRE_COEFFICIENTS, Recurrence_Coefficients_Generator() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Big_Fraction[] generate(const int& k) \r\n\r\n            {\r\n\r\n                const int& k_p1 = k + 1;\r\n\r\n                return Big_Fraction[] \r\n\r\n                {\r\n\r\n                        Big_Fraction.ZERO, Big_Fraction(k + k_p1, k_p1), Big_Fraction(k, k_p1)};\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Jacobi polynomial.\r\n\r\n     * <p><a href="http://mathworld.wolfram.com/JacobiPolynomial.html">Jacobi\r\n\r\n     * polynomials</a> are orthogonal polynomials.\r\n\r\n     * They can be defined by the following recurrence relations:</p><p>\r\n\r\n     * \\(\r\n\r\n     *    P_0^{vw}(x) = 1 \\\r\n\r\n     *    P_{-1}^{vw}(x) = 0 \\\r\n\r\n     *    2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\\r\n\r\n     *    (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\\r\n\r\n     *  - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x)\r\n\r\n     * \\)\r\n\r\n     * </p>\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @param v first exponent\r\n\r\n     * @param w second exponent\r\n\r\n     * @return Jacobi polynomial of specified degree\r\n\r\n     */\r\n\r\n    public static Polynomial_Function create_jacobi_polynomial(const int degree, const int v, const int w) \r\n\r\n    {\r\n\r\n\r\n\r\n        // select the appropriate list\r\n\r\n        const Jacobi_Key key = Jacobi_Key(v, w);\r\n\r\n\r\n\r\n        if (!JACOBI_COEFFICIENTS.contains_key(key)) \r\n\r\n        {\r\n\r\n\r\n\r\n            // allocate a list for v, w\r\n\r\n            const List<Big_Fraction> list = Array_list<>();\r\n\r\n            JACOBI_COEFFICIENTS.put(key, list);\r\n\r\n\r\n\r\n            // Pv,w,0(x) = 1;\r\n\r\n            list.add(Big_Fraction.ONE);\r\n\r\n\r\n\r\n            // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\r\n\r\n            list.add(new Big_Fraction(v - w, 2));\r\n\r\n            list.add(new Big_Fraction(2 + v + w, 2));\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return build_polynomial(degree, JACOBI_COEFFICIENTS.get(key), Recurrence_Coefficients_Generator() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Big_Fraction[] generate(const int& k) \r\n\r\n            {\r\n\r\n                k++;\r\n\r\n                const int& kvw      = k + v + w;\r\n\r\n                const int two_kvw   = kvw + k;\r\n\r\n                const int two_kvw_m1 = two_kvw - 1;\r\n\r\n                const int two_kvw_m2 = two_kvw - 2;\r\n\r\n                const int den      = 2 * k *  kvw * two_kvw_m2;\r\n\r\n\r\n\r\n                return Big_Fraction[] \r\n\r\n                {\r\n\r\n                    Big_Fraction(two_kvw_m1 * (v * v - w * w), den), Big_Fraction(two_kvw_m1 * two_kvw * two_kvw_m2, den), Big_Fraction(2 * (k + v - 1) * (k + w - 1) * two_kvw, den)\r\n\r\n                };\r\n\r\n            }\r\n\r\n        });\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Inner class for Jacobi polynomials keys. */\r\n\r\n    private static class Jacobi_Key \r\n\r\n    {\r\n\r\n\r\n\r\n        /** First exponent. */\r\n\r\n        private const int v;\r\n\r\n\r\n\r\n        /** Second exponent. */\r\n\r\n        private const int w;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param v first exponent\r\n\r\n         * @param w second exponent\r\n\r\n         */\r\n\r\n        Jacobi_Key(const int v, const int w) \r\n\r\n        {\r\n\r\n            this.v = v;\r\n\r\n            this.w = w;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Get hash code.\r\n\r\n         * @return hash code\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public int hash_code() \r\n\r\n        {\r\n\r\n            return (v << 16) ^ w;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Check if the instance represent the same key as another instance.\r\n\r\n         * @param key other key\r\n\r\n         * @return true if the instance and the other key refer to the same polynomial\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public bool equals(const Object key) \r\n\r\n        {\r\n\r\n\r\n\r\n            if ((key == null) || !(key instanceof Jacobi_Key)) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n\r\n\r\n            const Jacobi_Key other_k = (Jacobi_Key) key;\r\n\r\n            return (v == other_k.v) && (w == other_k.w);\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the coefficients of the polynomial \\(P_s(x)\\)\r\n\r\n     * whose values at point {@code x} will be the same as the those from the\r\n\r\n     * original polynomial \\(P(x)\\) when computed at {@code x + shift}.\r\n\r\n     * <p>\r\n\r\n     * More precisely, let \\(\\Delta = \\) {@code shift} and let\r\n\r\n     * \\(P_s(x) = P(x + \\Delta)\\).  The returned array\r\n\r\n     * consists of the coefficients of \\(P_s\\).  So if \\(a_0, ..., a_{n-1}\\)\r\n\r\n     * are the coefficients of \\(P\\), then the returned array\r\n\r\n     * \\(b_0, ..., b_{n-1}\\) satisfies the identity\r\n\r\n     * \\(\\sum_{i=0}^{n-1} b_i x^i = \\sum_{i=0}^{n-1} a_i (x + \\Delta)^i\\) for all \\(x\\).\r\n\r\n     *\r\n\r\n     * @param coefficients Coefficients of the original polynomial.\r\n\r\n     * @param shift Shift value.\r\n\r\n     * @return the coefficients \\(b_i\\) of the shifted\r\n\r\n     * polynomial.\r\n\r\n     */\r\n\r\n    public static std::vector<double> shift(const std::vector<double> coefficients, const double shift) \r\n\r\n    {\r\n\r\n        const int dp1 = coefficients.size();\r\n\r\n        const std::vector<double> new_coefficients = std::vector<double>(dp1];\r\n\r\n\r\n\r\n        // Pascal triangle.\r\n\r\n        const std::vector<std::vector<int>> coeff = int[dp1][dp1];\r\n\r\n        for (int i{}; i < dp1; i++)\r\n\r\n        {\r\n\r\n            for(const int& j = 0; j <= i; j++)\r\n\r\n            {\r\n\r\n                coeff[i][j] = static_cast<int>( Combinatorics_Utils.binomial_coefficient(i, j);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // First polynomial coefficient.\r\n\r\n        for (int i{}; i < dp1; i++)\r\n\r\n        {\r\n\r\n            new_coefficients[0] += coefficients[i] * std::pow(shift, i);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Superior order.\r\n\r\n        const int d = dp1 - 1;\r\n\r\n        for (int i{}; i < d; i++) \r\n\r\n        {\r\n\r\n            for (int j = i; j < d; j++)\r\n\r\n            {\r\n\r\n                new_coefficients[i + 1] += coeff[j + 1][j - i] *\r\n\r\n                    coefficients[j + 1] * std::pow(shift, j - i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return new_coefficients;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /** Get the coefficients array for a given degree.\r\n\r\n     * @param degree degree of the polynomial\r\n\r\n     * @param coefficients list where the computed coefficients are stored\r\n\r\n     * @param generator recurrence coefficients generator\r\n\r\n     * @return coefficients array\r\n\r\n     */\r\n\r\n    private static Polynomial_Function build_polynomial(const int degree, const List<Big_Fraction> coefficients, const Recurrence_Coefficients_Generator generator) \r\n\r\n    {\r\n\r\n\r\n\r\n        synchronized (coefficients) \r\n\r\n        {\r\n\r\n            const int max_degree = static_cast<int>( std::floor(std::sqrt(2 * coefficients.size())) - 1;\r\n\r\n            if (degree > max_degree) \r\n\r\n            {\r\n\r\n                compute_up_to_degree(degree, max_degree, generator, coefficients);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // coefficient  for polynomial 0 is  l [0]\r\n\r\n        // coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\r\n\r\n        // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\r\n\r\n        // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\r\n\r\n        // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\r\n\r\n        // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\r\n\r\n        // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\r\n\r\n        // ...\r\n\r\n        const int start = degree * (degree + 1) / 2;\r\n\r\n\r\n\r\n        const std::vector<double> a = std::vector<double>(degree + 1];\r\n\r\n        for (int i{}; i <= degree; ++i) \r\n\r\n        {\r\n\r\n            a[i] = coefficients.get(start + i).double_value();\r\n\r\n        }\r\n\r\n\r\n\r\n        // build the polynomial\r\n\r\n        return Polynomial_Function(a);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute polynomial coefficients up to a given degree.\r\n\r\n     * @param degree maximal degree\r\n\r\n     * @param max_degree current maximal degree\r\n\r\n     * @param generator recurrence coefficients generator\r\n\r\n     * @param coefficients list where the computed coefficients should be appended\r\n\r\n     */\r\n\r\n    private static void compute_up_to_degree(const int degree, const int max_degree, const Recurrence_Coefficients_Generator generator, const List<Big_Fraction> coefficients) \r\n\r\n    {\r\n\r\n\r\n\r\n        int start_k = (max_degree - 1) * max_degree / 2;\r\n\r\n        for (int k = max_degree; k < degree; ++k) \r\n\r\n        {\r\n\r\n\r\n\r\n            // start indices of two previous polynomials Pk(X) and Pk-1(X)\r\n\r\n            int start_km1 = start_k;\r\n\r\n            start_k += k;\r\n\r\n\r\n\r\n            // Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)\r\n\r\n            Big_Fraction[] ai = generator.generate(k);\r\n\r\n\r\n\r\n            Big_Fraction ck     = coefficients.get(start_k);\r\n\r\n            Big_Fraction ckm1   = coefficients.get(start_km1);\r\n\r\n\r\n\r\n            // degree 0 coefficient\r\n\r\n            coefficients.add(ck.multiply(ai[0]).subtract(ckm1.multiply(ai[2])));\r\n\r\n\r\n\r\n            // degree 1 to degree k-1 coefficients\r\n\r\n            for (int i{ 1 }; i < k; ++i) \r\n\r\n            {\r\n\r\n                const Big_Fraction ck_prev = ck;\r\n\r\n                ck     = coefficients.get(start_k + i);\r\n\r\n                ckm1   = coefficients.get(start_km1 + i);\r\n\r\n                coefficients.add(ck.multiply(ai[0]).add(ck_prev.multiply(ai[1])).subtract(ckm1.multiply(ai[2])));\r\n\r\n            }\r\n\r\n\r\n\r\n            // degree k coefficient\r\n\r\n            const Big_Fraction ck_prev = ck;\r\n\r\n            ck = coefficients.get(start_k + k);\r\n\r\n            coefficients.add(ck.multiply(ai[0]).add(ck_prev.multiply(ai[1])));\r\n\r\n\r\n\r\n            // degree k+1 coefficient\r\n\r\n            coefficients.add(ck.multiply(ai[1]));\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Interface for recurrence coefficients generation. */\r\n\r\n    private interface Recurrence_Coefficients_Generator \r\n\r\n    {\r\n\r\n        /**\r\n\r\n         * Generate recurrence coefficients.\r\n\r\n         * @param k highest degree of the polynomials used in the recurrence\r\n\r\n         * @return an array of three coefficients such that\r\n\r\n         * \\( P_{k+1}(x) = (a[0] + a[1] x) P_k(x) - a[2] P_{k-1}(x) \\)\r\n\r\n         */\r\n\r\n        Big_Fraction[] generate(const int& k);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n