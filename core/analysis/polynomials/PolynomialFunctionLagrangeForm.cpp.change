/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.polynomials;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n#include "../UnivariateFunction.h"\r\n\r\n#include "../../util/MathArrays.h"\r\n\r\n#include <vector>\r\n\r\n/**\r\n\r\n * Implements the representation of a real polynomial function in\r\n\r\n * <a href="http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html">\r\n\r\n * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\r\n\r\n * Analysis</b>, ISBN 038795452X, chapter 2.\r\n\r\n * <p>\r\n\r\n * The approximated function should be smooth enough for Lagrange polynomial\r\n\r\n * to work well. Otherwise, consider using splines instead.</p>\r\n\r\n *\r\n\r\n */\r\n\r\nclass Polynomial_Function_Lagrange_Form : Univariate_Function \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /**\r\n\r\n     * The coefficients of the polynomial, ordered by degree -- i.e.\r\n\r\n     * coefficients[0] is the constant term and coefficients[n] is the\r\n\r\n     * coefficient of x^n where n is the degree of the polynomial.\r\n\r\n     */\r\n\r\n    std::vector<double> my_coefficients;\r\n\r\n    /**\r\n\r\n     * Interpolating points (abscissas).\r\n\r\n     */\r\n\r\n    const std::vector<double> my_x;\r\n\r\n    /**\r\n\r\n     * Function values at interpolating points.\r\n\r\n     */\r\n\r\n    const std::vector<double> my_y;\r\n\r\n    /**\r\n\r\n     * Whether the polynomial coefficients are available.\r\n\r\n     */\r\n\r\n    bool my_coefficients_computed;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Evaluate the Lagrange polynomial using\r\n\r\n     * <a href="http://mathworld.wolfram.com/NevillesAlgorithm.html">\r\n\r\n     * Neville's Algorithm</a>. It takes O(n^2) time.\r\n\r\n     *\r\n\r\n     * @param x Interpolating points array.\r\n\r\n     * @param y Interpolating values array.\r\n\r\n     * @param z Point at which the function value is to be computed.\r\n\r\n     * @return the function value.\r\n\r\n     * @ if {@code x} and {@code y} have\r\n\r\n     * different lengths.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code x} is not sorted in strictly increasing order.\r\n\r\n     * @ if the size of {@code x} is less\r\n\r\n     * than 2.\r\n\r\n     */\r\n\r\n    static double evaluate_internal(const std::vector<double>& x, const std::vector<double>& y, const double& z)\r\n\r\n    {\r\n\r\n        int nearest{};\r\n\r\n        const int n = x.size();\r\n\r\n        auto c = std::vector<double>(n);\r\n\r\n        auto d = std::vector<double>(n);\r\n\r\n        double min_dist{ INFINITY };\r\n\r\n        for (int i{}; i < n; i++)\r\n\r\n        {\r\n\r\n            // initialize the difference arrays\r\n\r\n            c[i] = y[i];\r\n\r\n            d[i] = y[i];\r\n\r\n            // find out the abscissa closest to z\r\n\r\n            const double dist = std::abs(z - x[i]);\r\n\r\n            if (dist < min_dist)\r\n\r\n            {\r\n\r\n                nearest = i;\r\n\r\n                min_dist = dist;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // initial approximation to the function value at z\r\n\r\n        double value = y[nearest];\r\n\r\n\r\n\r\n        for (int i{ 1 }; i < n; i++)\r\n\r\n        {\r\n\r\n            for (int j{}; j < n - i; j++)\r\n\r\n            {\r\n\r\n                const double tc = x[j] - z;\r\n\r\n                const double td = x[i + j] - z;\r\n\r\n                const double divider = x[j] - x[i + j];\r\n\r\n                // update the difference arrays\r\n\r\n                const double w = (c[j + 1] - d[j]) / divider;\r\n\r\n                c[j] = tc * w;\r\n\r\n                d[j] = td * w;\r\n\r\n            }\r\n\r\n            // sum up the difference terms to get the const value\r\n\r\n            if (nearest < 0.5 * (n - i + 1))\r\n\r\n            {\r\n\r\n                value += c[nearest];    // fork down\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                nearest--;\r\n\r\n                value += d[nearest];    // fork up\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return value;\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Construct a Lagrange polynomial with the given abscissas and function\r\n\r\n     * values. The order of interpolating points are not important.\r\n\r\n     * <p>\r\n\r\n     * The constructor makes copy of the input arrays and assigns them.</p>\r\n\r\n     *\r\n\r\n     * @param x interpolating points\r\n\r\n     * @param y function values at interpolating points\r\n\r\n     * @ if the array lengths are different.\r\n\r\n     * @ if the number of points is less than 2.\r\n\r\n     * @\r\n\r\n     * if two abscissae have the same value.\r\n\r\n     */\r\n\r\n    Polynomial_Function_Lagrange_Form(const std::vector<double>& x, const std::vector<double>& y)\r\n\r\n        : my_x{ std::vector<double>(x.size()) }, my_y{std::vector<double>(y.size())}\r\n\r\n    {\r\n\r\n        System.arraycopy(x, 0, my_x, 0, x.size());\r\n\r\n        System.arraycopy(y, 0, my_y, 0, y.size());\r\n\r\n        coefficients_computed = false;\r\n\r\n\r\n\r\n        if (!verify_interpolation_array(x, y, false)) \r\n\r\n        {\r\n\r\n            Math_Arrays::sort_in_place(my_x, my_y);\r\n\r\n            // Second check in case some abscissa is duplicated.\r\n\r\n            verify_interpolation_array(my_x, my_y, true);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculate the function value at the given point.\r\n\r\n     *\r\n\r\n     * @param z Point at which the function value is to be computed.\r\n\r\n     * @return the function value.\r\n\r\n     * @ if {@code x} and {@code y} have\r\n\r\n     * different lengths.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code x} is not sorted in strictly increasing order.\r\n\r\n     * @ if the size of {@code x} is less\r\n\r\n     * than 2.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    double value(const double& z) \r\n\r\n    {\r\n\r\n        return evaluate_internal(my_x, my_y, z);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the degree of the polynomial.\r\n\r\n     *\r\n\r\n     * @return the degree of the polynomial\r\n\r\n     */\r\n\r\n    int degree() const \r\n\r\n    {\r\n\r\n        return my_x.size() - 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a copy of the interpolating points array.\r\n\r\n     * <p>\r\n\r\n     * Changes made to the returned copy will not affect the polynomial.</p>\r\n\r\n     *\r\n\r\n     * @return a fresh copy of the interpolating points array\r\n\r\n     */\r\n\r\n    std::vector<double> get_interpolating_points() const\r\n\r\n    {\r\n\r\n        auto out = std::vector<double>(my_x.size());\r\n\r\n        System.arraycopy(my_x, 0, out, 0, my_x.size());\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a copy of the interpolating values array.\r\n\r\n     * <p>\r\n\r\n     * Changes made to the returned copy will not affect the polynomial.</p>\r\n\r\n     *\r\n\r\n     * @return a fresh copy of the interpolating values array\r\n\r\n     */\r\n\r\n    std::vector<double> get_interpolating_values() \r\n\r\n    {\r\n\r\n        auto out = std::vector<double>(my_y.size());\r\n\r\n        System.arraycopy(my_y, 0, out, 0, y.size());\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a copy of the coefficients array.\r\n\r\n     * <p>\r\n\r\n     * Changes made to the returned copy will not affect the polynomial.</p>\r\n\r\n     * <p>\r\n\r\n     * Note that coefficients computation can be ill-conditioned. Use with caution\r\n\r\n     * and only when it is necessary.</p>\r\n\r\n     *\r\n\r\n     * @return a fresh copy of the coefficients array\r\n\r\n     */\r\n\r\n    std::vector<double> get_coefficients() \r\n\r\n    {\r\n\r\n        if (!my_coefficients_computed) \r\n\r\n        {\r\n\r\n            compute_coefficients();\r\n\r\n        }\r\n\r\n        auto out = std::vector<double>(my_coefficients.size());\r\n\r\n        System.arraycopy(my_coefficients, 0, out, 0, my_coefficients.size());\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Evaluate the Lagrange polynomial using\r\n\r\n     * <a href="http://mathworld.wolfram.com/NevillesAlgorithm.html">\r\n\r\n     * Neville's Algorithm</a>. It takes O(n^2) time.\r\n\r\n     *\r\n\r\n     * @param x Interpolating points array.\r\n\r\n     * @param y Interpolating values array.\r\n\r\n     * @param z Point at which the function value is to be computed.\r\n\r\n     * @return the function value.\r\n\r\n     * @ if {@code x} and {@code y} have\r\n\r\n     * different lengths.\r\n\r\n     * @\r\n\r\n     * if {@code x} is not sorted in strictly increasing order.\r\n\r\n     * @ if the size of {@code x} is less\r\n\r\n     * than 2.\r\n\r\n     */\r\n\r\n    static double evaluate(const std::vector<double>& x, const std::vector<double>& y, const double& z)\r\n\r\n    {\r\n\r\n        if (verify_interpolation_array(x, y, false)) \r\n\r\n        {\r\n\r\n            return evaluate_internal(x, y, z);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Array is not sorted.\r\n\r\n        auto x_new = std::vector<double>(x.size());\r\n\r\n        auto y_new = std::vector<double>(y.size());\r\n\r\n        System.arraycopy(x, 0, x_new, 0, x.size());\r\n\r\n        System.arraycopy(y, 0, y_new, 0, y.size());\r\n\r\n\r\n\r\n        Math_Arrays::sort_in_place(x_new, y_new);\r\n\r\n        // Second check in case some abscissa is duplicated.\r\n\r\n        verify_interpolation_array(x_new, y_new, true);\r\n\r\n        return evaluate_internal(x_new, y_new, z);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check that the interpolation arrays are valid.\r\n\r\n     * The arrays features checked by this method are that both arrays have the\r\n\r\n     * same length and this length is at least 2.\r\n\r\n     *\r\n\r\n     * @param x Interpolating points array.\r\n\r\n     * @param y Interpolating values array.\r\n\r\n     * @param abort Whether to throw an exception if {@code x} is not sorted.\r\n\r\n     * @ if the array lengths are different.\r\n\r\n     * @ if the number of points is less than 2.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code x} is not sorted in strictly increasing order and {@code abort}\r\n\r\n     * is {@code true}.\r\n\r\n     * @return {@code false} if the {@code x} is not sorted in increasing order, * {@code true} otherwise.\r\n\r\n     * @see #evaluate(std::vector<double>, std::vector<double>, double)\r\n\r\n     * @see #compute_coefficients()\r\n\r\n     */\r\n\r\n    static bool verify_interpolation_array(const std::vector<double>& x, const std::vector<double>& y, bool abort)\r\n\r\n    {\r\n\r\n        Math_Arrays::check_equal_length(x, y);\r\n\r\n        if (x.size() < 2) \r\n\r\n        {\r\n\r\n            throw std::exception("Localized_Core_Formats.WRONG_NUMBER_OF_POINTS, 2, x.size(), true);");\r\n\r\n            //throw (Localized_Core_Formats.WRONG_NUMBER_OF_POINTS, 2, x.size(), true);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Math_Arrays::check_order(x, Math_Arrays::Order_Direction::INCREASING, true, abort);\r\n\r\n    }\r\n\r\n\r\n\r\nprotected:\r\n\r\n        /**\r\n\r\n         * Calculate the coefficients of Lagrange polynomial from the\r\n\r\n         * interpolation data. It takes O(n^2) time.\r\n\r\n         * Note that this computation can be ill-conditioned: Use with caution\r\n\r\n         * and only when it is necessary.\r\n\r\n         */\r\n\r\n        void compute_coefficients()\r\n\r\n        {\r\n\r\n            const int n = degree() + 1;\r\n\r\n            my_coefficients = std::vector<double>(n);\r\n\r\n            for (int i{}; i < n; i++)\r\n\r\n            {\r\n\r\n                my_coefficients[i] = 0;\r\n\r\n            }\r\n\r\n\r\n\r\n            // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\r\n\r\n            auto c = std::vector<double>(n + 1);\r\n\r\n            c[0] = 1.0;\r\n\r\n            for (int i{}; i < n; i++)\r\n\r\n            {\r\n\r\n                for (int j = i; j > 0; j--)\r\n\r\n                {\r\n\r\n                    c[j] = c[j - 1] - c[j] * my_x[i];\r\n\r\n                }\r\n\r\n                c[0] *= -my_x[i];\r\n\r\n                c[i + 1] = 1;\r\n\r\n            }\r\n\r\n\r\n\r\n            auto tc = std::vector<double>(n);\r\n\r\n            for (int i{}; i < n; i++)\r\n\r\n            {\r\n\r\n                // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\r\n\r\n                double d{ 1 };\r\n\r\n                for (int j{}; j < n; j++)\r\n\r\n                {\r\n\r\n                    if (i != j)\r\n\r\n                    {\r\n\r\n                        d *= my_x[i] - my_x[j];\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                const double t = my_y[i] / d;\r\n\r\n                // Lagrange polynomial is the sum of n terms, each of which is a\r\n\r\n                // polynomial of degree n-1. tc[] are the coefficients of the i-th\r\n\r\n                // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\r\n\r\n                tc[n - 1] = c[n];     // actually c[n] = 1\r\n\r\n                my_coefficients[n - 1] += t * tc[n - 1];\r\n\r\n                for (int j{ n - 2 }; j >= 0; j--)\r\n\r\n                {\r\n\r\n                    tc[j] = c[j + 1] + tc[j + 1] * my_x[i];\r\n\r\n                    my_coefficients[j] += t * tc[j];\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            my_coefficients_computed = true;\r\n\r\n        }\r\n\r\n};\r\n