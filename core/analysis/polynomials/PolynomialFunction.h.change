/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.polynomials;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n//import java.util.Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Field_Univariate_Function;\r\n\r\n//import org.hipparchus.analysis.ParametricUnivariate_Function;\r\n\r\n//import org.hipparchus.analysis.differentiation.Derivative;\r\n\r\n//import org.hipparchus.analysis.differentiation.Univariate_Differentiable_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n#include <vector>\r\n\r\n#include <string>\r\n\r\n\r\n\r\n/**\r\n\r\n * Immutable representation of a real polynomial function with real coefficients.\r\n\r\n * <p>\r\n\r\n * <a href="http://mathworld.wolfram.com/Horners_method.html">Horner's Method</a>\r\n\r\n * is used to evaluate the function.</p>\r\n\r\n *\r\n\r\n */\r\n\r\nclass Polynomial_Function : Univariate_Differentiable_Function, Field_Univariate_Function\r\n\r\n{\r\n\r\n\r\n\r\nprivate:\r\n\r\n    /**\r\n\r\n     * The coefficients of the polynomial, ordered by degree -- i.e., * coefficients[0] is the constant term and coefficients[n] is the\r\n\r\n     * coefficient of x^n where n is the degree of the polynomial.\r\n\r\n     */\r\n\r\n    const std::vector<double> my_coefficients;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a string representing a coefficient, removing ".0" endings.\r\n\r\n     *\r\n\r\n     * @param coeff Coefficient.\r\n\r\n     * @return a string representation of {@code coeff}.\r\n\r\n     */\r\n\r\n    static std::string to_string(double coeff)\r\n\r\n    {\r\n\r\n        const std::string c = std::to_string(coeff);\r\n\r\n        if (c.ends_with(".0"))\r\n\r\n        {\r\n\r\n            return c.substring(0, c.size()() - 2);\r\n\r\n        }\r\n\r\n        else\r\n\r\n        {\r\n\r\n            return c;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\nprotected:\r\n\r\n    /**\r\n\r\n     * Uses Horner's Method to evaluate the polynomial with the given coefficients at\r\n\r\n     * the argument.\r\n\r\n     *\r\n\r\n     * @param coefficients Coefficients of the polynomial to evaluate.\r\n\r\n     * @param argument Input value.\r\n\r\n     * @return the value of the polynomial.\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n     */\r\n\r\n    static double evaluate(const std::vector<double>& coefficients, const double& argument)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0)\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        double result = coefficients[n - 1];\r\n\r\n        for (int j = n - 2; j >= 0; j--)\r\n\r\n        {\r\n\r\n            result = argument * result + coefficients[j];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the coefficients of the derivative of the polynomial with the given coefficients.\r\n\r\n     *\r\n\r\n     * @param coefficients Coefficients of the polynomial to differentiate.\r\n\r\n     * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n     */\r\n\r\n    static std::vector<double> differentiate(std::vector<double> coefficients)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0)\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        if (n == 1)\r\n\r\n        {\r\n\r\n            return std::vector<double>(]{ 0 };\r\n\r\n        }\r\n\r\n        std::vector<double> result = std::vector<double>(n - 1];\r\n\r\n        for (int i = n - 1; i > 0; i--)\r\n\r\n        {\r\n\r\n            result[i - 1] = i * coefficients[i];\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Construct a polynomial with the given coefficients.  The first element\r\n\r\n     * of the coefficients array is the constant term.  Higher degree\r\n\r\n     * coefficients follow in sequence.  The degree of the resulting polynomial\r\n\r\n     * is the index of the last non-null element of the array, or 0 if all elements\r\n\r\n     * are null.\r\n\r\n     * <p>\r\n\r\n     * The constructor makes a copy of the input array and assigns the copy to\r\n\r\n     * the coefficients property.</p>\r\n\r\n     *\r\n\r\n     * @param c Polynomial coefficients.\r\n\r\n     * @Null_Argument_Exception if {@code c} is {@code null}.\r\n\r\n     * @ if {@code c} is empty.\r\n\r\n     */\r\n\r\n    Polynomial_Function(std::vector<double>& c)\r\n\r\n    {\r\n\r\n        //super();\r\n\r\n        //Math_Utils::check_not_null(c);\r\n\r\n        int n = c.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        while ((n > 1) && (c[n - 1] == 0)) \r\n\r\n        {\r\n\r\n            --n;\r\n\r\n        }\r\n\r\n        my_coefficients = std::vector<double>(n);\r\n\r\n        System.arraycopy(c, 0, this.coefficients, 0, n);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the value of the function for the given argument.\r\n\r\n     * <p>\r\n\r\n     *  The value returned is </p><p>\r\n\r\n     *  {@code coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]}\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param x Argument for which the function value should be computed.\r\n\r\n     * @return the value of the polynomial at the given point.\r\n\r\n     *\r\n\r\n     * @see org.hipparchus.analysis.Univariate_Function#valuestatic_cast<double>(\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    double value(const double& x) \r\n\r\n    {\r\n\r\n       return evaluate(my_coefficients, x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the degree of the polynomial.\r\n\r\n     *\r\n\r\n     * @return the degree of the polynomial.\r\n\r\n     */\r\n\r\n    int degree() const \r\n\r\n    {\r\n\r\n        return my_coefficients.size() - 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a copy of the coefficients array.\r\n\r\n     * <p>\r\n\r\n     * Changes made to the returned copy will not affect the coefficients of\r\n\r\n     * the polynomial.</p>\r\n\r\n     *\r\n\r\n     * @return a fresh copy of the coefficients array.\r\n\r\n     */\r\n\r\n    std::vector<double> get_coefficients() const\r\n\r\n    {\r\n\r\n        return my_coefficients;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    <T extends Derivative<T>> T value(const T t)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        T result = t.get_field().get_zero().add(coefficients[n - 1]);\r\n\r\n        for (int j = n - 2; j >= 0; j--) \r\n\r\n        {\r\n\r\n            result = result.multiply(t).add(coefficients[j]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * @ if {@code coefficients} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code coefficients} is {@code null}.\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n     T value(const T t)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(coefficients);\r\n\r\n        int n = coefficients.size();\r\n\r\n        if (n == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\r\n\r\n        }\r\n\r\n        T result = t.get_field().get_zero().add(coefficients[n - 1]);\r\n\r\n        for (int j = n - 2; j >= 0; j--) \r\n\r\n        {\r\n\r\n            result = result.multiply(t).add(coefficients[j]);\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Add a polynomial to the instance.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to add.\r\n\r\n     * @return a polynomial which is the sum of the instance and {@code p}.\r\n\r\n     */\r\n\r\n    Polynomial_Function add(const Polynomial_Function p) \r\n\r\n    {\r\n\r\n        // identify the lowest degree polynomial\r\n\r\n        const int low_length  = std::min(coefficients.size(), p.coefficients.size());\r\n\r\n        const int high_length = std::max(coefficients.size(), p.coefficients.size());\r\n\r\n\r\n\r\n        // build the coefficients array\r\n\r\n        std::vector<double> new_coefficients = std::vector<double>(high_length];\r\n\r\n        for (int i{}; i < low_length; ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = coefficients[i] + p.coefficients[i];\r\n\r\n        }\r\n\r\n        System.arraycopy((coefficients.size() < p.coefficients.size()) ?\r\n\r\n                         p.coefficients : coefficients, low_length, new_coefficients, low_length, high_length - low_length);\r\n\r\n\r\n\r\n        return Polynomial_Function(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtract a polynomial from the instance.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to subtract.\r\n\r\n     * @return a polynomial which is the instance minus {@code p}.\r\n\r\n     */\r\n\r\n    Polynomial_Function subtract(const Polynomial_Function p) \r\n\r\n    {\r\n\r\n        // identify the lowest degree polynomial\r\n\r\n        int low_length  = std::min(coefficients.size(), p.coefficients.size());\r\n\r\n        int high_length = std::max(coefficients.size(), p.coefficients.size());\r\n\r\n\r\n\r\n        // build the coefficients array\r\n\r\n        std::vector<double> new_coefficients = std::vector<double>(high_length];\r\n\r\n        for (int i{}; i < low_length; ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = coefficients[i] - p.coefficients[i];\r\n\r\n        }\r\n\r\n        if (coefficients.size() < p.coefficients.size()) \r\n\r\n        {\r\n\r\n            for (int i = low_length; i < high_length; ++i) \r\n\r\n            {\r\n\r\n                new_coefficients[i] = -p.coefficients[i];\r\n\r\n            }\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            System.arraycopy(coefficients, low_length, new_coefficients, low_length, high_length - low_length);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Polynomial_Function(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Negate the instance.\r\n\r\n     *\r\n\r\n     * @return a polynomial with all coefficients negated\r\n\r\n     */\r\n\r\n    Polynomial_Function negate() \r\n\r\n    {\r\n\r\n        std::vector<double> new_coefficients = std::vector<double>(coefficients.size()];\r\n\r\n        for (int i{}; i < coefficients.size(); ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = -coefficients[i];\r\n\r\n        }\r\n\r\n        return Polynomial_Function(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply the instance by a polynomial.\r\n\r\n     *\r\n\r\n     * @param p Polynomial to multiply by.\r\n\r\n     * @return a polynomial equal to this times {@code p}\r\n\r\n     */\r\n\r\n    Polynomial_Function multiply(const Polynomial_Function p) \r\n\r\n    {\r\n\r\n        auto new_coefficients = std::vector<double>(coefficients.size() + p.coefficients.size() - 1);\r\n\r\n\r\n\r\n        for (int i{}; i < new_coefficients.size(); ++i) \r\n\r\n        {\r\n\r\n            new_coefficients[i] = 0;\r\n\r\n            for (int j = std::max(0, i + 1 - p.coefficients.size());\r\n\r\n                 j < std::min(coefficients.size(), i + 1);\r\n\r\n                 ++j) \r\n\r\n            {\r\n\r\n                new_coefficients[i] += coefficients[j] * p.coefficients[i-j];\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return Polynomial_Function(new_coefficients);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an anti-derivative of this polynomial, with 0 constant term.\r\n\r\n     *\r\n\r\n     * @return a polynomial whose derivative has the same coefficients as this polynomial\r\n\r\n     */\r\n\r\n    Polynomial_Function anti_derivative() \r\n\r\n    {\r\n\r\n        const int d = degree();\r\n\r\n        auto anti = std::vector<double>(d + 2);\r\n\r\n        anti[0] = 0d;\r\n\r\n        for (int i{ 1 }; i <= d + 1; i++) \r\n\r\n        {\r\n\r\n            anti[i] = coefficients[i - 1]  / i;\r\n\r\n        }\r\n\r\n        return Polynomial_Function(anti);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the definite integral of this polymomial over the given interval.\r\n\r\n     * <p>\r\n\r\n     * [lower, upper] must describe a finite interval (neither can be infinite\r\n\r\n     * and lower must be less than or equal to upper).\r\n\r\n     *\r\n\r\n     * @param lower lower bound for the integration\r\n\r\n     * @param upper upper bound for the integration\r\n\r\n     * @return the integral of this polymomial over the given interval\r\n\r\n     * @ if the bounds do not describe a finite interval\r\n\r\n     */\r\n\r\n    double integrate(const double lower, const double upper) \r\n\r\n    {\r\n\r\n        if (Double.std::isinfinite(lower) || Double.std::isinfinite(upper)) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INFINITE_BOUND);\r\n\r\n        }\r\n\r\n        if (lower > upper) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND);\r\n\r\n        }\r\n\r\n        const Polynomial_Function anti = anti_derivative();\r\n\r\n        return anti.value(upper) - anti.value(lower);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the derivative as a {@link Polynomial_Function}.\r\n\r\n     *\r\n\r\n     * @return the derivative polynomial.\r\n\r\n     */\r\n\r\n    Polynomial_Function polynomial_derivative() \r\n\r\n    {\r\n\r\n        return Polynomial_Function(differentiate(coefficients));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a string representation of the polynomial.\r\n\r\n     *\r\n\r\n     * <p>The representation is user oriented. Terms are displayed lowest\r\n\r\n     * degrees first. The multiplications signs, coefficients equals to\r\n\r\n     * one and null terms are not displayed (except if the polynomial is 0, * in which case the 0 constant term is displayed). Addition of terms\r\n\r\n     * with negative coefficients are replaced by subtraction of terms\r\n\r\n     * with positive coefficients except for the first displayed term\r\n\r\n     * (i.e. we display <code>-3</code> for a constant negative polynomial, * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\r\n\r\n     * the first one displayed).</p>\r\n\r\n     *\r\n\r\n     * @return a string representation of the polynomial.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    std::string to_string() const \r\n\r\n    {\r\n\r\n        std::stringBuilder s = std::stringstream();\r\n\r\n        if (coefficients[0] == 0.0) \r\n\r\n        {\r\n\r\n            if (coefficients.size() == 1) \r\n\r\n            {\r\n\r\n                return "0";\r\n\r\n            }\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            s.append(to_string(coefficients[0]));\r\n\r\n        }\r\n\r\n\r\n\r\n        for (int i{ 1 }; i < coefficients.size(); ++i) \r\n\r\n        {\r\n\r\n            if (coefficients[i] != 0) \r\n\r\n            {\r\n\r\n                if (s.size()() > 0) \r\n\r\n                {\r\n\r\n                    if (coefficients[i] < 0) \r\n\r\n                    {\r\n\r\n                        s.append(" - ");\r\n\r\n                    }\r\n\r\n                    else \r\n\r\n                    {\r\n\r\n                        s.append(" + ");\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                else \r\n\r\n                {\r\n\r\n                    if (coefficients[i] < 0) \r\n\r\n                    {\r\n\r\n                        s.append('-');\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                double abs_ai = std::abs(coefficients[i]);\r\n\r\n                if ((abs_ai - 1) != 0) \r\n\r\n                {\r\n\r\n                    s.append(to_string(abs_ai));\r\n\r\n                    s.append(' ');\r\n\r\n                }\r\n\r\n\r\n\r\n                s.append('x');\r\n\r\n                if (i > 1) \r\n\r\n                {\r\n\r\n                    s.append('^');\r\n\r\n                    s.append(Integer.to_string(i));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return s.to_string();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int hash_code() \r\n\r\n    {\r\n\r\n        constexpr int prime{ 31 };\r\n\r\n        int result = 1;\r\n\r\n        result = prime * result + Arrays.hash_code(coefficients);\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    bool equals(const Object& obj) \r\n\r\n    {\r\n\r\n        if (this == obj) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        if (!(obj instanceof Polynomial_Function)) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        Polynomial_Function other = (Polynomial_Function) obj;\r\n\r\n        if (!Arrays.equals(coefficients, other.coefficients)) \r\n\r\n        {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Dedicated parametric polynomial class.\r\n\r\n     *\r\n\r\n     */\r\n\r\n    static class Parametric : ParametricUnivariate_Function \r\n\r\n    {\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public std::vector<double> gradient(const double& x, double ... parameters) \r\n\r\n        {\r\n\r\n            const auto gradient = std::vector<double>(parameters.size());\r\n\r\n            double xn{ 1.0 };\r\n\r\n            for (int i{}; i < parameters.size(); ++i) \r\n\r\n            {\r\n\r\n                gradient[i] = xn;\r\n\r\n                xn *= x;\r\n\r\n            }\r\n\r\n            return gradient;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public double value(const double& x, const double ... parameters)\r\n\r\n             \r\n\r\n            {\r\n\r\n            return Polynomial_Function.evaluate(parameters, x);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n