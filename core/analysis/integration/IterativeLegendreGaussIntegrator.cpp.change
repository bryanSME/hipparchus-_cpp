/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.analysis.integration.gauss.Gauss_Integrator;\r\n\r\n//import org.hipparchus.analysis.integration.gauss.Gauss_Integrator_factory;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * This algorithm divides the integration interval into equally-sized\r\n\r\n * sub-interval and on each of them performs a\r\n\r\n * <a href="http://mathworld.wolfram.com/Legendre-GaussQuadrature.html">\r\n\r\n * Legendre-Gauss</a> quadrature.\r\n\r\n * Because of its <em>non-adaptive</em> nature, this algorithm can\r\n\r\n * converge to a wrong value for the integral (for example, if the\r\n\r\n * function is significantly different from zero toward the ends of the\r\n\r\n * integration interval).\r\n\r\n * In particular, a change of variables aimed at estimating integrals\r\n\r\n * over infinite intervals as proposed\r\n\r\n * <a href="http://en.wikipedia.org/w/index.php?title=_numerical_integration#Integrals_over_infinite_intervals">\r\n\r\n *  here</a> should be avoided when using this class.\r\n\r\n *\r\n\r\n */\r\n\r\n\r\n\r\nclass IterativeLegendreGauss_Integrator\r\n\r\n    extends BaseAbstractUnivariate_Integrator \r\n\r\n    {\r\n\r\n    /** Factory that computes the points and weights. */\r\n\r\n    private static const Gauss_Integrator_factory FACTORY\r\n\r\n        = Gauss_Integrator_factory();\r\n\r\n    /** Number of integration points (per interval). */\r\n\r\n    private const int& number_of_points;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds an integrator with given accuracies and iterations counts.\r\n\r\n     *\r\n\r\n     * @param n Number of integration points.\r\n\r\n     * @param relative_accuracy Relative accuracy of the result.\r\n\r\n     * @param absolute_accuracy Absolute accuracy of the result.\r\n\r\n     * @param minimal_iteration_count Minimum number of iterations.\r\n\r\n     * @param maximal_iteration_count Maximum number of iterations.\r\n\r\n     * @ if minimal number of iterations\r\n\r\n     * or number of points are not strictly positive.\r\n\r\n     * @ if maximal number of iterations\r\n\r\n     * is smaller than or equal to the minimal number of iterations.\r\n\r\n     */\r\n\r\n    public IterativeLegendreGauss_Integrator(const int& n, const double relative_accuracy, const double& absolute_accuracy, const int minimal_iteration_count, const int maximal_iteration_count)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(relative_accuracy, absolute_accuracy, minimal_iteration_count, maximal_iteration_count);\r\n\r\n        if (n <= 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, n);\r\n\r\n        }\r\n\r\n       number_of_points = n;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds an integrator with given accuracies.\r\n\r\n     *\r\n\r\n     * @param n Number of integration points.\r\n\r\n     * @param relative_accuracy Relative accuracy of the result.\r\n\r\n     * @param absolute_accuracy Absolute accuracy of the result.\r\n\r\n     * @ if {@code n < 1}.\r\n\r\n     */\r\n\r\n    public IterativeLegendreGauss_Integrator(const int& n, const double relative_accuracy, const double& absolute_accuracy)\r\n\r\n         \r\n\r\n        {\r\n\r\n        this(n, relative_accuracy, absolute_accuracy, DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds an integrator with given iteration counts.\r\n\r\n     *\r\n\r\n     * @param n Number of integration points.\r\n\r\n     * @param minimal_iteration_count Minimum number of iterations.\r\n\r\n     * @param maximal_iteration_count Maximum number of iterations.\r\n\r\n     * @ if minimal number of iterations\r\n\r\n     * is not strictly positive.\r\n\r\n     * @ if maximal number of iterations\r\n\r\n     * is smaller than or equal to the minimal number of iterations.\r\n\r\n     * @ if {@code n < 1}.\r\n\r\n     */\r\n\r\n    public IterativeLegendreGauss_Integrator(const int& n, const int minimal_iteration_count, const int maximal_iteration_count)\r\n\r\n         \r\n\r\n        {\r\n\r\n        this(n, DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, minimal_iteration_count, maximal_iteration_count);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected double do_integrate()\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        // Compute first estimate with a single step.\r\n\r\n        double oldt = stage(1);\r\n\r\n\r\n\r\n        int n = 2;\r\n\r\n        while (true) \r\n\r\n        {\r\n\r\n            // Improve integral with a larger number of steps.\r\n\r\n            const double t = stage(n);\r\n\r\n\r\n\r\n            // Estimate the error.\r\n\r\n            const double delta = std::abs(t - oldt);\r\n\r\n            const double limit =\r\n\r\n                std::max(get_absolute_accuracy(), get_relative_accuracy() * (std::abs(oldt) + std::abs(t)) * 0.5);\r\n\r\n\r\n\r\n            // check convergence\r\n\r\n            if (iterations.get_count() + 1 >= get_minimal_iteration_count() &&\r\n\r\n                delta <= limit) \r\n\r\n                {\r\n\r\n                return t;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Prepare next iteration.\r\n\r\n            const double ratio = std::min(4, std::pow(delta / limit, 0.5 / number_of_points));\r\n\r\n            n = std::max(static_cast<int>( (ratio * n), n + 1);\r\n\r\n            oldt = t;\r\n\r\n            iterations.increment();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the n-th stage integral.\r\n\r\n     *\r\n\r\n     * @param n Number of steps.\r\n\r\n     * @return the value of n-th stage integral.\r\n\r\n     * @Math_Illegal_State_Exception if the maximum number of evaluations\r\n\r\n     * is exceeded.\r\n\r\n     */\r\n\r\n    private double stage(const int& n)\r\n\r\n        Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n        // Function to be integrated is stored in the base class.\r\n\r\n        const Univariate_Function f = Univariate_Function() \r\n\r\n        {\r\n\r\n                /** {@inherit_doc} */\r\n\r\n                //override\r\n\r\n                public double value(double x)\r\n\r\n                    , Math_Illegal_State_Exception \r\n\r\n                    {\r\n\r\n                    return compute_objective_value(x);\r\n\r\n                }\r\n\r\n            };\r\n\r\n\r\n\r\n        const double min = get_min();\r\n\r\n        const double max = get_max();\r\n\r\n        const double step = (max - min) / n;\r\n\r\n\r\n\r\n        double sum{};\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            // Integrate over each sub-interval [a, b].\r\n\r\n            const double& a = min + i * step;\r\n\r\n            const double b = a + step;\r\n\r\n            const Gauss_Integrator g = FACTORY.legendre_high_precision(number_of_points, a, b);\r\n\r\n            sum += g.integrate(f);\r\n\r\n        }\r\n\r\n\r\n\r\n        return sum;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n