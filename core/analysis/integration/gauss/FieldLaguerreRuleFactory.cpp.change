/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration.gauss;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Pair;\r\n\r\n\r\n\r\n/**\r\n\r\n * Factory that creates Gauss-type quadrature rule using Laguerre polynomials.\r\n\r\n *\r\n\r\n * @see <a href="http://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature">Gauss-Laguerre quadrature (Wikipedia)</a>\r\n\r\n * @param <T> Type of the number used to represent the points and weights of\r\n\r\n * the quadrature rules.\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldLaguerreRule_Factory extends FieldAbstractRule_Factory<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Simple constructor\r\n\r\n     * @param field field to which rule coefficients belong\r\n\r\n     */\r\n\r\n    public FieldLaguerreRule_Factory(const Field<T> field) \r\n\r\n    {\r\n\r\n        super(field);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Pair<std::vector<T>, std::vector<T>> compute_rule(const int& number_of_points)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        const Field<T> field = get_field();\r\n\r\n\r\n\r\n        // find nodes as roots of Laguerre polynomial\r\n\r\n        const Laguerre<T> p      =  Laguerre<>(number_of_points);\r\n\r\n        const std::vector<T>      points = find_roots(number_of_points, p::ratio);\r\n\r\n\r\n\r\n        // compute weights\r\n\r\n        const std::vector<T> weights = Math_Arrays::build_array(field, number_of_points);\r\n\r\n        const int      n1         = number_of_points + 1;\r\n\r\n        const long     n1Squared  = n1 * static_cast<long>( n1;\r\n\r\n        const Laguerre<T> laguerreN1 = Laguerre<>(n1);\r\n\r\n        for (int i{}; i < number_of_points; i++) \r\n\r\n        {\r\n\r\n            const T y = laguerreN1.value(points[i]);\r\n\r\n            weights[i] = points[i].divide(y.multiply(y).multiply(n1Squared));\r\n\r\n        }\r\n\r\n\r\n\r\n        return Pair<>(points, weights);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Laguerre polynomial.\r\n\r\n     * @param <T> Type of the field elements.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private static class Laguerre \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Degree. */\r\n\r\n        private int degree;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param degree polynomial degree\r\n\r\n         */\r\n\r\n        Laguerre(const int& degree) \r\n\r\n        {\r\n\r\n            this.degree = degree;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Evaluate polynomial.\r\n\r\n         * @param x point at which polynomial must be evaluated\r\n\r\n         * @return value of the polynomial\r\n\r\n         */\r\n\r\n        public T value(const T x) \r\n\r\n        {\r\n\r\n            return lNlNm1(x)[0];\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute ratio L(x)/L'(x).\r\n\r\n         * @param x point at which ratio must be computed\r\n\r\n         * @return ratio L(x)/L'(x)\r\n\r\n         */\r\n\r\n        public T ratio(T x) \r\n\r\n        {\r\n\r\n            std::vector<T> l = lNlNm1(x);\r\n\r\n            return x.multiply(l[0]).divide(l[0].subtract(l[1]).multiply(degree));\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute L\xe2\x82\x99(x) and L\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x).\r\n\r\n         * @param x point at which polynomials are evaluated\r\n\r\n         * @return array containing L\xe2\x82\x99(x) at index 0 and L\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x) at index 1\r\n\r\n         */\r\n\r\n        private std::vector<T> lNlNm1(const T x) \r\n\r\n        {\r\n\r\n            std::vector<T> l = Math_Arrays::build_array(x.get_field(), 2);\r\n\r\n            l[0] = x.subtract(1).negate();\r\n\r\n            l[1] = x.get_field().get_one();\r\n\r\n            for (const int n = 1; n < degree; n++) \r\n\r\n            {\r\n\r\n                // apply recurrence relation (n+1) L\xe2\x82\x99\xe2\x82\x8a\xe2\x82\x81(x) = (2n + 1 - x) L\xe2\x82\x99(x) - n L\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x)\r\n\r\n                const T lp = l[0].multiply(x.negate().add(2 * n + 1)).subtract(l[1].multiply(n)).divide(n + 1);\r\n\r\n                l[1] = l[0];\r\n\r\n                l[0] = lp;\r\n\r\n            }\r\n\r\n            return l;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n