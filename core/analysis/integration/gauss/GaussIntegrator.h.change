/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n#include <vector>\r\n\r\n#include "../../../util/MathArrays.h"\r\n\r\n#include "../../UnivariateFunction.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * Class that : the Gaussian rule for\r\n\r\n * {@link #integrate(Univariate_Function) integrating} a weighted\r\n\r\n * function.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Gauss_Integrator \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Nodes. */\r\n\r\n    const std::vector<double> my_points;\r\n\r\n    /** Nodes weights. */\r\n\r\n    const std::vector<double> my_weights;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given {@code points} and {@code weights}.\r\n\r\n     * The integration interval is defined by the first and last value of\r\n\r\n     * {@code points} which must be sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @param points Integration points.\r\n\r\n     * @param weights Weights of the corresponding integration nodes.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     * @ if points and weights don't have the same length\r\n\r\n     */\r\n\r\n    Gauss_Integrator(const std::vector<double>& points, const std::vector<double>& weights)\r\n\r\n        : my_points{ points }, my_weights{ weights }\r\n\r\n    {\r\n\r\n        Math_Arrays::check_equal_length(points, weights);\r\n\r\n        //Math_Arrays::check_order(points, Math_Arrays::Order_Direction::INCREASING, true, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given pair of points (first element of\r\n\r\n     * the pair) and weights (second element of the pair.\r\n\r\n     *\r\n\r\n     * @param points_and_weights Integration points and corresponding weights.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @see #Gauss_Integrator(std::vector<double>, std::vector<double>)\r\n\r\n     */\r\n\r\n    Gauss_Integrator(const std::pair<std::vector<double>, std::vector<double>>& points_and_weights)\r\n\r\n    {\r\n\r\n        Gauss_Integrator(points_and_weights.first, points_and_weights.second);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an estimate of the integral of {@code f(x) * w(x)}, * where {@code w} is a weight function that depends on the actual\r\n\r\n     * flavor of the Gauss integration scheme.\r\n\r\n     * The algorithm uses the points and associated weights, as passed\r\n\r\n     * to the {@link #Gauss_Integrator(std::vector<double>,std::vector<double>) constructor}.\r\n\r\n     *\r\n\r\n     * @param f Function to integrate.\r\n\r\n     * @return the integral of the weighted function.\r\n\r\n     */\r\n\r\n    double integrate(Univariate_Function f) \r\n\r\n    {\r\n\r\n        double s = 0;\r\n\r\n        double c = 0;\r\n\r\n        for (int i{}; i < my_points.size(); i++)\r\n\r\n        {\r\n\r\n            const double x = my_points[i];\r\n\r\n            const double w = my_weights[i];\r\n\r\n            const double y = w * f.value(x) - c;\r\n\r\n            const double t = s + y;\r\n\r\n            c = (t - s) - y;\r\n\r\n            s = t;\r\n\r\n        }\r\n\r\n        return s;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @return the order of the integration rule (the number of integration\r\n\r\n     * points).\r\n\r\n     */\r\n\r\n    int get_number_of_points() const\r\n\r\n    {\r\n\r\n        return my_points.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the integration point at the given index.\r\n\r\n     * The index must be in the valid range but no check is performed.\r\n\r\n     * @param index index of the integration point\r\n\r\n     * @return the integration point.\r\n\r\n     */\r\n\r\n    double get_point(const int& index) const\r\n\r\n    {\r\n\r\n        return my_points[index];\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the weight of the integration point at the given index.\r\n\r\n     * The index must be in the valid range but no check is performed.\r\n\r\n     * @param index index of the integration point\r\n\r\n     * @return the weight.\r\n\r\n     */\r\n\r\n    double get_weight(const int& index) const\r\n\r\n    {\r\n\r\n        return my_weights[index];\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n