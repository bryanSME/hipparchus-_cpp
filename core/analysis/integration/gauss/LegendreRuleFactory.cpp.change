/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration.gauss;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Pair;\r\n\r\n\r\n\r\n/**\r\n\r\n * Factory that creates Gauss-type quadrature rule using Legendre polynomials.\r\n\r\n * In this implementation, the lower and upper bounds of the natural interval\r\n\r\n * of integration are -1 and 1, respectively.\r\n\r\n * The Legendre polynomials are evaluated using the recurrence relation\r\n\r\n * presented in <a href="http://en.wikipedia.org/wiki/Abramowitz_and_Stegun">\r\n\r\n * Abramowitz and Stegun, 1964</a>.\r\n\r\n *\r\n\r\n */\r\n\r\nclass LegendreRule_Factory extends AbstractRule_Factory \r\n\r\n{\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Pair<std::vector<double>, std::vector<double>> compute_rule(const int& number_of_points)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        if (number_of_points == 1) \r\n\r\n        {\r\n\r\n            // Break recursion.\r\n\r\n           return Pair<>(std::vector<double> { 0 } , std::vector<double> { 2 });\r\n\r\n        }\r\n\r\n\r\n\r\n        // find nodes as roots of Legendre polynomial\r\n\r\n        const Legendre p      =  Legendre(number_of_points);\r\n\r\n        const std::vector<double> points = find_roots(number_of_points, p::ratio);\r\n\r\n        enforce_symmetry(points);\r\n\r\n\r\n\r\n        // compute weights\r\n\r\n        const std::vector<double> weights = std::vector<double>(number_of_points];\r\n\r\n        for (int i{}; i <= number_of_points / 2; i++) \r\n\r\n        {\r\n\r\n            const double c = points[i];\r\n\r\n            const std::vector<double> pKpKm1 = p.pNpNm1(c);\r\n\r\n            const double d = number_of_points * (pKpKm1[1] - c * pKpKm1[0]);\r\n\r\n            weights[i] = 2 * (1 - c * c) / (d * d);\r\n\r\n\r\n\r\n            // symmetrical point\r\n\r\n            const int idx = number_of_points - i - 1;\r\n\r\n            weights[idx]  = weights[i];\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return Pair<>(points, weights);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Legendre polynomial. */\r\n\r\n    private static class Legendre \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Degree. */\r\n\r\n        private int degree;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param degree polynomial degree\r\n\r\n         */\r\n\r\n        Legendre(const int& degree) \r\n\r\n        {\r\n\r\n            this.degree = degree;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute ratio P(x)/P'(x).\r\n\r\n         * @param x point at which ratio must be computed\r\n\r\n         * @return ratio P(x)/P'(x)\r\n\r\n         */\r\n\r\n        public double ratio(double x) \r\n\r\n        {\r\n\r\n            double pm = 1;\r\n\r\n            double p  = x;\r\n\r\n            double d  = 1;\r\n\r\n            for (const int n = 1; n < degree; n++) \r\n\r\n            {\r\n\r\n                // apply recurrence relations (n+1) P_n+1(x)  = (2n+1) x P_n(x) - n P_n-1(x)\r\n\r\n                // and                              P'_n+1(x) = (n+1) P_n(x) + x P'_n(x)\r\n\r\n                const double pp = (p * (x * (2 * n + 1)) - pm * n) / (n + 1);\r\n\r\n                d  = p * (n + 1) + d * x;\r\n\r\n                pm = p;\r\n\r\n                p  = pp;\r\n\r\n            }\r\n\r\n            return p / d;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute P_n(x) and P_n-1(x).\r\n\r\n         * @param x point at which polynomials are evaluated\r\n\r\n         * @return array containing P_n(x) at index 0 and P_n-1(x) at index 1\r\n\r\n         */\r\n\r\n        private std::vector<double> pNpNm1(const double& x) \r\n\r\n        {\r\n\r\n            std::vector<double> p = { x, 1 };\r\n\r\n            for (const int n = 1; n < degree; n++) \r\n\r\n            {\r\n\r\n                // apply recurrence relation (n+1) P_pi+1(x) = (2n+1) x P_n(x) - n P_n-1(x)\r\n\r\n                const double pp = (p[0] * (x * (2 * n + 1)) - p[1] * n) / (n + 1);\r\n\r\n                p[1] = p[0];\r\n\r\n                p[0] = pp;\r\n\r\n            }\r\n\r\n            return p;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n