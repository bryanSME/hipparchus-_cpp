/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration.gauss;\r\n\r\n\r\n\r\n//import java.util.Arrays;\r\n\r\n//import java.util.Sorted_Map;\r\n\r\n//import java.util.Tree_Map;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Incrementor;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Pair;\r\n\r\n\r\n\r\n/**\r\n\r\n * Base class for rules that determines the integration nodes and their\r\n\r\n * weights.\r\n\r\n * Subclasses must implement the {@link #compute_rulestatic_cast<int>( compute_rule} method.\r\n\r\n *\r\n\r\n * @param <T> Type of the number used to represent the points and weights of\r\n\r\n * the quadrature rules.\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class FieldAbstractRule_Factory : FieldRule_Factory<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Field to which rule coefficients belong. */\r\n\r\n    private const Field<T> field;\r\n\r\n\r\n\r\n    /** List of points and weights, indexed by the order of the rule. */\r\n\r\n    private const Sorted_Map<Integer, Pair<std::vector<T>, std::vector<T>>> points_and_weights;\r\n\r\n\r\n\r\n    /** Simple constructor\r\n\r\n     * @param field field to which rule coefficients belong\r\n\r\n     */\r\n\r\n    public FieldAbstractRule_Factory(const Field<T> field) \r\n\r\n    {\r\n\r\n        this.field            = field;\r\n\r\n        this.points_and_weights = Tree_Map<>();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the field to which rule coefficients belong.\r\n\r\n     * @return field to which rule coefficients belong\r\n\r\n     */\r\n\r\n    public Field<T> get_field() \r\n\r\n    {\r\n\r\n        return field;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Pair<std::vector<T>, std::vector<T>> get_rule(const int& number_of_points)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        if (number_of_points <= 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_POINTS, number_of_points);\r\n\r\n        }\r\n\r\n        if (number_of_points > 1000) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_LARGE, number_of_points, 1000);\r\n\r\n        }\r\n\r\n\r\n\r\n        Pair<std::vector<T>, std::vector<T>> rule;\r\n\r\n        synchronized (points_and_weights) \r\n\r\n        {\r\n\r\n            // Try to obtain the rule from the cache.\r\n\r\n            rule = points_and_weights.get(number_of_points);\r\n\r\n\r\n\r\n            if (rule == null) \r\n\r\n            {\r\n\r\n                // Rule not computed yet.\r\n\r\n\r\n\r\n                // Compute the rule.\r\n\r\n                rule = compute_rule(number_of_points);\r\n\r\n\r\n\r\n                // Cache it.\r\n\r\n                points_and_weights.put(number_of_points, rule);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // Return a copy.\r\n\r\n        return Pair<>(rule.get_first().clone(), rule.get_second().clone());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the rule for the given order.\r\n\r\n     *\r\n\r\n     * @param number_of_points Order of the rule to be computed.\r\n\r\n     * @return the computed rule.\r\n\r\n     * @ if the elements of the pair do not\r\n\r\n     * have the same length.\r\n\r\n     */\r\n\r\n    protected virtual Pair<std::vector<T>, std::vector<T>> compute_rule(const int& number_of_points)\r\n\r\n        ;\r\n\r\n\r\n\r\n    /** Computes roots of the associated orthogonal polynomials.\r\n\r\n     * <p>\r\n\r\n     * The roots are found using the <a href="https://en.wikipedia.org/wiki/Aberth_method">Aberth method</a>.\r\n\r\n     * The guess points for initializing search for degree n are fixed for degrees 1 and 2 and are\r\n\r\n     * selected from n-1 roots of rule n-1 (the two extreme roots are used, plus the n-1 intermediate\r\n\r\n     * points between all roots).\r\n\r\n     * </p>\r\n\r\n     * @param n number of roots to search for\r\n\r\n     * @param ratio_evaluator function evaluating the ratio P\xe2\x82\x99(x)/P\xe2\x82\x99'(x)\r\n\r\n     * @return sorted array of roots\r\n\r\n     */\r\n\r\n    protected std::vector<T> find_roots(const int& n, const Calculus_Field_Univariate_Function<T> ratio_evaluator) \r\n\r\n    {\r\n\r\n\r\n\r\n        const std::vector<T> roots  = Math_Arrays::build_array(field, n);\r\n\r\n\r\n\r\n        // set up initial guess\r\n\r\n        if (n == 1) \r\n\r\n        {\r\n\r\n            // arbitrary guess\r\n\r\n            roots[0] = field.get_zero();\r\n\r\n        }\r\n\r\nelse if (n == 2) \r\n\r\n        {\r\n\r\n            // arbitrary guess\r\n\r\n            roots[0] = field.get_one().negate();\r\n\r\n            roots[1] = field.get_one();\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            // get roots from previous rule.\r\n\r\n            // If it has not been computed yet it will trigger a recursive call\r\n\r\n            const std::vector<T> previous_points = get_rule(n - 1).get_first();\r\n\r\n\r\n\r\n            // first guess at previous first root\r\n\r\n            roots[0] = previous_points[0];\r\n\r\n\r\n\r\n            // intermediate guesses between previous roots\r\n\r\n            for (int i{ 1 }; i < n - 1; ++i) \r\n\r\n            {\r\n\r\n                roots[i] = previous_points[i - 1].add(previous_points[i]).multiply(0.5);\r\n\r\n            }\r\n\r\n\r\n\r\n            // last guess at previous last root\r\n\r\n            roots[n - 1] = previous_points[n - 2];\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // use Aberth method to find all roots simultaneously\r\n\r\n        const std::vector<T>         ratio       = Math_Arrays::build_array(field, n);\r\n\r\n        const Incrementor incrementor = Incrementor(1000);\r\n\r\n        double            tol;\r\n\r\n        double            max_offset;\r\n\r\n        do \r\n\r\n        {\r\n\r\n\r\n\r\n            // safety check that triggers an exception if too much iterations are made\r\n\r\n            incrementor.increment();\r\n\r\n\r\n\r\n            // find the ratio P(x\xe1\xb5\xa2)/P'(x\xe1\xb5\xa2) for all current roots approximations\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                ratio[i] = ratio_evaluator.value(roots[i]);\r\n\r\n            }\r\n\r\n\r\n\r\n            // move roots approximations all at once, using Aberth method\r\n\r\n            max_offset = 0;\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                T sum = field.get_zero();\r\n\r\n                for (int j{}; j < n; ++j) \r\n\r\n                {\r\n\r\n                    if (j != i) \r\n\r\n                    {\r\n\r\n                        sum = sum.add(roots[i].subtract(roots[j]).reciprocal());\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                const T offset = ratio[i].divide(sum.multiply(ratio[i]).negate().add(1));\r\n\r\n                max_offset = std::max(max_offset, std::abs(offset).get_real());\r\n\r\n                roots[i] = roots[i].subtract(offset);\r\n\r\n            }\r\n\r\n\r\n\r\n            // we set tolerance to 1 ulp of the largest root\r\n\r\n            tol = 0;\r\n\r\n            for (const T r : roots) \r\n\r\n            {\r\n\r\n                tol = std::max(tol, FastMath.ulp(r.get_real()));\r\n\r\n            }\r\n\r\n\r\n\r\n        } while (max_offset > tol);\r\n\r\n\r\n\r\n        // sort the roots\r\n\r\n        Arrays.sort(roots, (r1, r2) -> Double.compare(r1.get_real(), r2.get_real()));\r\n\r\n\r\n\r\n        return roots;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Enforce symmetry of roots.\r\n\r\n     * @param roots roots to process in place\r\n\r\n     */\r\n\r\n    protected void enforce_symmetry(const std::vector<T> roots) \r\n\r\n    {\r\n\r\n\r\n\r\n        const int n = roots.size();\r\n\r\n\r\n\r\n        // enforce symmetry\r\n\r\n        for (int i{}; i < n / 2; ++i) \r\n\r\n        {\r\n\r\n            const int idx = n - i - 1;\r\n\r\n            const T c = roots[i].subtract(roots[idx]).multiply(0.5);\r\n\r\n            roots[i]   = c;\r\n\r\n            roots[idx] = c.negate();\r\n\r\n        }\r\n\r\n\r\n\r\n        // If n is odd, 0 is a root.\r\n\r\n        // Note: as written, the test for oddness will work for negative\r\n\r\n        // integers too (although it is not necessary here), preventing\r\n\r\n        // a Find_Bugs warning.\r\n\r\n        if (n % 2 != 0) \r\n\r\n        {\r\n\r\n            roots[n / 2] = field.get_zero();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n