/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n#include <type_traits>\r\n\r\n#include "../../../CalculusFieldElement.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * Class that : the Gaussian rule for\r\n\r\n * {@link #integrate(Calculus_Field_Univariate_Function) integrating} a weighted\r\n\r\n * function.\r\n\r\n *\r\n\r\n * @param <T> Type of the field elements.\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\ntemplate<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element<T>, T>::value>::type* = nullptr>\r\n\r\nclass FieldGauss_Integrator\r\n\r\n{\r\n\r\n    /** Nodes. */\r\n\r\n    private const std::vector<T> my_points;\r\n\r\n    /** Nodes weights. */\r\n\r\n    private const std::vector<T> my_weights;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given {@code points} and {@code weights}.\r\n\r\n     * The integration interval is defined by the first and last value of\r\n\r\n     * {@code points} which must be sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @param points Integration points.\r\n\r\n     * @param weights Weights of the corresponding integration nodes.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     * @ if points and weights don't have the same length\r\n\r\n     */\r\n\r\n    public FieldGauss_Integrator(const std::vector<T>& points, const std::vector<T>& weights) : my_points{ points }, my_weights{ weights }\r\n\r\n    {\r\n\r\n        Math_Arrays::check_equal_length(points, weights);\r\n\r\n        Math_Arrays::check_order(points, Math_Arrays::Order_Direction::INCREASING, true, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given pair of points (first element of\r\n\r\n     * the pair) and weights (second element of the pair.\r\n\r\n     *\r\n\r\n     * @param points_and_weights Integration points and corresponding weights.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @see #FieldGauss_Integrator(Calculus_Field_Element[], Calculus_Field_Element[])\r\n\r\n     */\r\n\r\n    public FieldGauss_Integrator(Pair<std::vector<T>, std::vector<T>> points_and_weights)\r\n\r\n\r\n\r\n    {\r\n\r\n        FieldGauss_Integrator(points_and_weights.get_first(), points_and_weights.get_second());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns an estimate of the integral of {@code f(x) * w(x)}, * where {@code w} is a weight function that depends on the actual\r\n\r\n     * flavor of the Gauss integration scheme.\r\n\r\n     * The algorithm uses the points and associated weights, as passed\r\n\r\n     * to the {@link #FieldGauss_Integrator(Calculus_Field_Element[], Calculus_Field_Element[]) constructor}.\r\n\r\n     *\r\n\r\n     * @param f Function to integrate.\r\n\r\n     * @return the integral of the weighted function.\r\n\r\n     */\r\n\r\n    public T integrate(const Calculus_Field_Univariate_Function<T>& f)\r\n\r\n    {\r\n\r\n        T s = points[0].get_field().get_zero();\r\n\r\n        T c = s;\r\n\r\n        for (int i{}; i < points.size(); i++)\r\n\r\n        {\r\n\r\n            const T x = points[i];\r\n\r\n            const T w = weights[i];\r\n\r\n            const T y = w.multiply(f.value(x)).subtract(c);\r\n\r\n            const T t = s.add(y);\r\n\r\n            c = t.subtract(s).subtract(y);\r\n\r\n            s = t;\r\n\r\n        }\r\n\r\n        return s;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * @return the order of the integration rule (the number of integration\r\n\r\n     * points).\r\n\r\n     */\r\n\r\n    public int get_number_of_points() const\r\n\r\n    {\r\n\r\n        return points.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the integration point at the given index.\r\n\r\n     * The index must be in the valid range but no check is performed.\r\n\r\n     * @param index index of the integration point\r\n\r\n     * @return the integration point.\r\n\r\n     */\r\n\r\n    public T get_point(const int& index) const\r\n\r\n    {\r\n\r\n        return points[index];\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the weight of the integration point at the given index.\r\n\r\n     * The index must be in the valid range but no check is performed.\r\n\r\n     * @param index index of the integration point\r\n\r\n     * @return the weight.\r\n\r\n     */\r\n\r\n    public T get_weight(const int& index) const\r\n\r\n    {\r\n\r\n        return weights[index];\r\n\r\n    }\r\n\r\n};\r\n