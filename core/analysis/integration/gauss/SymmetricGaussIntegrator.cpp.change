/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration.gauss;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.Univariate_Function;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Pair;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class's : {@link #integrate(Univariate_Function) integrate}\r\n\r\n * method assuming that the integral is symmetric about 0.\r\n\r\n * This allows to reduce numerical errors.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Symmetric_Gauss_Integrator extends Gauss_Integrator \r\n\r\n{\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given {@code points} and {@code weights}.\r\n\r\n     * The integration interval is defined by the first and last value of\r\n\r\n     * {@code points} which must be sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @param points Integration points.\r\n\r\n     * @param weights Weights of the corresponding integration nodes.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     * @ if points and weights don't have the same length\r\n\r\n     */\r\n\r\n    public Symmetric_Gauss_Integrator(std::vector<double> points, std::vector<double> weights)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(points, weights);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates an integrator from the given pair of points (first element of\r\n\r\n     * the pair) and weights (second element of the pair.\r\n\r\n     *\r\n\r\n     * @param points_and_weights Integration points and corresponding weights.\r\n\r\n     * @ if the {@code points} are not\r\n\r\n     * sorted in increasing order.\r\n\r\n     *\r\n\r\n     * @see #Symmetric_Gauss_Integrator(std::vector<double>, std::vector<double>)\r\n\r\n     */\r\n\r\n    public Symmetric_Gauss_Integrator(Pair<std::vector<double>, std::vector<double>> points_and_weights)\r\n\r\n         \r\n\r\n        {\r\n\r\n        this(points_and_weights.get_first(), points_and_weights.get_second());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public double integrate(Univariate_Function f) \r\n\r\n    {\r\n\r\n        const int rule_length = get_number_of_points();\r\n\r\n\r\n\r\n        if (rule_length == 1) \r\n\r\n        {\r\n\r\n            return get_weight(0) * f.value(0d);\r\n\r\n        }\r\n\r\n\r\n\r\n        const int i_max = rule_length / 2;\r\n\r\n        double s = 0;\r\n\r\n        double c = 0;\r\n\r\n        for (int i{}; i < i_max; i++) \r\n\r\n        {\r\n\r\n            const double p = get_point(i);\r\n\r\n            const double w = get_weight(i);\r\n\r\n\r\n\r\n            const double f1 = f.value(p);\r\n\r\n            const double f2 = f.value(-p);\r\n\r\n\r\n\r\n            const double y = w * (f1 + f2) - c;\r\n\r\n            const double t = s + y;\r\n\r\n\r\n\r\n            c = (t - s) - y;\r\n\r\n            s = t;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (rule_length % 2 != 0) \r\n\r\n        {\r\n\r\n            const double w = get_weight(i_max);\r\n\r\n\r\n\r\n            const double y = w * f.value(0d) - c;\r\n\r\n            const double t = s + y;\r\n\r\n\r\n\r\n            s = t;\r\n\r\n        }\r\n\r\n\r\n\r\n        return s;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n