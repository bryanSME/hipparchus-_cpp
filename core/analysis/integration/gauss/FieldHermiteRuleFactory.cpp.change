/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.analysis.integration.gauss;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Pair;\r\n\r\n\r\n\r\n/**\r\n\r\n * Factory that creates a\r\n\r\n * <a href="http://en.wikipedia.org/wiki/Gauss-Hermite_quadrature">\r\n\r\n * Gauss-type quadrature rule using Hermite polynomials</a>\r\n\r\n * of the first kind.\r\n\r\n * Such a quadrature rule allows the calculation of improper integrals\r\n\r\n * of a function\r\n\r\n * <p>\r\n\r\n *  \\(f(x) e^{-x^2}\\)\r\n\r\n * </p><p>\r\n\r\n * Recurrence relation and weights computation follow\r\n\r\n * <a href="http://en.wikipedia.org/wiki/Abramowitz_and_Stegun">\r\n\r\n * Abramowitz and Stegun, 1964</a>.\r\n\r\n * </p><p>\r\n\r\n * The coefficients of the standard Hermite polynomials grow very rapidly.\r\n\r\n * In order to avoid overflows, each Hermite polynomial is normalized with\r\n\r\n * respect to the underlying scalar product.\r\n\r\n * @param <T> Type of the number used to represent the points and weights of\r\n\r\n * the quadrature rules.\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldHermiteRule_Factory extends FieldAbstractRule_Factory<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Simple constructor\r\n\r\n     * @param field field to which rule coefficients belong\r\n\r\n     */\r\n\r\n    public FieldHermiteRule_Factory(const Field<T> field) \r\n\r\n    {\r\n\r\n        super(field);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Pair<std::vector<T>, std::vector<T>> compute_rule(const int& number_of_points)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        const Field<T> field  = get_field();\r\n\r\n        const T        sqrtPi = field.get_zero().get_pi().sqrt();\r\n\r\n\r\n\r\n        if (number_of_points == 1) \r\n\r\n        {\r\n\r\n            // Break recursion.\r\n\r\n            const std::vector<T> points  = Math_Arrays::build_array(field, number_of_points);\r\n\r\n            const std::vector<T> weights = Math_Arrays::build_array(field, number_of_points);\r\n\r\n            points[0]  = field.get_zero();\r\n\r\n            weights[0] = sqrtPi;\r\n\r\n            return Pair<>(points, weights);\r\n\r\n        }\r\n\r\n\r\n\r\n        // find nodes as roots of Hermite polynomial\r\n\r\n        const std::vector<T> points = find_roots(number_of_points, Hermite<>(field, number_of_points)::ratio);\r\n\r\n        enforce_symmetry(points);\r\n\r\n\r\n\r\n        // compute weights\r\n\r\n        const std::vector<T> weights = Math_Arrays::build_array(field, number_of_points);\r\n\r\n        const Hermite<T> hm1 = Hermite<>(field, number_of_points - 1);\r\n\r\n        for (int i{}; i < number_of_points; i++) \r\n\r\n        {\r\n\r\n            const T y = hm1.hNhNm1(points[i])[0];\r\n\r\n            weights[i] = sqrtPi.divide(y.multiply(y).multiply(number_of_points));\r\n\r\n        }\r\n\r\n\r\n\r\n        return Pair<>(points, weights);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Hermite polynomial, normalized to avoid overflow.\r\n\r\n     * <p>\r\n\r\n     * The regular Hermite polynomials and associated weights are given by:\r\n\r\n     *   <pre>\r\n\r\n     *     H\xe2\x82\x80(x)   = 1\r\n\r\n     *     H\xe2\x82\x81(x)   = 2 x\r\n\r\n     *     H\xe2\x82\x99\xe2\x82\x8a\xe2\x82\x81(x) = 2x H\xe2\x82\x99(x) - 2n H\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x), and H'\xe2\x82\x99(x) = 2n H\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x)\r\n\r\n     *     w\xe2\x82\x99(x\xe1\xb5\xa2) = [2\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9 n! \xe2\x88\x9a\xcf\x80]/[n H\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x\xe1\xb5\xa2)]\xc2\xb2\r\n\r\n     *   </pre>\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * In order to avoid overflow with normalize the polynomials h\xe2\x82\x99(x) = H\xe2\x82\x99(x) / \xe2\x88\x9a[2\xe2\x81\xbf n!]\r\n\r\n     * so the recurrence relations and weights become:\r\n\r\n     *   <pre>\r\n\r\n     *     h\xe2\x82\x80(x)   = 1\r\n\r\n     *     h\xe2\x82\x81(x)   = \xe2\x88\x9a2 x\r\n\r\n     *     h\xe2\x82\x99\xe2\x82\x8a\xe2\x82\x81(x) = [\xe2\x88\x9a2 x h\xe2\x82\x99(x) - \xe2\x88\x9an h\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x)]/\xe2\x88\x9a(n+1), and h'\xe2\x82\x99(x) = 2n h\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x)\r\n\r\n     *     u\xe2\x82\x99(x\xe1\xb5\xa2) = \xe2\x88\x9a\xcf\x80/[n N\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x\xe1\xb5\xa2)\xc2\xb2]\r\n\r\n     *   </pre>\r\n\r\n     * </p>\r\n\r\n     * @param <T> Type of the field elements.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    private static class Hermite \r\n\r\n    {\r\n\r\n\r\n\r\n        /** \xe2\x88\x9a2. */\r\n\r\n        private const T sqrt2;\r\n\r\n\r\n\r\n        /** Degree. */\r\n\r\n        private const int degree;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param field field to which rule coefficients belong\r\n\r\n         * @param degree polynomial degree\r\n\r\n         */\r\n\r\n        Hermite(Field<T> field, int degree) \r\n\r\n        {\r\n\r\n            this.sqrt2  = field.get_zero().new_instance(2).sqrt();\r\n\r\n            this.degree = degree;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute ratio H(x)/H'(x).\r\n\r\n         * @param x point at which ratio must be computed\r\n\r\n         * @return ratio H(x)/H'(x)\r\n\r\n         */\r\n\r\n        public T ratio(T x) \r\n\r\n        {\r\n\r\n            std::vector<T> h = hNhNm1(x);\r\n\r\n            return h[0].divide(h[1].multiply(2 * degree));\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Compute N\xe2\x82\x99(x) and N\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x).\r\n\r\n         * @param x point at which polynomials are evaluated\r\n\r\n         * @return array containing N\xe2\x82\x99(x) at index 0 and N\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x) at index 1\r\n\r\n         */\r\n\r\n        private std::vector<T> hNhNm1(const T x) \r\n\r\n        {\r\n\r\n            std::vector<T> h = Math_Arrays::build_array(x.get_field(), 2);\r\n\r\n            h[0] = sqrt2.multiply(x);\r\n\r\n            h[1] = x.get_field().get_one();\r\n\r\n            T sqrt_n = x.get_field().get_one();\r\n\r\n            for (const int n = 1; n < degree; n++) \r\n\r\n            {\r\n\r\n                // apply recurrence relation h\xe2\x82\x99\xe2\x82\x8a\xe2\x82\x81(x) = [\xe2\x88\x9a2 x h\xe2\x82\x99(x) - \xe2\x88\x9an h\xe2\x82\x99\xe2\x82\x8b\xe2\x82\x81(x)]/\xe2\x88\x9a(n+1)\r\n\r\n                const T sqrt_np = x.get_field().get_zero().new_instance(n + 1).sqrt();\r\n\r\n                const T hp = (h[0].multiply(x).multiply(sqrt2).subtract(h[1].multiply(sqrt_n))).divide(sqrt_np);\r\n\r\n                h[1]  = h[0];\r\n\r\n                h[0]  = hp;\r\n\r\n                sqrt_n = sqrt_np;\r\n\r\n            }\r\n\r\n            return h;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n