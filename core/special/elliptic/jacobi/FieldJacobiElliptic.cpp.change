/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.special.elliptic.jacobi;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.special.elliptic.carlson.Carlson_Elliptic_Integral;\r\n\r\n//import org.hipparchus.special.elliptic.legendre.Legendre_Elliptic_Integral;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/** Computation of Jacobi elliptic functions.\r\n\r\n * The Jacobi elliptic functions are related to elliptic integrals.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class Field_Jacobi_Elliptic \r\n\r\n{\r\n\r\n\r\n\r\n    /** Parameter of the function. */\r\n\r\n    private const T m;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param m parameter of the function\r\n\r\n     */\r\n\r\n    protected Field_Jacobi_Elliptic(const T m) \r\n\r\n    {\r\n\r\n        this.m = m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the parameter of the function.\r\n\r\n     * @return parameter of the function\r\n\r\n     */\r\n\r\n    public T get_m() \r\n\r\n    {\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three principal Jacobi elliptic functions with pole at point n in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three principal Jacobi\r\n\r\n     * elliptic functions {@code sn(u|m)}, {@code cn(u|m)}, and {@code dn(u|m)}.\r\n\r\n     */\r\n\r\n    public virtual Field_Copolar_N<T> values_n(T u);\r\n\r\n\r\n\r\n    /** Evaluate the three principal Jacobi elliptic functions with pole at point n in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three principal Jacobi\r\n\r\n     * elliptic functions {@code sn(u|m)}, {@code cn(u|m)}, and {@code dn(u|m)}.\r\n\r\n     */\r\n\r\n    public Field_Copolar_N<T> values_n(const double u) \r\n\r\n    {\r\n\r\n        return values_n(m.new_instance(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point s in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code cs(u|m)}, {@code ds(u|m)} and {@code ns(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_S<T> values_s(const T u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_S<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point s in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code cs(u|m)}, {@code ds(u|m)} and {@code ns(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_S<T> values_s(const double u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_S<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point c in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code dc(u|m)}, {@code nc(u|m)}, and {@code sc(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_C<T> values_c(const T u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_C<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point c in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code dc(u|m)}, {@code nc(u|m)}, and {@code sc(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_C<T> values_c(const double u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_C<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point d in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code nd(u|m)}, {@code sd(u|m)}, and {@code cd(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_D<T> values_d(const T u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_D<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the three subsidiary Jacobi elliptic functions with pole at point d in Glaisher\xe2\x80\x99s Notation.\r\n\r\n     * @param u argument of the functions\r\n\r\n     * @return copolar trio containing the three subsidiary Jacobi\r\n\r\n     * elliptic functions {@code nd(u|m)}, {@code sd(u|m)}, and {@code cd(u|m)}.\r\n\r\n     */\r\n\r\n    public FieldCopolar_D<T> values_d(const double u) \r\n\r\n    {\r\n\r\n        return FieldCopolar_D<>(values_n(u));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sn(u|m)}\r\n\r\n     * @return u such that {@code x=sn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsn(const T x) \r\n\r\n    {\r\n\r\n        // p = n, q = c, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcsp(x, x.get_field().get_one().negate(), get_m().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sn(u|m)}\r\n\r\n     * @return u such that {@code x=sn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsn(const double& x) \r\n\r\n    {\r\n\r\n        return arcsn(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cn(u|m)}\r\n\r\n     * @return u such that {@code x=cn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccn(const T x) \r\n\r\n    {\r\n\r\n        // p = c, q = n, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpqNoDivision(x, x.get_field().get_one(), get_m().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cn(u|m)}\r\n\r\n     * @return u such that {@code x=cn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccn(const double& x) \r\n\r\n    {\r\n\r\n        return arccn(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function dn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code dn(u|m)}\r\n\r\n     * @return u such that {@code x=dn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcdn(const T x) \r\n\r\n    {\r\n\r\n        // p = d, q = n, r = c, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpqNoDivision(x, get_m(), x.get_field().get_one().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function dn.\r\n\r\n     * @param x value of Jacobi elliptic function {@code dn(u|m)}\r\n\r\n     * @return u such that {@code x=dn(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcdn(const double& x) \r\n\r\n    {\r\n\r\n        return arcdn(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cs.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cs(u|m)}\r\n\r\n     * @return u such that {@code x=cs(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccs(const T x) \r\n\r\n    {\r\n\r\n        // p = c, q = n, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcps(x, x.get_field().get_one(), get_m().subtract(1).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cs.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cs(u|m)}\r\n\r\n     * @return u such that {@code x=cs(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccs(const double& x) \r\n\r\n    {\r\n\r\n        return arccs(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function ds.\r\n\r\n     * @param x value of Jacobi elliptic function {@code ds(u|m)}\r\n\r\n     * @return u such that {@code x=ds(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcds(const T x) \r\n\r\n    {\r\n\r\n        // p = d, q = c, r = n, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcps(x, get_m().subtract(1), get_m());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function ds.\r\n\r\n     * @param x value of Jacobi elliptic function {@code ds(u|m)}\r\n\r\n     * @return u such that {@code x=ds(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcds(const double& x) \r\n\r\n    {\r\n\r\n        return arcds(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function ns.\r\n\r\n     * @param x value of Jacobi elliptic function {@code ns(u|m)}\r\n\r\n     * @return u such that {@code x=ns(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcns(const T x) \r\n\r\n    {\r\n\r\n        // p = n, q = c, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcps(x, x.get_field().get_one().negate(), get_m().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function ns.\r\n\r\n     * @param x value of Jacobi elliptic function {@code ns(u|m)}\r\n\r\n     * @return u such that {@code x=ns(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcns(const double& x) \r\n\r\n    {\r\n\r\n        return arcns(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function dc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code dc(u|m)}\r\n\r\n     * @return u such that {@code x=dc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcdc(const T x) \r\n\r\n    {\r\n\r\n        // p = d, q = c, r = n, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpq(x, get_m().subtract(1), x.get_field().get_one());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function dc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code dc(u|m)}\r\n\r\n     * @return u such that {@code x=dc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcdc(const double& x) \r\n\r\n    {\r\n\r\n        return arcdc(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function nc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code nc(u|m)}\r\n\r\n     * @return u such that {@code x=nc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcnc(const T x) \r\n\r\n    {\r\n\r\n        // p = n, q = c, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpq(x, x.get_field().get_one().negate(), get_m().subtract(1).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function nc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code nc(u|m)}\r\n\r\n     * @return u such that {@code x=nc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcnc(const double& x) \r\n\r\n    {\r\n\r\n        return arcnc(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sc(u|m)}\r\n\r\n     * @return u such that {@code x=sc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsc(const T x) \r\n\r\n    {\r\n\r\n        // p = c, q = n, r = d, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcsp(x, x.get_field().get_one(), get_m().subtract(1).negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sc.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sc(u|m)}\r\n\r\n     * @return u such that {@code x=sc(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsc(const double& x) \r\n\r\n    {\r\n\r\n        return arcsc(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function nd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code nd(u|m)}\r\n\r\n     * @return u such that {@code x=nd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcnd(const T x) \r\n\r\n    {\r\n\r\n        // p = n, q = d, r = c, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpq(x, get_m().negate(), get_m().subtract(1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function nd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code nd(u|m)}\r\n\r\n     * @return u such that {@code x=nd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcnd(const double& x) \r\n\r\n    {\r\n\r\n        return arcnd(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sd(u|m)}\r\n\r\n     * @return u such that {@code x=sd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsd(const T x) \r\n\r\n    {\r\n\r\n        // p = d, q = n, r = c, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, p)\r\n\r\n        return arcsp(x, get_m(), get_m().subtract(1));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code sd(u|m)}\r\n\r\n     * @return u such that {@code x=sd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arcsd(const double& x) \r\n\r\n    {\r\n\r\n        return arcsd(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cd(u|m)}\r\n\r\n     * @return u such that {@code x=cd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccd(const T x) \r\n\r\n    {\r\n\r\n        // p = c, q = d, r = n, see DLMF 19.25.29 for evaluating \xce\x94\xe2\x81\xa1(q, p) and \xce\x94\xe2\x81\xa1(r, q)\r\n\r\n        return arcpq(x, get_m().subtract(1).negate(), get_m());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function cd.\r\n\r\n     * @param x value of Jacobi elliptic function {@code cd(u|m)}\r\n\r\n     * @return u such that {@code x=cd(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public T arccd(const double& x) \r\n\r\n    {\r\n\r\n        return arccd(get_m().get_field().get_zero().new_instance(x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function ps.\r\n\r\n     * <p>\r\n\r\n     * Here p, q, r are any permutation of the letters c, d, n.\r\n\r\n     * </p>\r\n\r\n     * @param x value of Jacobi elliptic function {@code ps(u|m)}\r\n\r\n     * @param deltaQP \xce\x94\xe2\x81\xa1(q, p) = q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @param deltaRP \xce\x94\xe2\x81\xa1(r, p) = r\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @return u such that {@code x=ps(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    private T arcps(const T& x, const T deltaQP, const T deltaRP) \r\n\r\n    {\r\n\r\n        // see equation 19.25.32 in Digital Library of Mathematical Functions\r\n\r\n        // https://dlmf.nist.gov/19.25.E32\r\n\r\n        const T x2       = x.multiply(x);\r\n\r\n        const T rf       = Carlson_Elliptic_Integral.r_f(x2, x2.add(deltaQP), x2.add(deltaRP));\r\n\r\n        return std::copysign(1.0, rf.get_real()) * std::copysign(1.0, x.get_real()) < 0 ?\r\n\r\n               rf.negate() : rf;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function sp.\r\n\r\n     * <p>\r\n\r\n     * Here p, q, r are any permutation of the letters c, d, n.\r\n\r\n     * </p>\r\n\r\n     * @param x value of Jacobi elliptic function {@code sp(u|m)}\r\n\r\n     * @param deltaQP \xce\x94\xe2\x81\xa1(q, p) = q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @param deltaRP \xce\x94\xe2\x81\xa1(r, p) = r\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @return u such that {@code x=sp(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    private T arcsp(const T& x, const T deltaQP, const T deltaRP) \r\n\r\n    {\r\n\r\n        // see equation 19.25.33 in Digital Library of Mathematical Functions\r\n\r\n        // https://dlmf.nist.gov/19.25.E33\r\n\r\n        const T x2       = x.multiply(x);\r\n\r\n        return x.multiply(Carlson_Elliptic_Integral.r_f(x.get_field().get_one(), deltaQP.multiply(x2).add(1), deltaRP.multiply(x2).add(1)));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function pq.\r\n\r\n     * <p>\r\n\r\n     * Here p, q, r are any permutation of the letters c, d, n.\r\n\r\n     * </p>\r\n\r\n     * @param x value of Jacobi elliptic function {@code pq(u|m)}\r\n\r\n     * @param deltaQP \xce\x94\xe2\x81\xa1(q, p) = q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @param deltaRQ \xce\x94\xe2\x81\xa1(r, q) = r\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @return u such that {@code x=pq(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    private T arcpq(const T& x, const T deltaQP, const T deltaRQ) \r\n\r\n    {\r\n\r\n        // see equation 19.25.34 in Digital Library of Mathematical Functions\r\n\r\n        // https://dlmf.nist.gov/19.25.E34\r\n\r\n        const T x2       = x.multiply(x);\r\n\r\n        const T w        = x2.subtract(1).negate().divide(deltaQP);\r\n\r\n        const T rf       = Carlson_Elliptic_Integral.r_f(x2, x.get_field().get_one(), deltaRQ.multiply(w).add(1));\r\n\r\n        const T positive = w.sqrt().multiply(rf);\r\n\r\n        return x.get_real() < 0 ? Legendre_Elliptic_Integral.big_k(get_m()).multiply(2).subtract(positive) : positive;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate inverse of Jacobi elliptic function pq.\r\n\r\n     * <p>\r\n\r\n     * Here p, q, r are any permutation of the letters c, d, n.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * This computed the same thing as {@link #arcpq(Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element)}\r\n\r\n     * but uses the homogeneity property Rf(x, y, z) = Rf(ax, ay, az) / \xe2\x88\x9aa to get rid of the division\r\n\r\n     * by deltaRQ. This division induces problems in the complex case as it may lose the sign\r\n\r\n     * of zero for values exactly along the real or imaginary axis, hence perturbing branch cuts.\r\n\r\n     * </p>\r\n\r\n     * @param x value of Jacobi elliptic function {@code pq(u|m)}\r\n\r\n     * @param deltaQP \xce\x94\xe2\x81\xa1(q, p) = q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - p\xe2\x81\xa3s\xc2\xb2(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @param deltaRQ \xce\x94\xe2\x81\xa1(r, q) = r\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) - q\xe2\x81\xa3s\xc2\xb2\xe2\x81\xa1(u|m) (equation 19.5.28 of DLMF)\r\n\r\n     * @return u such that {@code x=pq(u|m)}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    private T arcpqNoDivision(const T& x, const T deltaQP, const T deltaRQ) \r\n\r\n    {\r\n\r\n        // see equation 19.25.34 in Digital Library of Mathematical Functions\r\n\r\n        // https://dlmf.nist.gov/19.25.E34\r\n\r\n        const T x2       = x.multiply(x);\r\n\r\n        const T wDeltaQP = x2.subtract(1).negate();\r\n\r\n        const T rf       = Carlson_Elliptic_Integral.r_f(x2.multiply(deltaQP), deltaQP, deltaRQ.multiply(wDeltaQP).add(deltaQP));\r\n\r\n        const T positive = wDeltaQP.sqrt().multiply(rf);\r\n\r\n        return std::copysign(1.0, x.get_real()) < 0 ?\r\n\r\n               Legendre_Elliptic_Integral.big_k(get_m()).multiply(2).subtract(positive) :\r\n\r\n               positive;\r\n\r\n     }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n