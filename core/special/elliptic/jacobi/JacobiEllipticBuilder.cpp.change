/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.special.elliptic.jacobi;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.complex.std::complex<double>;\r\n\r\n//import org.hipparchus.complex.Field_std::complex<double>;\r\n\r\n\r\n\r\n/** Builder for algorithms compmuting Jacobi elliptic functions.\r\n\r\n * <p>\r\n\r\n * The Jacobi elliptic functions are related to elliptic integrals.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * There are different conventions to interpret the arguments of\r\n\r\n * Jacobi elliptic functions. The first argument may be  the amplitude \xcf\x86, * but is more often the variable u (with sn(u) = sin(\xcf\x86) and cn(u) = cos(\xcf\x86)).\r\n\r\n * The second argument  is either the modulus k or the parameter m with m = k\xc2\xb2.\r\n\r\n * In Hipparchus, we adopted the convention to use u and m.\r\n\r\n * </p>\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\nclass Jacobi_Elliptic_Builder \r\n\r\n{\r\n\r\n\r\n\r\n    /** Threshold near 0 for using specialized algorithm. */\r\n\r\n    private static const double NEAR_ZERO = 1.0e-9;\r\n\r\n\r\n\r\n    /** Threshold near 1 for using specialized algorithm. */\r\n\r\n    private static const double NEAR_ONE = 1.0 - NEAR_ZERO;\r\n\r\n\r\n\r\n    /** Private constructor for utility class.\r\n\r\n     */\r\n\r\n    private Jacobi_Elliptic_Builder() \r\n\r\n    {\r\n\r\n        // nothing to do\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build an algorithm for computing Jacobi elliptic functions.\r\n\r\n     * @param m parameter of the Jacobi elliptic function\r\n\r\n     * @return selected algorithm\r\n\r\n     */\r\n\r\n    public static Jacobi_Elliptic build(const double m) \r\n\r\n    {\r\n\r\n        if (m < 0) \r\n\r\n        {\r\n\r\n            return Negative_Parameter(m);\r\n\r\n        }\r\n\r\nelse if (m > 1) \r\n\r\n        {\r\n\r\n            return Big_Parameter(m);\r\n\r\n        }\r\n\r\nelse if (m < NEAR_ZERO) \r\n\r\n        {\r\n\r\n            return Near_Zero_Parameter(m);\r\n\r\n        }\r\n\r\nelse if (m > NEAR_ONE) \r\n\r\n        {\r\n\r\n            return Near_One_Parameter(m);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return Bounded_Parameter(m);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build an algorithm for computing Jacobi elliptic functions.\r\n\r\n     * @param m parameter of the Jacobi elliptic function\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return selected algorithm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  Field_Jacobi_Elliptic<T> build(const T m) \r\n\r\n    {\r\n\r\n        if (m.get_real() < 0) \r\n\r\n        {\r\n\r\n            return Field_Negative_Parameter<>(m);\r\n\r\n        }\r\n\r\nelse if (m.get_real() > 1) \r\n\r\n        {\r\n\r\n            return FieldBig_Parameter<>(m);\r\n\r\n        }\r\n\r\nelse if (m.get_real() < NEAR_ZERO) \r\n\r\n        {\r\n\r\n            return Field_Near_Zero_Parameter<>(m);\r\n\r\n        }\r\n\r\nelse if (m.get_real() > NEAR_ONE) \r\n\r\n        {\r\n\r\n            return Field_Near_One_Parameter<>(m);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return FieldBounded_Parameter<>(m);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build an algorithm for computing Jacobi elliptic functions.\r\n\r\n     * @param m parameter of the Jacobi elliptic function\r\n\r\n     * @return selected algorithm\r\n\r\n     */\r\n\r\n    public static Field_Jacobi_Elliptic<std::complex<double>> build(const std::complex<double> m) \r\n\r\n    {\r\n\r\n        return std::complex<double>_Parameter(m);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build an algorithm for computing Jacobi elliptic functions.\r\n\r\n     * @param m parameter of the Jacobi elliptic function\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return selected algorithm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  Field_Jacobi_Elliptic<Field_Complex<T>> build(const Field_Complex<T> m) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double>_Parameter<>(m);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n