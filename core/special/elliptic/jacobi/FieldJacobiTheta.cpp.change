/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.special.elliptic.jacobi;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n\r\n\r\n/** Algorithm computing Jacobi theta functions.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Jacobi_Theta\r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Maximum number of terms in the Fourier series. */\r\n\r\n    static constexpr int N_MAX{ 100 };\r\n\r\n\r\n\r\n    /** Nome. */\r\n\r\n    const T my_q;\r\n\r\n\r\n\r\n    /** q\xc2\xb2. */\r\n\r\n    const T my_q_Square;\r\n\r\n\r\n\r\n    /** \xe2\x88\x9cq. */\r\n\r\n    const T my_q_fourth;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Simple constructor.\r\n\r\n     * <p>\r\n\r\n     * The nome {@code q} can be computed using ratios of complete elliptic integrals\r\n\r\n     * ({@link org.hipparchus.special.elliptic.legendre.Legendre_Elliptic_Integral#nome(Calculus_Field_Element)\r\n\r\n     * Legendre_Elliptic_Integral.nome(m)} which are themselves defined in term of parameter m, * where m=k\xc2\xb2 and k is the elliptic modulus.\r\n\r\n     * </p>\r\n\r\n     * @param q nome\r\n\r\n     */\r\n\r\n    Field_Jacobi_Theta(const T q)\r\n\r\n    {\r\n\r\n        this.q = q;\r\n\r\n        this.my_q_Square = q.multiply(q);\r\n\r\n        this.my_q_fourth = std::sqrt(std::sqrt(q));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the nome.\r\n\r\n     * @return nome\r\n\r\n     */\r\n\r\n    T get_q()\r\n\r\n    {\r\n\r\n        return q;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the Jacobi theta functions.\r\n\r\n     * @param z argument of the functions\r\n\r\n     * @return container for the four Jacobi theta functions \xce\xb8\xe2\x82\x81(z|\xcf\x84), \xce\xb8\xe2\x82\x82(z|\xcf\x84), \xce\xb8\xe2\x82\x83(z|\xcf\x84), and \xce\xb8\xe2\x82\x84(z|\xcf\x84)\r\n\r\n     */\r\n\r\n    Field_Theta<T> values(const T z)\r\n\r\n    {\r\n\r\n\r\n\r\n        // the computation is based on Fourier series, // see Digital Library of Mathematical Functions section 20.2\r\n\r\n        // https://dlmf.nist.gov/20.2\r\n\r\n        const T zero = q.get_field().get_zero();\r\n\r\n        const T one = q.get_field().get_one();\r\n\r\n\r\n\r\n        // base angle for Fourier Series\r\n\r\n        const Field_Sin_Cos<T> sc1 = Sin_Cos(z);\r\n\r\n\r\n\r\n        // recursion rules initialization\r\n\r\n        double         sgn = 1.0;\r\n\r\n        T              qNN = one;\r\n\r\n        T              qTwoN = one;\r\n\r\n        T              qNNp1 = one;\r\n\r\n        Field_Sin_Cos<T> sc2n1 = sc1;\r\n\r\n        const double   eps = FastMath.ulp(one).get_real();\r\n\r\n\r\n\r\n        // Fourier series\r\n\r\n        T sum1 = sc1.sin();\r\n\r\n        T sum2 = sc1.cos();\r\n\r\n        T sum3 = zero;\r\n\r\n        T sum4 = zero;\r\n\r\n        for (const int n = 1; n < N_MAX; ++n)\r\n\r\n        {\r\n\r\n\r\n\r\n            sgn = -sgn;                            // (-1)\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9     \xe2\x86\x90 (-1)\xe2\x81\xbf\r\n\r\n            qNN = qNN.multiply(qTwoN).multiply(q); // q\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9\xe2\x81\xbe\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9\xe2\x81\xbe \xe2\x86\x90 q\xe2\x81\xbf\xe2\x81\xbf\r\n\r\n            qTwoN = qTwoN.multiply(my_q_Square);         // q\xc2\xb2\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9\xe2\x81\xbe     \xe2\x86\x90 q\xc2\xb2\xe2\x81\xbf\r\n\r\n            qNNp1 = qNNp1.multiply(qTwoN);           // q\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xbb\xc2\xb9\xe2\x81\xbe\xe2\x81\xbf     \xe2\x86\x90 q\xe2\x81\xbf\xe2\x81\xbd\xe2\x81\xbf\xe2\x81\xba\xc2\xb9\xe2\x81\xbe\r\n\r\n\r\n\r\n            sc2n1 = Field_Sin_Cos.sum(sc2n1, sc1); // {sin|cos}([2n-1] z) \xe2\x86\x90 {sin|cos}(2n z)\r\n\r\n            sum3 = sum3.add(sc2n1.cos().multiply(qNN));\r\n\r\n            sum4 = sum4.add(sc2n1.cos().multiply(qNN.multiply(sgn)));\r\n\r\n\r\n\r\n            sc2n1 = Field_Sin_Cos.sum(sc2n1, sc1); // {sin|cos}(2n z) \xe2\x86\x90 {sin|cos}([2n+1] z)\r\n\r\n            sum1 = sum1.add(sc2n1.sin().multiply(qNNp1.multiply(sgn)));\r\n\r\n            sum2 = sum2.add(sc2n1.cos().multiply(qNNp1));\r\n\r\n\r\n\r\n            if (qNNp1.norm() <= eps)\r\n\r\n            {\r\n\r\n                // we have reach convergence\r\n\r\n                break;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return Field_Theta<>(sum1.multiply(my_q_fourth.multiply(2)), sum2.multiply(my_q_fourth.multiply(2)), sum3.multiply(2).add(1), sum4.multiply(2).add(1));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n};\r\n