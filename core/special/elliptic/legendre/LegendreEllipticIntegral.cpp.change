/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n //package org.hipparchus.special.elliptic.legendre;\r\n\r\n\r\n\r\n //import java.util.function.Double_Function;\r\n\r\n //import java.util.function.Function;\r\n\r\n\r\n\r\n //import org.hipparchus.Calculus_Field_Element;\r\n\r\n //import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n //import org.hipparchus.complex.std::complex<double>;\r\n\r\n //import org.hipparchus.complex.std::complex<double>_Univariate_Integrator;\r\n\r\n //import org.hipparchus.complex.Field_std::complex<double>;\r\n\r\n //import org.hipparchus.complex.Field_std::complex<double>_Univariate_Integrator;\r\n\r\n //import org.hipparchus.special.elliptic.carlson.Carlson_Elliptic_Integral;\r\n\r\n //import org.hipparchus.util.FastMath;\r\n\r\n //import org.hipparchus.util.Math_Utils;\r\n\r\n#include <vector>\r\n\r\n#include <numbers>\r\n\r\n\r\n\r\n /** Complete and incomplete elliptic integrals in Legendre form.\r\n\r\n  * <p>\r\n\r\n  * The elliptic integrals are related to Jacobi elliptic functions.\r\n\r\n  * </p>\r\n\r\n  * <p>\r\n\r\n  * <emph>\r\n\r\n  * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n  * are considered experimental for now, they have known issues:\r\n\r\n  * <a href="https://github.com/Hipparchus-Math/hipparchus/issues/151">issue 151</a>\r\n\r\n  * and <a href="https://github.com/Hipparchus-Math/hipparchus/issues/152">issue 152</a>.\r\n\r\n  * </emph>\r\n\r\n  * </p>\r\n\r\n  * <p>\r\n\r\n  * There are different conventions to interpret the arguments of\r\n\r\n  * Legendre elliptic integrals. In mathematical texts, these conventions show\r\n\r\n  * up using the separator between arguments. So for example for the incomplete\r\n\r\n  * integral of the first kind F we have:\r\n\r\n  * <ul>\r\n\r\n  *   <li>F(\xcf\x86, k): the first argument \xcf\x86 is an angle and the second argument k\r\n\r\n  *       is the elliptic modulus: this is the trigonometric form of the integral</li>\r\n\r\n  *   <li>F(\xcf\x86; m): the first argument \xcf\x86 is an angle and the second argument m=k\xc2\xb2\r\n\r\n  *       is the parameter: this is also a trigonometric form of the integral</li>\r\n\r\n  *   <li>F(x|m): the first argument x=sin(\xcf\x86) is not an angle anymore and the\r\n\r\n  *       second argument m=k\xc2\xb2 is the parameter: this is the Legendre form</li>\r\n\r\n  *   <li>F(\xcf\x86\\\xce\xb1): the first argument \xcf\x86 is an angle and the second argument \xce\xb1 is the\r\n\r\n  *       modular angle</li>\r\n\r\n  * </ul>\r\n\r\n  * As we have no separator in a method call, we have to adopt one convention\r\n\r\n  * and stick to it. In Hipparchus, we adopted the Legendre form (i.e. F(x|m), * with x=sin(\xcf\x86) and m=k\xc2\xb2. These conventions are consistent with Wolfram Alpha\r\n\r\n  * functions Elliptic_F, Elliptic_E, ElliptiPI\xe2\x80\xa6\r\n\r\n  * </p>\r\n\r\n  * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n  * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n  * @see <a href="https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html">Complete Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n  * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n  * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n  * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n  * @since 2.0\r\n\r\n  */\r\n\r\nclass Legendre_Elliptic_Integral\r\n\r\n{\r\n\r\n\t/** Private constructor for a utility class.\r\n\r\n\t */\r\n\r\n\tprivate Legendre_Elliptic_Integral()\r\n\r\n\t{\r\n\r\n\t\t// nothing to do\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the nome q.\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return nome q\r\n\r\n\t */\r\n\r\n\tpublic static double nome(const double m)\r\n\r\n\t{\r\n\r\n\t\tif (m < 1.0e-16)\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.21\r\n\r\n\t\t\tconst double m16 = m * 0.0625;\r\n\r\n\t\t\treturn m16 * (1 + 8 * m16);\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn std::exp(-std::numbers::pi * big_k_prime(m) / big_k(m));\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the nome q.\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return nome q\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T nome(const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\tif (m.norm() < 100 * one.ulp().get_real())\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.21\r\n\r\n\t\t\tconst T m16 = m.multiply(0.0625);\r\n\r\n\t\t\treturn m16.multiply(m16.multiply(8).add(1));\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn std::exp(big_k_prime(m).divide(big_k(m)).multiply(one.get_pi().negate()));\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the real quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the first kind K(m)\r\n\r\n\t * @see #big_k_primestatic_cast<double>(\r\n\r\n\t * @see #big_f(double, double)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_k(const double m)\r\n\r\n\t{\r\n\r\n\t\tif (m < 1.0e-8)\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.11\r\n\r\n\t\t\treturn (1 + 0.25 * m) * Math_Utils::SEMI_PI;\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn Carlson_Elliptic_Integral.r_f(0, 1.0 - m, 1);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the real quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the first kind K(m)\r\n\r\n\t * @see #big_k_prime(Calculus_Field_Element)\r\n\r\n\t * @see #big_f(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_k(const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T zero = m.get_field().get_zero();\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\tif (m.norm() < 1.0e7 * one.ulp().get_real())\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.11\r\n\r\n\t\t\treturn one.add(m.multiply(0.25)).multiply(zero.get_pi().multiply(0.5));\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn Carlson_Elliptic_Integral.r_f(zero, one.subtract(m), one);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the real quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the first kind K(m)\r\n\r\n\t * @see #big_k_prime(std::complex<double>)\r\n\r\n\t * @see #big_f(std::complex<double>, std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_k(const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\tif (m.norm() < 1.0e-8)\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.11\r\n\r\n\t\t\treturn std::complex<double>.ONE.add(m.multiply(0.25)).multiply(Math_Utils::SEMI_PI);\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn Carlson_Elliptic_Integral.r_f(std::complex<double>.ZERO, std::complex<double>.ONE.subtract(m), std::complex<double>.ONE);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the real quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the first kind K(m)\r\n\r\n\t * @see #big_k_prime(Field_std::complex<double>)\r\n\r\n\t * @see #big_f(Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_k(const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\tconst Field_Complex<T> zero = m.get_field().get_zero();\r\n\r\n\t\tconst Field_Complex<T> one = m.get_field().get_one();\r\n\r\n\t\tif (m.norm() < 1.0e7 * one.ulp().get_real())\r\n\r\n\t\t{\r\n\r\n\t\t\t// first terms of infinite series in Abramowitz and Stegun 17.3.11\r\n\r\n\t\t\treturn one.add(m.multiply(0.25)).multiply(zero.get_pi().multiply(0.5));\r\n\r\n\t\t}\r\n\r\n\t\telse\r\n\r\n\t\t{\r\n\r\n\t\t\treturn Carlson_Elliptic_Integral.r_f(zero, one.subtract(m), one);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K'(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K'(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-(1-m) \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the imaginary quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the first kind K'(m)\r\n\r\n\t * @see #big_kstatic_cast<double>(\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_k_prime(const double m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(0, m, 1);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K'(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K'(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-(1-m) \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the imaginary quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the first kind K'(m)\r\n\r\n\t * @see #big_k(Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_k_prime(const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T zero = m.get_field().get_zero();\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(zero, m, one);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K'(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K'(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-(1-m) \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the imaginary quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the first kind K'(m)\r\n\r\n\t * @see #big_k(std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_k_prime(const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(std::complex<double>.ZERO, m, std::complex<double>.ONE);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the first kind K'(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the first kind K'(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-(1-m) \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * it corresponds to the imaginary quarter-period of Jacobi elliptic functions\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the first kind K'(m)\r\n\r\n\t * @see #big_k(Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_complete_elliptic_integralofthe_first_kind.html">Complete Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_k_prime(const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\tconst Field_Complex<T> zero = m.get_field().get_zero();\r\n\r\n\t\tconst Field_Complex<T> one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(zero, m, one);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the second kind E(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the second kind E(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the second kind E(m)\r\n\r\n\t * @see #big_e(double, double)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html">Complete Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_e(const double m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rG(0, 1 - m, 1) * 2;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the second kind E(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the second kind E(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the second kind E(m)\r\n\r\n\t * @see #big_e(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html">Complete Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_e(const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T zero = m.get_field().get_zero();\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rG(zero, one.subtract(m), one).multiply(2);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the second kind E(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the second kind E(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the second kind E(m)\r\n\r\n\t * @see #big_e(std::complex<double>, std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html">Complete Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_e(const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rG(std::complex<double>.ZERO, std::complex<double>.ONE.subtract(m), std::complex<double>.ONE).multiply(2);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the second kind E(m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the second kind E(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the second kind E(m)\r\n\r\n\t * @see #big_e(Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/CompleteEllipticIntegraloftheSecondKind.html">Complete Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_e(const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\tconst Field_Complex<T> zero = m.get_field().get_zero();\r\n\r\n\t\tconst Field_Complex<T> one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rG(zero, one.subtract(m), one).multiply(2);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral D(m) = [K(m) - E(m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral D(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral D(m)\r\n\r\n\t * @see #big_d(double, double)\r\n\r\n\t */\r\n\r\n\tpublic static double big_d(const double m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rD(0, 1 - m, 1) / 3;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral D(m) = [K(m) - E(m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral D(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral D(m)\r\n\r\n\t * @see #big_d(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_d(const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T zero = m.get_field().get_zero();\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rD(zero, one.subtract(m), one).divide(3);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral D(m) = [K(m) - E(m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral D(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral D(m)\r\n\r\n\t * @see #big_d(std::complex<double>, std::complex<double>)\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_d(const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rD(std::complex<double>.ZERO, std::complex<double>.ONE.subtract(m), std::complex<double>.ONE).divide(3);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral D(m) = [K(m) - E(m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral D(m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral D(m)\r\n\r\n\t * @see #big_d(Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_d(const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\tconst Field_Complex<T> zero = m.get_field().get_zero();\r\n\r\n\t\tconst Field_Complex<T> one = m.get_field().get_one();\r\n\r\n\t\treturn Carlson_Elliptic_Integral.rD(zero, one.subtract(m), one).divide(3);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the third kind \xce\xa0(n, m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the third kind \xce\xa0(n, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the third kind \xce\xa0(n, m)\r\n\r\n\t * @see #big_pi(double, double, double)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_pi(const double n, const double m)\r\n\r\n\t{\r\n\r\n\t\tconst double k_prime2 = 1 - m;\r\n\r\n\t\tconst double delta = n * (m - n) * (n - 1);\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(0, k_prime2, 1) +\r\n\r\n\t\t\tCarlson_Elliptic_Integral.rJ(0, k_prime2, 1, 1 - n, delta) * n / 3;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the third kind \xce\xa0(n, m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the third kind \xce\xa0(n, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the third kind \xce\xa0(n, m)\r\n\r\n\t * @see #big_pi(Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_pi(const T n, const T m)\r\n\r\n\t{\r\n\r\n\t\tconst T zero = m.get_field().get_zero();\r\n\r\n\t\tconst T one = m.get_field().get_one();\r\n\r\n\t\tconst T k_prime2 = one.subtract(m);\r\n\r\n\t\tconst T delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(zero, k_prime2, one).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(zero, k_prime2, one, one.subtract(n), delta).multiply(n).divide(3));\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the third kind \xce\xa0(n, m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the third kind \xce\xa0(n, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return complete elliptic integral of the third kind \xce\xa0(n, m)\r\n\r\n\t * @see #big_pi(std::complex<double>, std::complex<double>, std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_pi(const std::complex<double> n, const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\tconst std::complex<double> k_prime2 = std::complex<double>.ONE.subtract(m);\r\n\r\n\t\tconst std::complex<double> delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(std::complex<double>.ZERO, k_prime2, std::complex<double>.ONE).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(std::complex<double>.ZERO, k_prime2, std::complex<double>.ONE, std::complex<double>.ONE.subtract(n), delta).multiply(n).divide(3));\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the complete elliptic integral of the third kind \xce\xa0(n, m).\r\n\r\n\t * <p>\r\n\r\n\t * The complete elliptic integral of the third kind \xce\xa0(n, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\x0crac{\\pi}{2}} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return complete elliptic integral of the third kind \xce\xa0(n, m)\r\n\r\n\t * @see #big_pi(Field_std::complex<double>, Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_pi(const Field_Complex<T> n, const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\tconst Field_Complex<T> zero = m.get_field().get_zero();\r\n\r\n\t\tconst Field_Complex<T> one = m.get_field().get_one();\r\n\r\n\t\tconst Field_Complex<T> k_prime2 = one.subtract(m);\r\n\r\n\t\tconst Field_Complex<T> delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\treturn Carlson_Elliptic_Integral.r_f(zero, k_prime2, one).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(zero, k_prime2, one, one.subtract(n), delta).multiply(n).divide(3));\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_kstatic_cast<double>(\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_f(const double& phi, const double m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Double_Argument_Reduction ar = Double_Argument_Reduction(phi, m, n->big_k(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst double c_m1 = ar.csc2 - 1.0;\r\n\r\n\t\tconst double c_mm = ar.csc2 - m;\r\n\r\n\t\tconst double incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete - incomplete : ar.complete + incomplete;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_k(Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_f(const T phi, const T m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<T> ar = Field_Argument_Reduction<>(phi, m, n->big_k(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst T c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst T c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst T incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_k(std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_f(const std::complex<double> phi, const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<std::complex<double>> ar = Field_Argument_Reduction<>(phi, m, n->big_k(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst std::complex<double> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst std::complex<double> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst std::complex<double> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m) using numerical integration.\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_k(std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_f(const std::complex<double> phi, const std::complex<double> m, const std::complex<double>_Univariate_Integrator integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, First<>(m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_k(Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_f(const Field_Complex<T> phi, const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<Field_Complex<T>> ar = Field_Argument_Reduction<>(phi, m, n->big_k(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst Field_Complex<T> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst Field_Complex<T> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst Field_Complex<T> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the first kind F(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the first kind F(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the first kind F(\xcf\x86, m)\r\n\r\n\t * @see #big_k(Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheFirstKind.html">Elliptic Integrals of the First Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_f(const Field_Complex<T> phi, const Field_Complex<T> m, const Field_std::complex<double>_Univariate_Integrator<T> integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, First<>(m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_estatic_cast<double>(\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_e(const double& phi, const double m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Double_Argument_Reduction ar = Double_Argument_Reduction(phi, m, n->big_e(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst double c_m1 = ar.csc2 - 1.0;\r\n\r\n\t\tconst double c_mm = ar.csc2 - m;\r\n\r\n\t\tconst double incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2) -\r\n\r\n\t\t\tCarlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2) * (m / 3);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete - incomplete : ar.complete + incomplete;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_e(Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_e(const T phi, const T m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<T> ar = Field_Argument_Reduction<>(phi, m, n->big_e(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst T c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst T c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst T incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tsubtract(Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).multiply(m.divide(3)));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_e(std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_e(const std::complex<double> phi, const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<std::complex<double>> ar = Field_Argument_Reduction<>(phi, m, n->big_e(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst std::complex<double> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst std::complex<double> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst std::complex<double> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tsubtract(Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).multiply(m.divide(3)));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m) using numerical integration.\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_e(std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_e(const std::complex<double> phi, const std::complex<double> m, const std::complex<double>_Univariate_Integrator integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, Second<>(m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_e(Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_e(const Field_Complex<T> phi, const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<Field_Complex<T>> ar = Field_Argument_Reduction<>(phi, m, n->big_e(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst Field_Complex<T> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst Field_Complex<T> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst Field_Complex<T> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tsubtract(Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).multiply(m.divide(3)));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the second kind E(\xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the second kind E(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \\sqrt{1-m \\sin^2\theta} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the second kind E(\xcf\x86, m)\r\n\r\n\t * @see #big_e(Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/EllipticIntegraloftheSecondKind.html">Elliptic Integrals of the Second Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_e(const Field_Complex<T> phi, const Field_Complex<T> m, const Field_std::complex<double>_Univariate_Integrator<T> integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, Second<>(m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral D(\xcf\x86, m) = [F(\xcf\x86, m) - E(\xcf\x86, m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral D(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral D(\xcf\x86, m)\r\n\r\n\t * @see #big_dstatic_cast<double>(\r\n\r\n\t */\r\n\r\n\tpublic static double big_d(const double& phi, const double m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Double_Argument_Reduction ar = Double_Argument_Reduction(phi, m, n->big_d(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst double c_m1 = ar.csc2 - 1.0;\r\n\r\n\t\tconst double c_mm = ar.csc2 - m;\r\n\r\n\t\tconst double incomplete = Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2) / 3;\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete - incomplete : ar.complete + incomplete;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral D(\xcf\x86, m) = [F(\xcf\x86, m) - E(\xcf\x86, m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral D(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral D(\xcf\x86, m)\r\n\r\n\t * @see #big_d(Calculus_Field_Element)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_d(const T phi, const T m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<T> ar = Field_Argument_Reduction<>(phi, m, n->big_d(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst T c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst T c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst T incomplete = Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).divide(3);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral D(\xcf\x86, m) = [F(\xcf\x86, m) - E(\xcf\x86, m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral D(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral D(\xcf\x86, m)\r\n\r\n\t * @see #big_d(std::complex<double>)\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_d(const std::complex<double> phi, const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<std::complex<double>> ar = Field_Argument_Reduction<>(phi, m, n->big_d(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst std::complex<double> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst std::complex<double> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst std::complex<double> incomplete = Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).divide(3);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral D(\xcf\x86, m) = [F(\xcf\x86, m) - E(\xcf\x86, m)]/m.\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral D(\xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{\\sin^2\theta}{\\sqrt{1-m \\sin^2\theta}} d\theta\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral D(\xcf\x86, m)\r\n\r\n\t * @see #big_d(Calculus_Field_Element)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_d(const Field_Complex<T> phi, const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<Field_Complex<T>> ar = Field_Argument_Reduction<>(phi, m, n->big_d(n));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst Field_Complex<T> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst Field_Complex<T> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst Field_Complex<T> incomplete = Carlson_Elliptic_Integral.rD(c_m1, c_mm, ar.csc2).divide(3);\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(double, double)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static double big_pi(const double n, const double& phi, const double m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Double_Argument_Reduction ar = Double_Argument_Reduction(phi, m, parameter->big_pi(n, parameter));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst double c_m1 = ar.csc2 - 1.0;\r\n\r\n\t\tconst double c_mm = ar.csc2 - m;\r\n\r\n\t\tconst double c_mn = ar.csc2 - n;\r\n\r\n\t\tconst double delta = n * (m - n) * (n - 1);\r\n\r\n\t\tconst double incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2) +\r\n\r\n\t\t\tCarlson_Elliptic_Integral.rJ(c_m1, c_mm, ar.csc2, c_mn, delta) * n / 3;\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete - incomplete : ar.complete + incomplete;\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  T big_pi(const T n, const T phi, const T m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<T> ar = Field_Argument_Reduction<>(phi, m, parameter->big_pi(n, parameter));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst T c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst T c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst T c_mn = ar.csc2.subtract(n);\r\n\r\n\t\tconst T delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\tconst T incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(c_m1, c_mm, ar.csc2, c_mn, delta).multiply(n).divide(3));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(std::complex<double>, std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_pi(const std::complex<double> n, const std::complex<double> phi, const std::complex<double> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<std::complex<double>> ar = Field_Argument_Reduction<>(phi, m, parameter->big_pi(n, parameter));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst std::complex<double> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst std::complex<double> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst std::complex<double> c_mn = ar.csc2.subtract(n);\r\n\r\n\t\tconst std::complex<double> delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\tconst std::complex<double> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(c_m1, c_mm, ar.csc2, c_mn, delta).multiply(n).divide(3));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) using numerical integration.\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(std::complex<double>, std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n\t */\r\n\r\n\tpublic static std::complex<double> big_pi(const std::complex<double> n, const std::complex<double> phi, const std::complex<double> m, const std::complex<double>_Univariate_Integrator integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, Third<>(n, m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on {@link Carlson_Elliptic_Integral\r\n\r\n\t * Carlson elliptic integrals}.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_pi(const Field_Complex<T> n, const Field_Complex<T> phi, const Field_Complex<T> m)\r\n\r\n\t{\r\n\r\n\t\t// argument reduction\r\n\r\n\t\tconst Field_Argument_Reduction<Field_Complex<T>> ar = Field_Argument_Reduction<>(phi, m, parameter->big_pi(n, parameter));\r\n\r\n\r\n\r\n\t\t// integrate part between 0 and \xcf\x80/2\r\n\r\n\t\tconst Field_Complex<T> c_m1 = ar.csc2.subtract(1);\r\n\r\n\t\tconst Field_Complex<T> c_mm = ar.csc2.subtract(m);\r\n\r\n\t\tconst Field_Complex<T> c_mn = ar.csc2.subtract(n);\r\n\r\n\t\tconst Field_Complex<T> delta = n.multiply(m.subtract(n)).multiply(n.subtract(1));\r\n\r\n\t\tconst Field_Complex<T> incomplete = Carlson_Elliptic_Integral.r_f(c_m1, c_mm, ar.csc2).\r\n\r\n\t\t\tadd(Carlson_Elliptic_Integral.rJ(c_m1, c_mm, ar.csc2, c_mn, delta).multiply(n).divide(3));\r\n\r\n\r\n\r\n\t\t// combine complete and incomplete parts\r\n\r\n\t\treturn ar.negate ? ar.complete.subtract(incomplete) : ar.complete.add(incomplete);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Get the incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m).\r\n\r\n\t * <p>\r\n\r\n\t * <emph>\r\n\r\n\t * BEWARE! Elliptic integrals for complex numbers in the incomplete case\r\n\r\n\t * are considered experimental for now, they have known issues.\r\n\r\n\t * </emph>\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m) is\r\n\r\n\t * \\[\r\n\r\n\t *    \\int_0^{\\phi} \x0crac{d\theta}{\\sqrt{1-m \\sin^2\theta}(1-n \\sin^2\theta)}\r\n\r\n\t * \\]\r\n\r\n\t * </p>\r\n\r\n\t * <p>\r\n\r\n\t * The algorithm for evaluating the functions is based on numerical integration.\r\n\r\n\t * If integration path comes too close to a pole of the integrand, then integration will fail\r\n\r\n\t * with a {@link org.hipparchus.exception.Math_Illegal_State_Exception Math_Illegal_State_Exception}\r\n\r\n\t * even for very large {@code max_eval}. This is normal behavior.\r\n\r\n\t * </p>\r\n\r\n\t * @param n elliptic characteristic\r\n\r\n\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t * @param integrator integrator to use\r\n\r\n\t * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n\t * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n\t * @param <T> the type of the field elements\r\n\r\n\t * @return incomplete elliptic integral of the third kind \xce\xa0(n, \xcf\x86, m)\r\n\r\n\t * @see #big_pi(Field_std::complex<double>, Field_std::complex<double>)\r\n\r\n\t * @see <a href="https://mathworld.wolfram.com/_elliptic_integralofthe_third_kind.html">Elliptic Integrals of the Third Kind (MathWorld)</a>\r\n\r\n\t * @see <a href="https://en.wikipedia.org/wiki/Elliptic_integral">Elliptic Integrals (Wikipedia)</a>\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tpublic static  Field_Complex<T> big_pi(const Field_Complex<T> n, const Field_Complex<T> phi, const Field_Complex<T> m, const Field_std::complex<double>_Univariate_Integrator<T> integrator, const int max_eval)\r\n\r\n\t{\r\n\r\n\t\treturn integrator.integrate(max_eval, Third<>(n, m), phi.get_field().get_zero(), phi);\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Argument reduction for an incomplete integral. */\r\n\r\n\tprivate static class Double_Argument_Reduction\r\n\r\n\t{\r\n\r\n\t\t/** Complete part. */\r\n\r\n\t\tprivate const double complete;\r\n\r\n\r\n\r\n\t\t/** Squared cosecant of the Jacobi amplitude. */\r\n\r\n\t\tprivate const double csc2;\r\n\r\n\r\n\r\n\t\t/** Indicator for negated Jacobi amplitude. */\r\n\r\n\t\tprivate bool negate;\r\n\r\n\r\n\r\n\t\t/** Simple constructor.\r\n\r\n\t\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t\t * @param integral provider for complete integral\r\n\r\n\t\t */\r\n\r\n\t\tDouble_Argument_Reduction(const double& phi, const double m, const Double_Function<Double> integral)\r\n\r\n\t\t{\r\n\r\n\t\t\tconst double sin = std::sin(phi);\r\n\r\n\t\t\tconst int    p = static_cast<int>(FastMath.rint(phi / std::numbers::pi);\r\n\r\n\t\t\tcomplete = p == 0 ? 0 : integral.apply(m) * 2 * p;\r\n\r\n\t\t\tnegate = sin < 0 ^ (p & 0x1) == 1;\r\n\r\n\t\t\tcsc2 = 1.0 / (sin * sin);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Argument reduction for an incomplete integral.\r\n\r\n\t * @param <T> type fo the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tprivate static class Field_Argument_Reduction\r\n\r\n\t{\r\n\r\n\t\t/** Complete part. */\r\n\r\n\t\tprivate const T complete;\r\n\r\n\r\n\r\n\t\t/** Squared cosecant of the Jacobi amplitude. */\r\n\r\n\t\tprivate const T csc2;\r\n\r\n\r\n\r\n\t\t/** Indicator for negated Jacobi amplitude. */\r\n\r\n\t\tprivate bool negate;\r\n\r\n\r\n\r\n\t\t/** Simple constructor.\r\n\r\n\t\t * @param phi amplitude (i.e. upper bound of the integral)\r\n\r\n\t\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t\t * @param integral provider for complete integral\r\n\r\n\t\t */\r\n\r\n\t\tField_Argument_Reduction(const T phi, const T m, const Function<T, T> integral)\r\n\r\n\t\t{\r\n\r\n\t\t\tconst T   sin = std::sin(phi);\r\n\r\n\t\t\tconst int p = static_cast<int>(FastMath.rint(phi.get_real() / std::numbers::pi);\r\n\r\n\t\t\tcomplete = p == 0 ? phi.get_field().get_zero() : integral.apply(m).multiply(2 * p);\r\n\r\n\t\t\tnegate = sin.get_real() < 0 ^ (p & 0x1) == 1;\r\n\r\n\t\t\tcsc2 = sin.multiply(sin).reciprocal();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Integrand for elliptic integrals of the first kind.\r\n\r\n\t * @param <T> type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tprivate static class First : Calculus_Field_Univariate_Function<T>\r\n\r\n\t{\r\n\r\n\t\t/** Parameter. */\r\n\r\n\t\tprivate const T m;\r\n\r\n\r\n\r\n\t\t/** Simple constructor.\r\n\r\n\t\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t\t */\r\n\r\n\t\tFirst(const T m)\r\n\r\n\t\t{\r\n\r\n\t\t\tthis.m = m;\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\t/** {@inherit_doc} */\r\n\r\n\t //override\r\n\r\n\t\t\tpublic T value(const T theta)\r\n\r\n\t\t{\r\n\r\n\t\t\tconst T sin = theta.sin();\r\n\r\n\t\t\tconst T sin2 = sin.multiply(sin);\r\n\r\n\t\t\treturn sin2.multiply(m).negate().add(1).sqrt().reciprocal();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Integrand for elliptic integrals of the second kind.\r\n\r\n\t * @param <T> type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tprivate static class Second : Calculus_Field_Univariate_Function<T>\r\n\r\n\t{\r\n\r\n\t\t/** Parameter. */\r\n\r\n\t\tprivate const T m;\r\n\r\n\r\n\r\n\t\t/** Simple constructor.\r\n\r\n\t\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t\t */\r\n\r\n\t\tSecond(const T m)\r\n\r\n\t\t{\r\n\r\n\t\t\tthis.m = m;\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\t/** {@inherit_doc} */\r\n\r\n\t //override\r\n\r\n\t\t\tpublic T value(const T theta)\r\n\r\n\t\t{\r\n\r\n\t\t\tconst T sin = theta.sin();\r\n\r\n\t\t\tconst T sin2 = sin.multiply(sin);\r\n\r\n\t\t\treturn sin2.multiply(m).negate().add(1).sqrt();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\t/** Integrand for elliptic integrals of the third kind.\r\n\r\n\t * @param <T> type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\tprivate static class Third : Calculus_Field_Univariate_Function<T>\r\n\r\n\t{\r\n\r\n\t\t/** Elliptic characteristic. */\r\n\r\n\t\tprivate const T n;\r\n\r\n\r\n\r\n\t\t/** Parameter. */\r\n\r\n\t\tprivate const T m;\r\n\r\n\r\n\r\n\t\t/** Simple constructor.\r\n\r\n\t\t * @param n elliptic characteristic\r\n\r\n\t\t * @param m parameter (m=k\xc2\xb2 where k is the elliptic modulus)\r\n\r\n\t\t */\r\n\r\n\t\tThird(const T n, const T m)\r\n\r\n\t\t{\r\n\r\n\t\t\tthis.n = n;\r\n\r\n\t\t\tthis.m = m;\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\t/** {@inherit_doc} */\r\n\r\n\t //override\r\n\r\n\t\t\tpublic T value(const T theta)\r\n\r\n\t\t{\r\n\r\n\t\t\tconst T sin = theta.sin();\r\n\r\n\t\t\tconst T sin2 = sin.multiply(sin);\r\n\r\n\t\t\tconst T d1 = sin2.multiply(m).negate().add(1).sqrt();\r\n\r\n\t\t\tconst T da = sin2.multiply(n).negate().add(1);\r\n\r\n\t\t\treturn d1.multiply(da).reciprocal();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n