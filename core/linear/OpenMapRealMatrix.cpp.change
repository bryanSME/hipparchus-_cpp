/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.linear;\r\n\r\n#include "MatrixUtils.h"\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Open_Int_To_Double_Hash_Map;\r\n\r\n#include "AbstractRealMatrix.h"\r\n\r\n#include "SparseRealMatrix.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * Sparse matrix implementation based on an open addressed map.\r\n\r\n *\r\n\r\n * <p>\r\n\r\n *  Caveat: This implementation assumes that, for any {@code x}, *  the equality {@code x * 0d == 0d} holds. But it is is not true for\r\n\r\n *  {@code NaN}. Moreover, zero entries will lose their sign.\r\n\r\n *  Some operations (that involve {@code NaN} and/or infinities) may\r\n\r\n *  thus give incorrect results.\r\n\r\n * </p>\r\n\r\n */\r\n\r\nclass Open_Map_Real_Matrix : public Abstract_Real_Matrix, public Sparse_Real_Matrix \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Number of rows of the matrix. */\r\n\r\n    const int my_rows;\r\n\r\n    /** Number of columns of the matrix. */\r\n\r\n    const int my_columns;\r\n\r\n    /** Storage for (sparse) matrix elements. */\r\n\r\n    const Open_Int_To_Double_Hash_Map my_entries;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the key to access a matrix element\r\n\r\n     * @param row row index of the matrix element\r\n\r\n     * @param column column index of the matrix element\r\n\r\n     * @return key within the map to access the matrix element\r\n\r\n     */\r\n\r\n    int compute_key(const int& row, const int& column) const\r\n\r\n    {\r\n\r\n        return row * my_columns + column;\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Build a sparse matrix with the supplied row and column dimensions.\r\n\r\n     *\r\n\r\n     * @param row_dimension Number of rows of the matrix.\r\n\r\n     * @param column_dimension Number of columns of the matrix.\r\n\r\n     * @ if row or column dimension is not\r\n\r\n     * positive.\r\n\r\n     * @ if the total number of entries of the\r\n\r\n     * matrix is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    Open_Map_Real_Matrix(const int& row_dimension, const int& column_dimension)\r\n\r\n        : my_rows{ row_dimension }, my_columns{ column_dimension }\r\n\r\n    {\r\n\r\n        super(row_dimension, column_dimension);\r\n\r\n        if (static_cast<long>(row_dimension) * static_cast<long>(column_dimension) >= Integer.MAX_VALUE)\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, static_cast<long>(row_dimension) * static_cast<long(column_dimension), Integer.MAX_VALUE);\r\n\r\n        }\r\n\r\n        this.entries = Open_Int_To_Double_Hash_Map(0.0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a matrix by copying another one.\r\n\r\n     *\r\n\r\n     * @param matrix matrix to copy.\r\n\r\n     */\r\n\r\n    Open_Map_Real_Matrix(Open_Map_Real_Matrix matrix) : my_rows{ matrix.rows }, my_columns{ matrix.columns }\r\n\r\n    {\r\n\r\n        my_entries = Open_Int_To_Double_Hash_Map(matrix.entries);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Open_Map_Real_Matrix copy() \r\n\r\n    {\r\n\r\n        return Open_Map_Real_Matrix(this);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if the total number of entries of the\r\n\r\n     * matrix is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Open_Map_Real_Matrix create_matrix(const int& row_dimension, const int& column_dimension)\r\n\r\n    {\r\n\r\n        return Open_Map_Real_Matrix(row_dimension, column_dimension);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int get_column_dimension() const\r\n\r\n    {\r\n\r\n        return my_columns;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the sum of this matrix and {@code m}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be added.\r\n\r\n     * @return {@code this} + {@code m}.\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this}.\r\n\r\n     */\r\n\r\n    Open_Map_Real_Matrix add(const Open_Map_Real_Matrix& m)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_addition_compatible(this, m);\r\n\r\n\r\n\r\n        const Open_Map_Real_Matrix out = Open_Map_Real_Matrix(this);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = m.entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const int row = iterator.key() / columns;\r\n\r\n            const int col = iterator.key() - row * columns;\r\n\r\n            out.set_entry(row, col, get_entry(row, col) + iterator.value());\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Open_Map_Real_Matrix subtract(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        if (m instanceof Open_Map_Real_Matrix) \r\n\r\n        {\r\n\r\n            return subtract((Open_Map_Real_Matrix) m);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            return static_cast<Open_Map_Real_Matrix>(super.subtract(m));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtract {@code m} from this matrix.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be subtracted.\r\n\r\n     * @return {@code this} - {@code m}.\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this}.\r\n\r\n     */\r\n\r\n    Open_Map_Real_Matrix subtract(const Open_Map_Real_Matrix& m)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_addition_compatible(this, m);\r\n\r\n\r\n\r\n        const Open_Map_Real_Matrix out = Open_Map_Real_Matrix(this);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = m.entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const int row = iterator.key() / columns;\r\n\r\n            const int col = iterator.key() - row * columns;\r\n\r\n            out.set_entry(row, col, get_entry(row, col) - iterator.value());\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if {@code m} is an\r\n\r\n     * {@code Open_Map_Real_Matrix}, and the total number of entries of the product\r\n\r\n     * is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Real_Matrix multiply(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_multiplication_compatible(this, m);\r\n\r\n\r\n\r\n        const int out_cols = m.get_column_dimension();\r\n\r\n        const Real_Matrix out = m.create_matrix(rows, out_cols);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const double value = iterator.value();\r\n\r\n            const int& key      = iterator.key();\r\n\r\n            const int i        = key / my_columns;\r\n\r\n            const int& k        = key % my_columns;\r\n\r\n            for (int j{}; j < out_cols; ++j) \r\n\r\n            {\r\n\r\n                out.add_to_entry(i, j, value * m.get_entry(k, j));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if {@code m} is an\r\n\r\n     * {@code Open_Map_Real_Matrix}, and the total number of entries of the product\r\n\r\n     * is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Real_Matrix multiply_transposed(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_same_column_dimension(this, m);\r\n\r\n\r\n\r\n        const int out_cols = m.get_row_dimension();\r\n\r\n        const Real_Matrix out = m.create_matrix(rows, out_cols);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const double value = iterator.value();\r\n\r\n            const int& key      = iterator.key();\r\n\r\n            const int i        = key / my_columns;\r\n\r\n            const int& k        = key % my_columns;\r\n\r\n            for (int j{}; j < out_cols; ++j) \r\n\r\n            {\r\n\r\n                out.add_to_entry(i, j, value * m.get_entry(j, k));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if {@code m} is an\r\n\r\n     * {@code Open_Map_Real_Matrix}, and the total number of entries of the product\r\n\r\n     * is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Real_Matrix transpose_multiply(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_same_row_dimension(this, m);\r\n\r\n\r\n\r\n        const int out_cols = m.get_column_dimension();\r\n\r\n        const Real_Matrix out = m.create_matrix(my_columns, out_cols);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const double value = iterator.value();\r\n\r\n            const int& key      = iterator.key();\r\n\r\n            const int& k        = key / my_columns;\r\n\r\n            const int i        = key % my_columns;\r\n\r\n            for (int j{}; j < out_cols; ++j) \r\n\r\n            {\r\n\r\n                out.add_to_entry(i, j, value * m.get_entry(k, j));\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Postmultiply this matrix by {@code m}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to postmultiply by.\r\n\r\n     * @return {@code this} * {@code m}.\r\n\r\n     * @ if the number of rows of {@code m}\r\n\r\n     * differ from the number of columns of {@code this} matrix.\r\n\r\n     * @ if the total number of entries of the\r\n\r\n     * product is larger than {@code Integer.MAX_VALUE}.\r\n\r\n     */\r\n\r\n    Open_Map_Real_Matrix multiply(const Open_Map_Real_Matrix& m)\r\n\r\n    {\r\n\r\n        // Safety check.\r\n\r\n        Matrix_Utils.check_multiplication_compatible(this, m);\r\n\r\n\r\n\r\n        const int out_cols = m.get_column_dimension();\r\n\r\n        Open_Map_Real_Matrix out = Open_Map_Real_Matrix(my_rows, out_cols);\r\n\r\n        for (Open_Int_To_Double_Hash_Map.Iterator iterator = entries.iterator(); iterator.has_next();) \r\n\r\n        {\r\n\r\n            iterator.advance();\r\n\r\n            const double value = iterator.value();\r\n\r\n            const int& key      = iterator.key();\r\n\r\n            const int i        = key / my_columns;\r\n\r\n            const int& k        = key % my_columns;\r\n\r\n            for (int j{}; j < out_cols; ++j) \r\n\r\n            {\r\n\r\n                const int right_key = m.compute_key(k, j);\r\n\r\n                if (m.entries.contains_key(right_key)) \r\n\r\n                {\r\n\r\n                    const int out_key = out.compute_key(i, j);\r\n\r\n                    const double out_value = out.entries.get(out_key) + value * m.entries.get(right_key);\r\n\r\n                    if (out_value == 0.0) \r\n\r\n                    {\r\n\r\n                        out.entries.remove(out_key);\r\n\r\n                    }\r\n\r\n                    else \r\n\r\n                    {\r\n\r\n                        out.entries.put(out_key, out_value);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    double get_entry(const int& row, const int& column)  \r\n\r\n    {\r\n\r\n        Matrix_Utils.check_row_index(this, row);\r\n\r\n        Matrix_Utils.check_column_index(this, column);\r\n\r\n        return entries.get(compute_key(row, column));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int get_row_dimension() const\r\n\r\n    {\r\n\r\n        return my_rows;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    void set_entry(const int& row, const int& column, const double& value)     \r\n\r\n    {\r\n\r\n        Matrix_Utils.check_row_index(this, row);\r\n\r\n        Matrix_Utils.check_column_index(this, column);\r\n\r\n        if (value == 0.0) \r\n\r\n        {\r\n\r\n            entries.remove(compute_key(row, column));\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            entries.put(compute_key(row, column), value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    void add_to_entry(const int& row, const int& column, const double& increment)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_row_index(this, row);\r\n\r\n        Matrix_Utils.check_column_index(this, column);\r\n\r\n        const int& key = compute_key(row, column);\r\n\r\n        const double value = my_entries.get(key) + increment;\r\n\r\n        if (value == 0.0) \r\n\r\n        {\r\n\r\n            my_entries.remove(key);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            my_entries.put(key, value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    void multiply_entry(const int& row, const int& column, const double& factor)     \r\n\r\n    {\r\n\r\n        Matrix_Utils.check_row_index(this, row);\r\n\r\n        Matrix_Utils.check_column_index(this, column);\r\n\r\n        const int& key = compute_key(row, column);\r\n\r\n        const double value = my_entries.get(key) * factor;\r\n\r\n        if (value == 0.0) \r\n\r\n        {\r\n\r\n            my_entries.remove(key);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            my_entries.put(key, value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n