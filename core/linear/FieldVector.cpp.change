/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Field_Element;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n\r\n\r\n/**\r\n\r\n * Interface defining a field-valued vector with basic algebraic operations.\r\n\r\n * <p>\r\n\r\n * vector element indexing is 0-based -- e.g., <code>get_entry(0)</code>\r\n\r\n * returns the first element of the vector.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * The various <code>map_xxx</code> and <code>map_xxx_to_self</code> methods operate\r\n\r\n * on vectors element-wise, i.e. they perform the same operation (adding a scalar, * applying a function ...) on each element in turn. The <code>map_xxx</code>\r\n\r\n * versions create a vector to hold the result and do not change the instance.\r\n\r\n * The <code>map_xxx_to_self</code> versions use the instance itself to store the\r\n\r\n * results, so the instance is changed by these methods. In both cases, the result\r\n\r\n * vector is returned by the methods, this allows to use the <i>fluent API</i>\r\n\r\n * style, like this:\r\n\r\n * </p>\r\n\r\n * <pre>\r\n\r\n *   Real_Vector result = v.map_add_to_self(3.0).map_tan_to_self().map_square_to_self();\r\n\r\n * </pre>\r\n\r\n * <p>\r\n\r\n * Note that as almost all operations on {@link Field_Element} throw {@link\r\n\r\n * Null_Argument_Exception} when operating on a null element, it is the responsibility\r\n\r\n * of <code>Field_Vector</code> implementations to make sure no null elements\r\n\r\n * are inserted into the vector. This must be done in all constructors and\r\n\r\n * all setters.\r\n\r\n * <p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\nclass Field_Vector<T extends Field_Element<T>>  \r\n\r\n{\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the type of field elements of the vector.\r\n\r\n     * @return type of field elements of the vector\r\n\r\n     */\r\n\r\n    Field<T> get_field();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a (deep) copy of this.\r\n\r\n     * @return vector copy\r\n\r\n     */\r\n\r\n    Field_Vector<T> copy();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the sum of {@code this} and {@code v}.\r\n\r\n     * @param v vector to be added\r\n\r\n     * @return {@code this + v}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     */\r\n\r\n    Field_Vector<T> add(Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute {@code this} minus {@code v}.\r\n\r\n     * @param v vector to be subtracted\r\n\r\n     * @return {@code this - v}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     */\r\n\r\n    Field_Vector<T> subtract(Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map an addition operation to each entry.\r\n\r\n     * @param d value to be added to each entry\r\n\r\n     * @return {@code this + d}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_add(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map an addition operation to each entry.\r\n\r\n     * <p>The instance <strong>is</strong> changed by this method.</p>\r\n\r\n     * @param d value to be added to each entry\r\n\r\n     * @return for convenience, return {@code this}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_add_to_self(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a subtraction operation to each entry.\r\n\r\n     * @param d value to be subtracted to each entry\r\n\r\n     * @return {@code this - d}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_subtract(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a subtraction operation to each entry.\r\n\r\n     * <p>The instance <strong>is</strong> changed by this method.</p>\r\n\r\n     * @param d value to be subtracted to each entry\r\n\r\n     * @return for convenience, return {@code this}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_subtract_to_self(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a multiplication operation to each entry.\r\n\r\n     * @param d value to multiply all entries by\r\n\r\n     * @return {@code this * d}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_multiply(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a multiplication operation to each entry.\r\n\r\n     * <p>The instance <strong>is</strong> changed by this method.</p>\r\n\r\n     * @param d value to multiply all entries by\r\n\r\n     * @return for convenience, return {@code this}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_multiply_to_self(T d) Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a division operation to each entry.\r\n\r\n     * @param d value to divide all entries by\r\n\r\n     * @return {@code this / d}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     * @Math_Runtime_Exception if {@code d} is zero.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_divide(T d)\r\n\r\n        Null_Argument_Exception, Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map a division operation to each entry.\r\n\r\n     * <p>The instance <strong>is</strong> changed by this method.</p>\r\n\r\n     * @param d value to divide all entries by\r\n\r\n     * @return for convenience, return {@code this}\r\n\r\n     * @Null_Argument_Exception if {@code d} is {@code null}.\r\n\r\n     * @Math_Runtime_Exception if {@code d} is zero.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_divide_to_self(T d)\r\n\r\n        Null_Argument_Exception, Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map the 1/x function to each entry.\r\n\r\n     * @return a vector containing the result of applying the function to each entry.\r\n\r\n     * @Math_Runtime_Exception if one of the entries is zero.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_inv() Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Map the 1/x function to each entry.\r\n\r\n     * <p>The instance <strong>is</strong> changed by this method.</p>\r\n\r\n     * @return for convenience, return {@code this}\r\n\r\n     * @Math_Runtime_Exception if one of the entries is zero.\r\n\r\n     */\r\n\r\n    Field_Vector<T> map_inv_to_self() Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Element-by-element multiplication.\r\n\r\n     * @param v vector by which instance elements must be multiplied\r\n\r\n     * @return a vector containing {@code this[i] * v[i]} for all {@code i}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     */\r\n\r\n    Field_Vector<T> ebe_multiply(Field_Vector<T> v)\r\n\r\n        ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Element-by-element division.\r\n\r\n     * @param v vector by which instance elements must be divided\r\n\r\n     * @return a vector containing {@code this[i] / v[i]} for all {@code i}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     * @Math_Runtime_Exception if one entry of {@code v} is zero.\r\n\r\n     */\r\n\r\n    Field_Vector<T> ebe_divide(Field_Vector<T> v)\r\n\r\n        , Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the dot product.\r\n\r\n     * @param v vector with which dot product should be computed\r\n\r\n     * @return the scalar dot product of {@code this} and {@code v}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     */\r\n\r\n    T dot_product(Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find the orthogonal projection of this vector onto another vector.\r\n\r\n     * @param v vector onto which {@code this} must be projected\r\n\r\n     * @return projection of {@code this} onto {@code v}\r\n\r\n     * @ if {@code v} is not the same size as {@code this}\r\n\r\n     * @Math_Runtime_Exception if {@code v} is the null vector.\r\n\r\n     */\r\n\r\n    Field_Vector<T> projection(Field_Vector<T> v)\r\n\r\n        , Math_Runtime_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the outer product.\r\n\r\n     * @param v vector with which outer product should be computed\r\n\r\n     * @return the matrix outer product between instance and v\r\n\r\n     */\r\n\r\n    Field_Matrix<T> outer_product(Field_Vector<T> v);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the entry in the specified index.\r\n\r\n     *\r\n\r\n     * @param index Index location of entry to be fetched.\r\n\r\n     * @return the vector entry at {@code index}.\r\n\r\n     * @ if the index is not valid.\r\n\r\n     * @see #set_entry(int, Field_Element)\r\n\r\n     */\r\n\r\n    T get_entry(const int& index) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set a single element.\r\n\r\n     * @param index element index.\r\n\r\n     * @param value value for the element.\r\n\r\n     * @ if the index is not valid.\r\n\r\n     * @see #get_entrystatic_cast<int>(\r\n\r\n     */\r\n\r\n    void set_entry(const int& index, T value) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the size of the vector.\r\n\r\n     * @return size\r\n\r\n     */\r\n\r\n    int get_dimension();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a vector by appending a vector to this vector.\r\n\r\n     * @param v vector to append to this one.\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector<T> append(Field_Vector<T> v);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a vector by appending a T to this vector.\r\n\r\n     * @param d T to append.\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector<T> append(T d);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a subvector from consecutive elements.\r\n\r\n     * @param index index of first element.\r\n\r\n     * @param n number of elements to be retrieved.\r\n\r\n     * @return a vector containing n elements.\r\n\r\n     * @ if the index is not valid.\r\n\r\n     * @ if the number of elements if not positive.\r\n\r\n     */\r\n\r\n    Field_Vector<T> get_sub_vector(const int& index, int n)\r\n\r\n        ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set a set of consecutive elements.\r\n\r\n     * @param index index of first element to be set.\r\n\r\n     * @param v vector containing the values to set.\r\n\r\n     * @ if the index is not valid.\r\n\r\n     */\r\n\r\n    void set_sub_vector(const int& index, Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set all elements to a single value.\r\n\r\n     * @param value single value to set for all elements\r\n\r\n     */\r\n\r\n    void set(T value);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Convert the vector to a T array.\r\n\r\n     * <p>The array is independent from vector data, it's elements\r\n\r\n     * are copied.</p>\r\n\r\n     * @return array containing a copy of vector elements\r\n\r\n     */\r\n\r\n    std::vector<T> to_array();\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n