/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import org.hipparchus.complex.std::complex<double>;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n#include "MatrixUtils.h"\r\n\r\n/**\r\n\r\n * Calculates the eigen decomposition of a real matrix.\r\n\r\n * <p>\r\n\r\n * The eigen decomposition of matrix A is a set of two matrices:\r\n\r\n * V and D such that A = V &times; D &times; V<sup>T</sup>.\r\n\r\n * A, V and D are all m &times; m matrices.\r\n\r\n * <p>\r\n\r\n * This class is similar in spirit to the {@code Eigenvalue_Decomposition}\r\n\r\n * class from the <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a>\r\n\r\n * library, with the following changes:\r\n\r\n * <ul>\r\n\r\n *   <li>a {@link #get_v_t() get_vt} method has been added,</li>\r\n\r\n *   <li>two {@link #get_real_eigenvaluestatic_cast<int>( get_real_eigenvalue} and\r\n\r\n *       {@link #get_imag_eigenvaluestatic_cast<int>( get_imag_eigenvalue} methods to pick up a\r\n\r\n *       single eigenvalue have been added,</li>\r\n\r\n *   <li>a {@link #get_eigenvectorstatic_cast<int>( get_eigenvector} method to pick up a\r\n\r\n *       single eigenvector has been added,</li>\r\n\r\n *   <li>a {@link #get_determinant() get_determinant} method has been added.</li>\r\n\r\n *   <li>a {@link #get_solver() get_solver} method has been added.</li>\r\n\r\n * </ul>\r\n\r\n * <p>\r\n\r\n * As of 3.1, this class supports general real matrices (both symmetric and non-symmetric):\r\n\r\n * <p>\r\n\r\n * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is diagonal\r\n\r\n * and the eigenvector matrix V is orthogonal, i.e.\r\n\r\n * {@code A = V.multiply(D.multiply(V.transpose()))} and\r\n\r\n * {@code V.multiply(V.transpose())} equals the identity matrix.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * If A is not symmetric, then the eigenvalue matrix D is block diagonal with the real\r\n\r\n * eigenvalues in 1-by-1 blocks and any complex eigenvalues, lambda + i*mu, in 2-by-2\r\n\r\n * blocks:\r\n\r\n * <pre>\r\n\r\n *    [lambda, mu    ]\r\n\r\n *    [   -mu, lambda]\r\n\r\n * </pre>\r\n\r\n * The columns of V represent the eigenvectors in the sense that {@code A*V = V*D}, * i.e. A.multiply(V) equals V.multiply(D).\r\n\r\n * The matrix V may be badly conditioned, or even singular, so the validity of the\r\n\r\n * equation {@code A = V*D*inverse(V)} depends upon the condition of V.\r\n\r\n * <p>\r\n\r\n * This implementation is based on the paper by A. Drubrulle, R.S. Martin and\r\n\r\n * J.H. Wilkinson "The Implicit QL Algorithm" in Wilksinson and Reinsch (1971)\r\n\r\n * Handbook for automatic computation, vol. 2, Linear algebra, Springer-Verlag, * New-York.\r\n\r\n *\r\n\r\n * @see <a href="http://mathworld.wolfram.com/Eigen_Decomposition.html">MathWorld</a>\r\n\r\n * @see <a href="http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Wikipedia</a>\r\n\r\n */\r\n\r\nclass Eigen_Decomposition \r\n\r\n{\r\n\r\n    /** Default epsilon value to use for internal epsilon **/\r\n\r\n    private static const double DEFAULT_EPSILON = 1e-12;\r\n\r\n    /** Maximum number of iterations accepted in the implicit QL transformation */\r\n\r\n    private static const std::byte MAX_ITER = 30;\r\n\r\n    /** Internally used epsilon criteria. */\r\n\r\n    private const double epsilon;\r\n\r\n    /** Main diagonal of the tridiagonal matrix. */\r\n\r\n    private std::vector<double> main;\r\n\r\n    /** Secondary diagonal of the tridiagonal matrix. */\r\n\r\n    private std::vector<double> secondary;\r\n\r\n    /**\r\n\r\n     * Transformer to tridiagonal (may be null if matrix is already\r\n\r\n     * tridiagonal).\r\n\r\n     */\r\n\r\n    private Tri_Diagonal_Transformer transformer;\r\n\r\n    /** Real part of the real_eigenvalues. */\r\n\r\n    private std::vector<double> real_eigenvalues;\r\n\r\n    /** Imaginary part of the real_eigenvalues. */\r\n\r\n    private std::vector<double> imag_eigenvalues;\r\n\r\n    /** Eigenvectors. */\r\n\r\n    private Array_Real_Vector[] eigenvectors;\r\n\r\n    /** Cached value of V. */\r\n\r\n    private Real_Matrix cached_v;\r\n\r\n    /** Cached value of D. */\r\n\r\n    private Real_Matrix cached_d;\r\n\r\n    /** Cached value of Vt. */\r\n\r\n    private Real_Matrix cached_vt;\r\n\r\n    /** Whether the matrix is symmetric. */\r\n\r\n    private const bool is_symmetric;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the eigen decomposition of the given real matrix.\r\n\r\n     * <p>\r\n\r\n     * Supports decomposition of a general matrix since 3.1.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to decompose.\r\n\r\n     * @Math_Illegal_State_Exception if the algorithm fails to converge.\r\n\r\n     * @Math_Runtime_Exception if the decomposition of a general matrix\r\n\r\n     * results in a matrix with zero norm\r\n\r\n     */\r\n\r\n    public Eigen_Decomposition(const Real_Matrix matrix) \r\n\r\n    {\r\n\r\n        this(matrix, DEFAULT_EPSILON);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the eigen decomposition of the given real matrix.\r\n\r\n     * <p>\r\n\r\n     * Supports decomposition of a general matrix since 3.1.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to decompose.\r\n\r\n     * @param epsilon Epsilon used for internal tests (e.g. is singular, eigenvalue ratio, etc.)\r\n\r\n     * @Math_Illegal_State_Exception if the algorithm fails to converge.\r\n\r\n     * @Math_Runtime_Exception if the decomposition of a general matrix\r\n\r\n     * results in a matrix with zero norm\r\n\r\n     */\r\n\r\n    public Eigen_Decomposition(const Real_Matrix matrix, double epsilon)\r\n\r\n        Math_Runtime_Exception \r\n\r\n        {\r\n\r\n        this.epsilon = epsilon;\r\n\r\n        const double sym_tol = 10 * matrix.get_row_dimension() * matrix.get_column_dimension() * Precision.EPSILON;\r\n\r\n        is_symmetric = Matrix_Utils.is_symmetric(matrix, sym_tol);\r\n\r\n        if (is_symmetric) \r\n\r\n        {\r\n\r\n            transform_to_tridiagonal(matrix);\r\n\r\n            find_eigen_vectors(transformer.get_q().get_data());\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const Schur_Transformer t = transform_to_schur(matrix);\r\n\r\n            find_eigen_vectors_from_schur(t);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the eigen decomposition of the symmetric tridiagonal\r\n\r\n     * matrix.  The Householder matrix is assumed to be the identity matrix.\r\n\r\n     *\r\n\r\n     * @param main Main diagonal of the symmetric tridiagonal form.\r\n\r\n     * @param secondary Secondary of the tridiagonal form.\r\n\r\n     * @Math_Illegal_State_Exception if the algorithm fails to converge.\r\n\r\n     */\r\n\r\n    public Eigen_Decomposition(const std::vector<double> main, const std::vector<double> secondary) \r\n\r\n    {\r\n\r\n        this(main, secondary, DEFAULT_EPSILON);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the eigen decomposition of the symmetric tridiagonal\r\n\r\n     * matrix.  The Householder matrix is assumed to be the identity matrix.\r\n\r\n     *\r\n\r\n     * @param main Main diagonal of the symmetric tridiagonal form.\r\n\r\n     * @param secondary Secondary of the tridiagonal form.\r\n\r\n     * @param epsilon Epsilon used for internal tests (e.g. is singular, eigenvalue ratio, etc.)\r\n\r\n     * @Math_Illegal_State_Exception if the algorithm fails to converge.\r\n\r\n     */\r\n\r\n    public Eigen_Decomposition(const std::vector<double> main, const std::vector<double> secondary, double epsilon) \r\n\r\n    {\r\n\r\n        this.epsilon = epsilon;\r\n\r\n        is_symmetric = true;\r\n\r\n        this.main      = main.clone();\r\n\r\n        this.secondary = secondary.clone();\r\n\r\n        transformer    = null;\r\n\r\n        const int size = main.size();\r\n\r\n        const std::vector<std::vector<double>> z = std::vector<double>(size][size];\r\n\r\n        for (int i{}; i < size; i++) \r\n\r\n        {\r\n\r\n            z[i][i] = 1.0;\r\n\r\n        }\r\n\r\n        find_eigen_vectors(z);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the matrix V of the decomposition.\r\n\r\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\r\n\r\n     * The columns of V are the eigenvectors of the original matrix.\r\n\r\n     * No assumption is made about the orientation of the system axes formed\r\n\r\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\r\n\r\n     * or right-handed system).\r\n\r\n     *\r\n\r\n     * @return the V matrix.\r\n\r\n     */\r\n\r\n    public Real_Matrix get_v() \r\n\r\n    {\r\n\r\n\r\n\r\n        if (cached_v == null) \r\n\r\n        {\r\n\r\n            const int m = eigenvectors.size();\r\n\r\n            cached_v = Matrix_Utils.create_real_matrix(m, m);\r\n\r\n            for (int k{}; k < m; ++k) \r\n\r\n            {\r\n\r\n                cached_v.set_column_vector(k, eigenvectors[k]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // return the cached matrix\r\n\r\n        return cached_v;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the block diagonal matrix D of the decomposition.\r\n\r\n     * D is a block diagonal matrix.\r\n\r\n     * Real eigenvalues are on the diagonal while complex values are on\r\n\r\n     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.\r\n\r\n     *\r\n\r\n     * @return the D matrix.\r\n\r\n     *\r\n\r\n     * @see #get_real_eigenvalues()\r\n\r\n     * @see #get_imag_eigenvalues()\r\n\r\n     */\r\n\r\n    public Real_Matrix get_d() \r\n\r\n    {\r\n\r\n\r\n\r\n        if (cached_d == null) \r\n\r\n        {\r\n\r\n            // cache the matrix for subsequent calls\r\n\r\n            cached_d = Matrix_Utils.create_real_matrix(real_eigenvalues.size(), real_eigenvalues.size());\r\n\r\n            for (int i{}; i < real_eigenvalues.size(); ++i) \r\n\r\n            {\r\n\r\n                cached_d.set_entry(i, i, real_eigenvalues[i]);\r\n\r\n            }\r\n\r\n\r\n\r\n            for (int i{}; i < imag_eigenvalues.size(); i++) \r\n\r\n            {\r\n\r\n                if (Precision.compare_to(imag_eigenvalues[i], 0.0, epsilon) > 0) \r\n\r\n                {\r\n\r\n                    cached_d.set_entry(i, i+1, imag_eigenvalues[i]);\r\n\r\n                }\r\n\r\nelse if (Precision.compare_to(imag_eigenvalues[i], 0.0, epsilon) < 0) \r\n\r\n                {\r\n\r\n                    cached_d.set_entry(i, i-1, imag_eigenvalues[i]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_d;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get's the value for epsilon which is used for internal tests (e.g. is singular, eigenvalue ratio, etc.)\r\n\r\n     *\r\n\r\n     * @return the epsilon value.\r\n\r\n     */\r\n\r\n    public double get_epsilon() { return epsilon; }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the transpose of the matrix V of the decomposition.\r\n\r\n     * V is an orthogonal matrix, i.e. its transpose is also its inverse.\r\n\r\n     * The columns of V are the eigenvectors of the original matrix.\r\n\r\n     * No assumption is made about the orientation of the system axes formed\r\n\r\n     * by the columns of V (e.g. in a 3-dimension space, V can form a left-\r\n\r\n     * or right-handed system).\r\n\r\n     *\r\n\r\n     * @return the transpose of the V matrix.\r\n\r\n     */\r\n\r\n    public Real_Matrix get_v_t() \r\n\r\n    {\r\n\r\n\r\n\r\n        if (cached_vt == null) \r\n\r\n        {\r\n\r\n            const int m = eigenvectors.size();\r\n\r\n            cached_vt = Matrix_Utils.create_real_matrix(m, m);\r\n\r\n            for (int k{}; k < m; ++k) \r\n\r\n            {\r\n\r\n                cached_vt.set_row_vector(k, eigenvectors[k]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // return the cached matrix\r\n\r\n        return cached_vt;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns whether the calculated eigen values are complex or real.\r\n\r\n     * <p>The method performs a zero check for each element of the\r\n\r\n     * {@link #get_imag_eigenvalues()} array and returns {@code true} if any\r\n\r\n     * element is not equal to zero.\r\n\r\n     *\r\n\r\n     * @return {@code true} if the eigen values are complex, {@code false} otherwise\r\n\r\n     */\r\n\r\n    public bool has_complex_eigenvalues() \r\n\r\n    {\r\n\r\n        for (int i{}; i < imag_eigenvalues.size(); i++) \r\n\r\n        {\r\n\r\n            if (!Precision.equals(imag_eigenvalues[i], 0.0, epsilon)) \r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets a copy of the real parts of the eigenvalues of the original matrix.\r\n\r\n     *\r\n\r\n     * @return a copy of the real parts of the eigenvalues of the original matrix.\r\n\r\n     *\r\n\r\n     * @see #get_d()\r\n\r\n     * @see #get_real_eigenvaluestatic_cast<int>(\r\n\r\n     * @see #get_imag_eigenvalues()\r\n\r\n     */\r\n\r\n    public std::vector<double> get_real_eigenvalues() \r\n\r\n    {\r\n\r\n        return real_eigenvalues.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the real part of the i<sup>th</sup> eigenvalue of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @param i index of the eigenvalue (counting from 0)\r\n\r\n     * @return real part of the i<sup>th</sup> eigenvalue of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @see #get_d()\r\n\r\n     * @see #get_real_eigenvalues()\r\n\r\n     * @see #get_imag_eigenvaluestatic_cast<int>(\r\n\r\n     */\r\n\r\n    public double get_real_eigenvalue(const int& i) \r\n\r\n    {\r\n\r\n        return real_eigenvalues[i];\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets a copy of the imaginary parts of the eigenvalues of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @return a copy of the imaginary parts of the eigenvalues of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @see #get_d()\r\n\r\n     * @see #get_imag_eigenvaluestatic_cast<int>(\r\n\r\n     * @see #get_real_eigenvalues()\r\n\r\n     */\r\n\r\n    public std::vector<double> get_imag_eigenvalues() \r\n\r\n    {\r\n\r\n        return imag_eigenvalues.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the imaginary part of the i<sup>th</sup> eigenvalue of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @param i Index of the eigenvalue (counting from 0).\r\n\r\n     * @return the imaginary part of the i<sup>th</sup> eigenvalue of the original\r\n\r\n     * matrix.\r\n\r\n     *\r\n\r\n     * @see #get_d()\r\n\r\n     * @see #get_imag_eigenvalues()\r\n\r\n     * @see #get_real_eigenvaluestatic_cast<int>(\r\n\r\n     */\r\n\r\n    public double get_imag_eigenvalue(const int& i) \r\n\r\n    {\r\n\r\n        return imag_eigenvalues[i];\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.\r\n\r\n     *\r\n\r\n     * @param i Index of the eigenvector (counting from 0).\r\n\r\n     * @return a copy of the i<sup>th</sup> eigenvector of the original matrix.\r\n\r\n     * @see #get_d()\r\n\r\n     */\r\n\r\n    public Real_Vector get_eigenvector(const int& i) \r\n\r\n    {\r\n\r\n        return eigenvectors[i].copy();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the determinant of the matrix.\r\n\r\n     *\r\n\r\n     * @return the determinant of the matrix.\r\n\r\n     */\r\n\r\n    public double get_determinant() \r\n\r\n    {\r\n\r\n        double determinant = 1;\r\n\r\n        for (double lambda : real_eigenvalues) \r\n\r\n        {\r\n\r\n            determinant *= lambda;\r\n\r\n        }\r\n\r\n        return determinant;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the square-root of the matrix.\r\n\r\n     * This implementation assumes that the matrix is symmetric and positive\r\n\r\n     * definite.\r\n\r\n     *\r\n\r\n     * @return the square-root of the matrix.\r\n\r\n     * @Math_Runtime_Exception if the matrix is not\r\n\r\n     * symmetric or not positive definite.\r\n\r\n     */\r\n\r\n    public Real_Matrix get_square_root() \r\n\r\n    {\r\n\r\n        if (!is_symmetric) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.UNSUPPORTED_OPERATION);\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<double> sqrt_eigen_values = std::vector<double>(real_eigenvalues.size()];\r\n\r\n        for (int i{}; i < real_eigenvalues.size(); i++) \r\n\r\n        {\r\n\r\n            const double eigen = real_eigenvalues[i];\r\n\r\n            if (eigen <= 0) \r\n\r\n            {\r\n\r\n                throw Math_Runtime_Exception(Localized_Core_Formats.UNSUPPORTED_OPERATION);\r\n\r\n            }\r\n\r\n            sqrt_eigen_values[i] = std::sqrt(eigen);\r\n\r\n        }\r\n\r\n        const Real_Matrix sqrt_eigen = Matrix_Utils.create_real_diagonal_matrix(sqrt_eigen_values);\r\n\r\n        const Real_Matrix v = get_v();\r\n\r\n        const Real_Matrix vT = get_v_t();\r\n\r\n\r\n\r\n        return v.multiply(sqrt_eigen).multiply(vT);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets a solver for finding the A &times; X = B solution in exact\r\n\r\n     * linear sense.\r\n\r\n     * <p>\r\n\r\n     * sin_ce 3.1, eigen decomposition of a general matrix is supported, * but the {@link Decomposition_Solver} only supports real eigenvalues.\r\n\r\n     *\r\n\r\n     * @return a solver\r\n\r\n     * @Math_Runtime_Exception if the decomposition resulted in\r\n\r\n     * complex eigenvalues\r\n\r\n     */\r\n\r\n    public Decomposition_Solver get_solver() \r\n\r\n    {\r\n\r\n        if (has_complex_eigenvalues()) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.UNSUPPORTED_OPERATION);\r\n\r\n        }\r\n\r\n        return Solver();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Specialized solver. */\r\n\r\n    private class Solver : Decomposition_Solver \r\n\r\n    {\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Solves the linear equation A &times; X = B for symmetric matrices A.\r\n\r\n         * <p>\r\n\r\n         * This method only finds exact linear solutions, i.e. solutions for\r\n\r\n         * which ||A &times; X - B|| is exactly 0.\r\n\r\n         * </p>\r\n\r\n         *\r\n\r\n         * @param b Right-hand side of the equation A &times; X = B.\r\n\r\n         * @return a Vector X that minimizes the two norm of A &times; X - B.\r\n\r\n         *\r\n\r\n         * @ if the matrices dimensions do not match.\r\n\r\n         * @ if the decomposed matrix is singular.\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public Real_Vector solve(const Real_Vector b) \r\n\r\n        {\r\n\r\n            if (!is_non_singular()) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int m = real_eigenvalues.size();\r\n\r\n            if (b.get_dimension() != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_dimension(), m);\r\n\r\n            }\r\n\r\n\r\n\r\n            const std::vector<double> bp = std::vector<double>(m];\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const Array_Real_Vector v = eigenvectors[i];\r\n\r\n                const std::vector<double>& v_data = v.get_data_ref();\r\n\r\n                const double s = v.dot_product(b) / real_eigenvalues[i];\r\n\r\n                for (int j{}; j < m; ++j) \r\n\r\n                {\r\n\r\n                    bp[j] += s * v_data[j];\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return Array_Real_Vector(bp, false);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Real_Matrix solve(Real_Matrix b) \r\n\r\n        {\r\n\r\n\r\n\r\n            if (!is_non_singular()) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int m = real_eigenvalues.size();\r\n\r\n            if (b.get_row_dimension() != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_row_dimension(), m);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int& n_col_b = b.get_column_dimension();\r\n\r\n            const std::vector<std::vector<double>> bp = std::vector<double>(m][n_col_b];\r\n\r\n            const std::vector<double> tmp_col = std::vector<double>(m];\r\n\r\n            for (int k{}; k < n_col_b; ++k) \r\n\r\n            {\r\n\r\n                for (int i{}; i < m; ++i) \r\n\r\n                {\r\n\r\n                    tmp_col[i] = b.get_entry(i, k);\r\n\r\n                    bp[i][k]  = 0;\r\n\r\n                }\r\n\r\n                for (int i{}; i < m; ++i) \r\n\r\n                {\r\n\r\n                    const Array_Real_Vector v = eigenvectors[i];\r\n\r\n                    const std::vector<double>& v_data = v.get_data_ref();\r\n\r\n                    double s = 0;\r\n\r\n                    for (int j{}; j < m; ++j) \r\n\r\n                    {\r\n\r\n                        s += v.get_entry(j) * tmp_col[j];\r\n\r\n                    }\r\n\r\n                    s /= real_eigenvalues[i];\r\n\r\n                    for (int j{}; j < m; ++j) \r\n\r\n                    {\r\n\r\n                        bp[j][k] += s * v_data[j];\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return Array_2D_Row_Real_Matrix(bp, false);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Checks whether the decomposed matrix is non-singular.\r\n\r\n         *\r\n\r\n         * @return true if the decomposed matrix is non-singular.\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public bool is_non_singular() \r\n\r\n        {\r\n\r\n            double largest_eigenvalue_norm = 0.0;\r\n\r\n            // Looping over all values (in case they are not sorted in decreasing\r\n\r\n            // order of their norm).\r\n\r\n            for (int i{}; i < real_eigenvalues.size(); ++i) \r\n\r\n            {\r\n\r\n                largest_eigenvalue_norm = std::max(largest_eigenvalue_norm, eigenvalue_norm(i));\r\n\r\n            }\r\n\r\n            // Corner case: zero matrix, all exactly 0 eigenvalues\r\n\r\n            if (largest_eigenvalue_norm == 0.0) \r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            for (int i{}; i < real_eigenvalues.size(); ++i) \r\n\r\n            {\r\n\r\n                // Looking for eigenvalues that are 0, where we consider anything much much smaller\r\n\r\n                // than the largest eigenvalue to be effectively 0.\r\n\r\n                if (Precision.equals(eigenvalue_norm(i) / largest_eigenvalue_norm, 0, epsilon)) \r\n\r\n                {\r\n\r\n                    return false;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * @param i which eigenvalue to find the norm of\r\n\r\n         * @return the norm of ith (complex) eigenvalue.\r\n\r\n         */\r\n\r\n        private double eigenvalue_norm(const int& i) \r\n\r\n        {\r\n\r\n            const double re = real_eigenvalues[i];\r\n\r\n            const double im = imag_eigenvalues[i];\r\n\r\n            return std::sqrt(re * re + im * im);\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the inverse of the decomposed matrix.\r\n\r\n         *\r\n\r\n         * @return the inverse matrix.\r\n\r\n         * @ if the decomposed matrix is singular.\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public Real_Matrix get_inverse() \r\n\r\n        {\r\n\r\n            if (!is_non_singular()) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int m = real_eigenvalues.size();\r\n\r\n            const std::vector<std::vector<double>> inv_data = std::vector<double>(m][m];\r\n\r\n\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<double> inv_i = inv_data[i];\r\n\r\n                for (int j{}; j < m; ++j) \r\n\r\n                {\r\n\r\n                    double inv_i_j = 0;\r\n\r\n                    for (int k{}; k < m; ++k) \r\n\r\n                    {\r\n\r\n                        const std::vector<double>& vK = eigenvectors[k].get_data_ref();\r\n\r\n                        inv_i_j += vK[i] * vK[j] / real_eigenvalues[k];\r\n\r\n                    }\r\n\r\n                    inv_i[j] = inv_i_j;\r\n\r\n                }\r\n\r\n            }\r\n\r\n            return Matrix_Utils.create_real_matrix(inv_data);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_row_dimension() \r\n\r\n        {\r\n\r\n            return real_eigenvalues.size();\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_column_dimension() \r\n\r\n        {\r\n\r\n            return real_eigenvalues.size();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Transforms the matrix to tridiagonal form.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to transform.\r\n\r\n     */\r\n\r\n    private void transform_to_tridiagonal(const Real_Matrix matrix) \r\n\r\n    {\r\n\r\n        // transform the matrix to tridiagonal\r\n\r\n        transformer = Tri_Diagonal_Transformer(matrix);\r\n\r\n        main = transformer.get_main_diagonal_ref();\r\n\r\n        secondary = transformer.get_secondary_diagonal_ref();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find eigenvalues and eigenvectors (Dubrulle et al., 1971)\r\n\r\n     *\r\n\r\n     * @param householder_matrix Householder matrix of the transformation\r\n\r\n     * to tridiagonal form.\r\n\r\n     */\r\n\r\n    private void find_eigen_vectors(const std::vector<std::vector<double>> householder_matrix) \r\n\r\n    {\r\n\r\n        const std::vector<std::vector<double>>z = householder_matrix.clone();\r\n\r\n        const int n = main.size();\r\n\r\n        real_eigenvalues = std::vector<double>(n];\r\n\r\n        imag_eigenvalues = std::vector<double>(n];\r\n\r\n        const std::vector<double> e = std::vector<double>(n];\r\n\r\n        for (int i{}; i < n - 1; i++) \r\n\r\n        {\r\n\r\n            real_eigenvalues[i] = main[i];\r\n\r\n            e[i] = secondary[i];\r\n\r\n        }\r\n\r\n        real_eigenvalues[n - 1] = main[n - 1];\r\n\r\n        e[n - 1] = 0;\r\n\r\n\r\n\r\n        // Determine the largest main and secondary value in absolute term.\r\n\r\n        double max_absolute_value = 0;\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            if (std::abs(real_eigenvalues[i]) > max_absolute_value) \r\n\r\n            {\r\n\r\n                max_absolute_value = std::abs(real_eigenvalues[i]);\r\n\r\n            }\r\n\r\n            if (std::abs(e[i]) > max_absolute_value) \r\n\r\n            {\r\n\r\n                max_absolute_value = std::abs(e[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Make null any main and secondary value too small to be significant\r\n\r\n        if (max_absolute_value != 0) \r\n\r\n        {\r\n\r\n            for (const int& i=0; i < n; i++) \r\n\r\n            {\r\n\r\n                if (std::abs(real_eigenvalues[i]) <= Precision.EPSILON * max_absolute_value) \r\n\r\n                {\r\n\r\n                    real_eigenvalues[i] = 0;\r\n\r\n                }\r\n\r\n                if (std::abs(e[i]) <= Precision.EPSILON * max_absolute_value) \r\n\r\n                {\r\n\r\n                    e[i]=0;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        for (int j{}; j < n; j++) \r\n\r\n        {\r\n\r\n            int its = 0;\r\n\r\n            int m;\r\n\r\n            do \r\n\r\n            {\r\n\r\n                for (m = j; m < n - 1; m++) \r\n\r\n                {\r\n\r\n                    double delta = std::abs(real_eigenvalues[m]) +\r\n\r\n                        std::abs(real_eigenvalues[m + 1]);\r\n\r\n                    if (std::abs(e[m]) + delta == delta) \r\n\r\n                    {\r\n\r\n                        break;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                if (m != j) \r\n\r\n                {\r\n\r\n                    if (its == MAX_ITER) \r\n\r\n                    {\r\n\r\n                        throw Math_Illegal_State_Exception(Localized_Core_Formats.CONVERGENCE_FAILED, MAX_ITER);\r\n\r\n                    }\r\n\r\n                    its++;\r\n\r\n                    double q = (real_eigenvalues[j + 1] - real_eigenvalues[j]) / (2 * e[j]);\r\n\r\n                    double t = std::sqrt(1 + q * q);\r\n\r\n                    if (q < 0.0) \r\n\r\n                    {\r\n\r\n                        q = real_eigenvalues[m] - real_eigenvalues[j] + e[j] / (q - t);\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        q = real_eigenvalues[m] - real_eigenvalues[j] + e[j] / (q + t);\r\n\r\n                    }\r\n\r\n                    double u = 0.0;\r\n\r\n                    double s = 1.0;\r\n\r\n                    double c = 1.0;\r\n\r\n                    int i;\r\n\r\n                    for (i = m - 1; i >= j; i--) \r\n\r\n                    {\r\n\r\n                        double p = s * e[i];\r\n\r\n                        double h = c * e[i];\r\n\r\n                        if (std::abs(p) >= std::abs(q)) \r\n\r\n                        {\r\n\r\n                            c = q / p;\r\n\r\n                            t = std::sqrt(c * c + 1.0);\r\n\r\n                            e[i + 1] = p * t;\r\n\r\n                            s = 1.0 / t;\r\n\r\n                            c *= s;\r\n\r\n                        }\r\n\r\nelse \r\n\r\n                        {\r\n\r\n                            s = p / q;\r\n\r\n                            t = std::sqrt(s * s + 1.0);\r\n\r\n                            e[i + 1] = q * t;\r\n\r\n                            c = 1.0 / t;\r\n\r\n                            s *= c;\r\n\r\n                        }\r\n\r\n                        if (e[i + 1] == 0.0) \r\n\r\n                        {\r\n\r\n                            real_eigenvalues[i + 1] -= u;\r\n\r\n                            e[m] = 0.0;\r\n\r\n                            break;\r\n\r\n                        }\r\n\r\n                        q = real_eigenvalues[i + 1] - u;\r\n\r\n                        t = (real_eigenvalues[i] - q) * s + 2.0 * c * h;\r\n\r\n                        u = s * t;\r\n\r\n                        real_eigenvalues[i + 1] = q + u;\r\n\r\n                        q = c * t - h;\r\n\r\n                        for (const int& ia = 0; ia < n; ia++) \r\n\r\n                        {\r\n\r\n                            p = z[ia][i + 1];\r\n\r\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\r\n\r\n                            z[ia][i] = c * z[ia][i] - s * p;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    if (t == 0.0 && i >= j) \r\n\r\n                    {\r\n\r\n                        continue;\r\n\r\n                    }\r\n\r\n                    real_eigenvalues[j] -= u;\r\n\r\n                    e[j] = q;\r\n\r\n                    e[m] = 0.0;\r\n\r\n                }\r\n\r\n            } while (m != j);\r\n\r\n        }\r\n\r\n\r\n\r\n        //Sort the eigen values (and vectors) in increase order\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            int k = i;\r\n\r\n            double p = real_eigenvalues[i];\r\n\r\n            for (int j = i + 1; j < n; j++) \r\n\r\n            {\r\n\r\n                if (real_eigenvalues[j] > p) \r\n\r\n                {\r\n\r\n                    k = j;\r\n\r\n                    p = real_eigenvalues[j];\r\n\r\n                }\r\n\r\n            }\r\n\r\n            if (k != i) \r\n\r\n            {\r\n\r\n                real_eigenvalues[k] = real_eigenvalues[i];\r\n\r\n                real_eigenvalues[i] = p;\r\n\r\n                for (int j{}; j < n; j++) \r\n\r\n                {\r\n\r\n                    p = z[j][i];\r\n\r\n                    z[j][i] = z[j][k];\r\n\r\n                    z[j][k] = p;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // Determine the largest eigen value in absolute term.\r\n\r\n        max_absolute_value = 0;\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            if (std::abs(real_eigenvalues[i]) > max_absolute_value) \r\n\r\n            {\r\n\r\n                max_absolute_value=std::abs(real_eigenvalues[i]);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Make null any eigen value too small to be significant\r\n\r\n        if (max_absolute_value != 0.0) \r\n\r\n        {\r\n\r\n            for (const int& i=0; i < n; i++) \r\n\r\n            {\r\n\r\n                if (std::abs(real_eigenvalues[i]) < Precision.EPSILON * max_absolute_value) \r\n\r\n                {\r\n\r\n                    real_eigenvalues[i] = 0;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        eigenvectors = Array_Real_Vector[n];\r\n\r\n        const std::vector<double> tmp = std::vector<double>(n];\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            for (int j{}; j < n; j++) \r\n\r\n            {\r\n\r\n                tmp[j] = z[j][i];\r\n\r\n            }\r\n\r\n            eigenvectors[i] = Array_Real_Vector(tmp);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Transforms the matrix to Schur form and calculates the eigenvalues.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to transform.\r\n\r\n     * @return the {@link Schur_Transformer Shur transform} for this matrix\r\n\r\n     */\r\n\r\n    private Schur_Transformer transform_to_schur(const Real_Matrix matrix) \r\n\r\n    {\r\n\r\n        const Schur_Transformer schur_transform = Schur_Transformer(matrix);\r\n\r\n        const std::vector<std::vector<double>> mat_t = schur_transform.get_t().get_data();\r\n\r\n        const double norm = matrix.get_norm1();\r\n\r\n\r\n\r\n        real_eigenvalues = std::vector<double>(mat_t.size()];\r\n\r\n        imag_eigenvalues = std::vector<double>(mat_t.size()];\r\n\r\n\r\n\r\n        for (int i{}; i < real_eigenvalues.size(); i++) \r\n\r\n        {\r\n\r\n            if (i == (real_eigenvalues.size() - 1) ||\r\n\r\n                Precision.equals(mat_t[i + 1][i], 0.0, norm * epsilon)) \r\n\r\n                {\r\n\r\n                real_eigenvalues[i] = mat_t[i][i];\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                const double x = mat_t[i + 1][i + 1];\r\n\r\n                const double p = 0.5 * (mat_t[i][i] - x);\r\n\r\n                const double z = std::sqrt(std::abs(p * p + mat_t[i + 1][i] * mat_t[i][i + 1]));\r\n\r\n                real_eigenvalues[i] = x + p;\r\n\r\n                imag_eigenvalues[i] = z;\r\n\r\n                real_eigenvalues[i + 1] = x + p;\r\n\r\n                imag_eigenvalues[i + 1] = -z;\r\n\r\n                i++;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return schur_transform;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Performs a division of two complex numbers.\r\n\r\n     *\r\n\r\n     * @param xr real part of the first number\r\n\r\n     * @param xi imaginary part of the first number\r\n\r\n     * @param yr real part of the second number\r\n\r\n     * @param yi imaginary part of the second number\r\n\r\n     * @return result of the complex division\r\n\r\n     */\r\n\r\n    private std::complex<double> cdiv(const double xr, const double xi, const double yr, const double yi) \r\n\r\n    {\r\n\r\n        return std::complex<double>(xr, xi).divide(new std::complex<double>(yr, yi));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find eigenvectors from a matrix transformed to Schur form.\r\n\r\n     *\r\n\r\n     * @param schur the schur transformation of the matrix\r\n\r\n     * @Math_Runtime_Exception if the Schur form has a norm of zero\r\n\r\n     */\r\n\r\n    private void find_eigen_vectors_from_schur(const Schur_Transformer schur)\r\n\r\n        Math_Runtime_Exception \r\n\r\n        {\r\n\r\n        const std::vector<std::vector<double>> matrix_t = schur.get_t().get_data();\r\n\r\n        const std::vector<std::vector<double>> matrix_p = schur.get_p().get_data();\r\n\r\n\r\n\r\n        const int n = matrix_t.size();\r\n\r\n\r\n\r\n        // compute matrix norm\r\n\r\n        double norm = 0.0;\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n           for (int j = std::max(i - 1, 0); j < n; j++) \r\n\r\n           {\r\n\r\n               norm += std::abs(matrix_t[i][j]);\r\n\r\n           }\r\n\r\n        }\r\n\r\n\r\n\r\n        // we can not handle a matrix with zero norm\r\n\r\n        if (Precision.equals(norm, 0.0, epsilon)) \r\n\r\n        {\r\n\r\n           throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Backsubstitute to find vectors of upper triangular form\r\n\r\n\r\n\r\n        double r = 0.0;\r\n\r\n        double s = 0.0;\r\n\r\n        double z = 0.0;\r\n\r\n\r\n\r\n        for (const int& idx = n - 1; idx >= 0; idx--) \r\n\r\n        {\r\n\r\n            double p = real_eigenvalues[idx];\r\n\r\n            double q = imag_eigenvalues[idx];\r\n\r\n\r\n\r\n            if (Precision.equals(q, 0.0)) \r\n\r\n            {\r\n\r\n                // Real vector\r\n\r\n                int l = idx;\r\n\r\n                matrix_t[idx][idx] = 1.0;\r\n\r\n                for (int i = idx - 1; i >= 0; i--) \r\n\r\n                {\r\n\r\n                    double w = matrix_t[i][i] - p;\r\n\r\n                    r = 0.0;\r\n\r\n                    for (int j = l; j <= idx; j++) \r\n\r\n                    {\r\n\r\n                        r += matrix_t[i][j] * matrix_t[j][idx];\r\n\r\n                    }\r\n\r\n                    if (Precision.compare_to(imag_eigenvalues[i], 0.0, epsilon) < 0) \r\n\r\n                    {\r\n\r\n                        z = w;\r\n\r\n                        s = r;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        l = i;\r\n\r\n                        if (Precision.equals(imag_eigenvalues[i], 0.0)) \r\n\r\n                        {\r\n\r\n                            if (w != 0.0) \r\n\r\n                            {\r\n\r\n                                matrix_t[i][idx] = -r / w;\r\n\r\n                            }\r\n\r\nelse \r\n\r\n                            {\r\n\r\n                                matrix_t[i][idx] = -r / (Precision.EPSILON * norm);\r\n\r\n                            }\r\n\r\n                        }\r\n\r\nelse \r\n\r\n                        {\r\n\r\n                            // Solve real equations\r\n\r\n                            double x = matrix_t[i][i + 1];\r\n\r\n                            double y = matrix_t[i + 1][i];\r\n\r\n                            q = (real_eigenvalues[i] - p) * (real_eigenvalues[i] - p) +\r\n\r\n                                imag_eigenvalues[i] * imag_eigenvalues[i];\r\n\r\n                            double t = (x * s - z * r) / q;\r\n\r\n                            matrix_t[i][idx] = t;\r\n\r\n                            if (std::abs(x) > std::abs(z)) \r\n\r\n                            {\r\n\r\n                                matrix_t[i + 1][idx] = (-r - w * t) / x;\r\n\r\n                            }\r\n\r\nelse \r\n\r\n                            {\r\n\r\n                                matrix_t[i + 1][idx] = (-s - y * t) / z;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n\r\n                        // Overflow control\r\n\r\n                        double t = std::abs(matrix_t[i][idx]);\r\n\r\n                        if ((Precision.EPSILON * t) * t > 1) \r\n\r\n                        {\r\n\r\n                            for (int j = i; j <= idx; j++) \r\n\r\n                            {\r\n\r\n                                matrix_t[j][idx] /= t;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse if (q < 0.0) \r\n\r\n            {\r\n\r\n                // std::complex<double> vector\r\n\r\n                int l = idx - 1;\r\n\r\n\r\n\r\n                // Last vector component imaginary so matrix is triangular\r\n\r\n                if (std::abs(matrix_t[idx][idx - 1]) > std::abs(matrix_t[idx - 1][idx])) \r\n\r\n                {\r\n\r\n                    matrix_t[idx - 1][idx - 1] = q / matrix_t[idx][idx - 1];\r\n\r\n                    matrix_t[idx - 1][idx]     = -(matrix_t[idx][idx] - p) / matrix_t[idx][idx - 1];\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    const std::complex<double> result = cdiv(0.0, -matrix_t[idx - 1][idx], matrix_t[idx - 1][idx - 1] - p, q);\r\n\r\n                    matrix_t[idx - 1][idx - 1] = result.get_real();\r\n\r\n                    matrix_t[idx - 1][idx]     = result.get_imaginary();\r\n\r\n                }\r\n\r\n\r\n\r\n                matrix_t[idx][idx - 1] = 0.0;\r\n\r\n                matrix_t[idx][idx]     = 1.0;\r\n\r\n\r\n\r\n                for (int i = idx - 2; i >= 0; i--) \r\n\r\n                {\r\n\r\n                    double ra = 0.0;\r\n\r\n                    double sa = 0.0;\r\n\r\n                    for (int j = l; j <= idx; j++) \r\n\r\n                    {\r\n\r\n                        ra += matrix_t[i][j] * matrix_t[j][idx - 1];\r\n\r\n                        sa += matrix_t[i][j] * matrix_t[j][idx];\r\n\r\n                    }\r\n\r\n                    double w = matrix_t[i][i] - p;\r\n\r\n\r\n\r\n                    if (Precision.compare_to(imag_eigenvalues[i], 0.0, epsilon) < 0) \r\n\r\n                    {\r\n\r\n                        z = w;\r\n\r\n                        r = ra;\r\n\r\n                        s = sa;\r\n\r\n                    }\r\n\r\nelse \r\n\r\n                    {\r\n\r\n                        l = i;\r\n\r\n                        if (Precision.equals(imag_eigenvalues[i], 0.0)) \r\n\r\n                        {\r\n\r\n                            const std::complex<double> c = cdiv(-ra, -sa, w, q);\r\n\r\n                            matrix_t[i][idx - 1] = c.get_real();\r\n\r\n                            matrix_t[i][idx] = c.get_imaginary();\r\n\r\n                        }\r\n\r\nelse \r\n\r\n                        {\r\n\r\n                            // Solve complex equations\r\n\r\n                            double x = matrix_t[i][i + 1];\r\n\r\n                            double y = matrix_t[i + 1][i];\r\n\r\n                            double vr = (real_eigenvalues[i] - p) * (real_eigenvalues[i] - p) +\r\n\r\n                                        imag_eigenvalues[i] * imag_eigenvalues[i] - q * q;\r\n\r\n                            const double vi = (real_eigenvalues[i] - p) * 2.0 * q;\r\n\r\n                            if (Precision.equals(vr, 0.0) && Precision.equals(vi, 0.0)) \r\n\r\n                            {\r\n\r\n                                vr = Precision.EPSILON * norm *\r\n\r\n                                     (std::abs(w) + std::abs(q) + std::abs(x) +\r\n\r\n                                      std::abs(y) + std::abs(z));\r\n\r\n                            }\r\n\r\n                            const std::complex<double> c     = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\r\n\r\n                            matrix_t[i][idx - 1] = c.get_real();\r\n\r\n                            matrix_t[i][idx]     = c.get_imaginary();\r\n\r\n\r\n\r\n                            if (std::abs(x) > (std::abs(z) + std::abs(q))) \r\n\r\n                            {\r\n\r\n                                matrix_t[i + 1][idx - 1] = (-ra - w * matrix_t[i][idx - 1] +\r\n\r\n                                                           q * matrix_t[i][idx]) / x;\r\n\r\n                                matrix_t[i + 1][idx]     = (-sa - w * matrix_t[i][idx] -\r\n\r\n                                                           q * matrix_t[i][idx - 1]) / x;\r\n\r\n                            }\r\n\r\nelse \r\n\r\n                            {\r\n\r\n                                const std::complex<double> c2        = cdiv(-r - y * matrix_t[i][idx - 1], -s - y * matrix_t[i][idx], z, q);\r\n\r\n                                matrix_t[i + 1][idx - 1] = c2.get_real();\r\n\r\n                                matrix_t[i + 1][idx]     = c2.get_imaginary();\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n\r\n\r\n                        // Overflow control\r\n\r\n                        double t = std::max(std::abs(matrix_t[i][idx - 1]), std::abs(matrix_t[i][idx]));\r\n\r\n                        if ((Precision.EPSILON * t) * t > 1) \r\n\r\n                        {\r\n\r\n                            for (int j = i; j <= idx; j++) \r\n\r\n                            {\r\n\r\n                                matrix_t[j][idx - 1] /= t;\r\n\r\n                                matrix_t[j][idx] /= t;\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // Back transformation to get eigenvectors of original matrix\r\n\r\n        for (int j = n - 1; j >= 0; j--) \r\n\r\n        {\r\n\r\n            for (int i{}; i <= n - 1; i++) \r\n\r\n            {\r\n\r\n                z = 0.0;\r\n\r\n                for (int k{}; k <= std::min(j, n - 1); k++) \r\n\r\n                {\r\n\r\n                    z += matrix_p[i][k] * matrix_t[k][j];\r\n\r\n                }\r\n\r\n                matrix_p[i][j] = z;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        eigenvectors = Array_Real_Vector[n];\r\n\r\n        const std::vector<double> tmp = std::vector<double>(n];\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            for (int j{}; j < n; j++) \r\n\r\n            {\r\n\r\n                tmp[j] = matrix_p[j][i];\r\n\r\n            }\r\n\r\n            eigenvectors[i] = Array_Real_Vector(tmp);\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n