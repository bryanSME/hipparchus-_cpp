/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import org.hipparchus.analysis.function.Sqrt;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the standard Jacobi (diagonal) preconditioner. For a\r\n\r\n * matrix A<sub>ij</sub>, this preconditioner is\r\n\r\n * M = diag(1 / A<sub>11</sub>, 1 / A<sub>22</sub>, &hellip;).\r\n\r\n */\r\n\r\nclass Jacobi_Preconditioner : Real_Linear_Operator \r\n\r\n{\r\n\r\n\r\n\r\n    /** The diagonal coefficients of the preconditioner. */\r\n\r\n    private const Array_Real_Vector diag;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a instance of this class.\r\n\r\n     *\r\n\r\n     * @param diag the diagonal coefficients of the linear operator to be\r\n\r\n     * preconditioned\r\n\r\n     * @param deep {@code true} if a deep copy of the above array should be\r\n\r\n     * performed\r\n\r\n     */\r\n\r\n    public Jacobi_Preconditioner(const std::vector<double> diag, const bool deep) \r\n\r\n    {\r\n\r\n        this.diag = Array_Real_Vector(diag, deep);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a instance of this class. This method extracts the diagonal\r\n\r\n     * coefficients of the specified linear operator. If {@code a} does not\r\n\r\n     * extend {@link Abstract_Real_Matrix}, then the coefficients of the\r\n\r\n     * underlying matrix are not accessible, coefficient extraction is made by\r\n\r\n     * matrix-vector products with the basis vectors (and might therefore take\r\n\r\n     * some time). With matrices, direct entry access is carried out.\r\n\r\n     *\r\n\r\n     * @param a the linear operator for which the preconditioner should be built\r\n\r\n     * @return the diagonal preconditioner made of the inverse of the diagonal\r\n\r\n     * coefficients of the specified linear operator\r\n\r\n     * @ if {@code a} is not square\r\n\r\n     */\r\n\r\n    public static Jacobi_Preconditioner create(const Real_Linear_Operator a)\r\n\r\n         \r\n\r\n        {\r\n\r\n        const int n = a.get_column_dimension();\r\n\r\n        if (a.get_row_dimension() != n) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_OPERATOR, a.get_row_dimension(), n);\r\n\r\n        }\r\n\r\n        const std::vector<double> diag = std::vector<double>(n];\r\n\r\n        if (a instanceof Abstract_Real_Matrix) \r\n\r\n        {\r\n\r\n            const Abstract_Real_Matrix m = (Abstract_Real_Matrix) a;\r\n\r\n            for (int i{}; i < n; i++) \r\n\r\n            {\r\n\r\n                diag[i] = m.get_entry(i, i);\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const Array_Real_Vector x = Array_Real_Vector(n);\r\n\r\n            for (int i{}; i < n; i++) \r\n\r\n            {\r\n\r\n                x.set(0.);\r\n\r\n                x.set_entry(i, 1.);\r\n\r\n                diag[i] = a.operate(x).get_entry(i);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return Jacobi_Preconditioner(diag, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_column_dimension() \r\n\r\n    {\r\n\r\n        return diag.get_dimension();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_row_dimension() \r\n\r\n    {\r\n\r\n        return diag.get_dimension();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Real_Vector operate(const Real_Vector x) \r\n\r\n    {\r\n\r\n        // Dimension check is carried out by ebe_divide\r\n\r\n        return Array_Real_Vector(Math_Arrays::ebe_divide(x.to_array(), diag.to_array()), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the square root of {@code this} diagonal operator. More\r\n\r\n     * precisely, this method returns\r\n\r\n     * P = diag(1 / &radic;A<sub>11</sub>, 1 / &radic;A<sub>22</sub>, &hellip;).\r\n\r\n     *\r\n\r\n     * @return the square root of {@code this} preconditioner\r\n\r\n     */\r\n\r\n    public Real_Linear_Operator sqrt() \r\n\r\n    {\r\n\r\n        const Real_Vector sqrt_diag = diag.map(new Sqrt());\r\n\r\n        return Real_Linear_Operator() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public Real_Vector operate(const Real_Vector x) \r\n\r\n            {\r\n\r\n                return Array_Real_Vector(Math_Arrays::ebe_divide(x.to_array(), sqrt_diag.to_array()), false);\r\n\r\n            }\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public int get_row_dimension() \r\n\r\n            {\r\n\r\n                return sqrt_diag.get_dimension();\r\n\r\n            }\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public int get_column_dimension() \r\n\r\n            {\r\n\r\n                return sqrt_diag.get_dimension();\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n