/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n#include "AbstractRealMatrix.h"\r\n\r\n#include "MatrixUtils.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * Implementation of a diagonal matrix.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Diagonal_Matrix : public Abstract_Real_Matrix\r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Entries of the diagonal. */\r\n\r\n    std::vector<double> my_data;\r\n\r\n\r\n\r\n    /** Ensure a value is zero.\r\n\r\n     * @param value value to check\r\n\r\n     * @exception  if value is not zero\r\n\r\n     */\r\n\r\n    void ensure_zero(const double value)\r\n\r\n    {\r\n\r\n        /*if (!Precision.equals(0.0, value, 1))\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_TOO_LARGE, std::abs(value), 0);\r\n\r\n        }*/\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * Creates a matrix with the supplied dimension.\r\n\r\n     *\r\n\r\n     * @param dimension Number of rows and columns in the matrix.\r\n\r\n     * @ if the dimension is\r\n\r\n     * not positive.\r\n\r\n     */\r\n\r\n    Diagonal_Matrix(const int& dimension)\r\n\r\n         \r\n\r\n        {\r\n\r\n        //super(dimension, dimension);\r\n\r\n        my_data = std::vector<double>(dimension);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a matrix using the input array as the underlying data.\r\n\r\n     * <br/>\r\n\r\n     * The input array is copied, not referenced.\r\n\r\n     *\r\n\r\n     * @param d Data for the matrix.\r\n\r\n     */\r\n\r\n    Diagonal_Matrix(const std::vector<double> d) \r\n\r\n    {\r\n\r\n        Diagonal_Matrix(d, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a matrix using the input array as the underlying data.\r\n\r\n     * <br/>\r\n\r\n     * If an array is created specially in order to be embedded in a\r\n\r\n     * this instance and not used directly, the {@code copy_array} may be\r\n\r\n     * set to {@code false}.\r\n\r\n     * This will prevent the copying and improve performance as no new\r\n\r\n     * array will be built and no data will be copied.\r\n\r\n     *\r\n\r\n     * @param d Data for matrix.\r\n\r\n     * @param copy_array if {@code true}, the input array will be copied, * otherwise it will be referenced.\r\n\r\n     * @exception Null_Argument_Exception if d is null\r\n\r\n     */\r\n\r\n    Diagonal_Matrix(const std::vector<double>& d, const bool& copy_array) \r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(d);\r\n\r\n        my_data = copy_array\r\n\r\n            ? d.clone()\r\n\r\n            : d;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     *\r\n\r\n     * @ if the requested dimensions are not equal.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Real_Matrix create_matrix(const int& row_dimension, const int column_dimension)\r\n\r\n    {\r\n\r\n        /*if (row_dimension != column_dimension) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, row_dimension, column_dimension);\r\n\r\n        }*/\r\n\r\n\r\n\r\n        return Diagonal_Matrix(row_dimension);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Real_Matrix copy() \r\n\r\n    {\r\n\r\n        return Diagonal_Matrix(my_data);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the sum of {@code this} and {@code m}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be added.\r\n\r\n     * @return {@code this + m}.\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this}.\r\n\r\n     */\r\n\r\n    Diagonal_Matrix add(const Diagonal_Matrix m)\r\n\r\n         \r\n\r\n        {\r\n\r\n        // Safety check.\r\n\r\n        //Matrix_Utils.check_addition_compatible(this, m);\r\n\r\n\r\n\r\n        const int dim = get_row_dimension();\r\n\r\n        auto out_data = std::vector<double>(dim);\r\n\r\n        for (int i{}; i < dim; i++) \r\n\r\n        {\r\n\r\n            out_data[i] = my_data[i] + m.get_data_ref()[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        return Diagonal_Matrix(out_data, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code this} minus {@code m}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be subtracted.\r\n\r\n     * @return {@code this - m}\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this}.\r\n\r\n     */\r\n\r\n    Diagonal_Matrix subtract(const Diagonal_Matrix m)\r\n\r\n    {\r\n\r\n        //Matrix_Utils.check_subtraction_compatible(this, m);\r\n\r\n\r\n\r\n        const int dim = get_row_dimension();\r\n\r\n        auto out_data = std::vector<double>(dim);\r\n\r\n        for (int i{}; i < dim; i++) \r\n\r\n        {\r\n\r\n            out_data[i] = my_data[i] - m.get_data_ref()[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        return Diagonal_Matrix(out_data, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of postmultiplying {@code this} by {@code m}.\r\n\r\n     *\r\n\r\n     * @param m matrix to postmultiply by\r\n\r\n     * @return {@code this * m}\r\n\r\n     * @ if\r\n\r\n     * {@code column_dimension(this) != row_dimension(m)}\r\n\r\n     */\r\n\r\n    Diagonal_Matrix multiply(const Diagonal_Matrix m)\r\n\r\n         \r\n\r\n        {\r\n\r\n        Matrix_Utils.check_multiplication_compatible(this, m);\r\n\r\n\r\n\r\n        const int dim = get_row_dimension();\r\n\r\n        auto out_data = std::vector<double>(dim);\r\n\r\n        for (int i{}; i < dim; i++) \r\n\r\n        {\r\n\r\n            out_data[i] = my_data[i] * m.get_data_ref()[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        return Diagonal_Matrix(out_data, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Real_Matrix multiply(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        if (m instanceof Diagonal_Matrix) \r\n\r\n        {\r\n\r\n            return multiply((Diagonal_Matrix) m);\r\n\r\n        }\r\n\r\n        Matrix_Utils.check_multiplication_compatible(this, m);\r\n\r\n        const Real_Matrix product = m.create_matrix(m.get_row_dimension(), m.get_column_dimension());\r\n\r\n        product.walk_in_optimized_order(new Default_Real_Matrix_Changing_Visitor() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public double visit(const int& row, const int& column, double value) \r\n\r\n            {\r\n\r\n                return my_data[row] * m.get_entry(row, column);\r\n\r\n            }\r\n\r\n        });\r\n\r\n        return product;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of postmultiplying {@code this} by {@code m^T}.\r\n\r\n     * @param m matrix to first transpose and second postmultiply by\r\n\r\n     * @return {@code this * m}\r\n\r\n     * @ if\r\n\r\n     * {@code column_dimension(this) != column_dimension(m)}\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    Diagonal_Matrix multiply_transposed(const Diagonal_Matrix m)\r\n\r\n    {\r\n\r\n        // transposition is no-op for diagonal matrices\r\n\r\n        return multiply(m);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Real_Matrix multiply_transposed(const Real_Matrix& m)\r\n\r\n    {\r\n\r\n        if (m instanceof Diagonal_Matrix) \r\n\r\n        {\r\n\r\n            return multiply_transposed((Diagonal_Matrix) m);\r\n\r\n        }\r\n\r\n\r\n\r\n        Matrix_Utils.check_same_column_dimension(this, m);\r\n\r\n        const Real_Matrix product = m.create_matrix(m.get_column_dimension(), m.get_row_dimension());\r\n\r\n        product.walk_in_optimized_order(new Default_Real_Matrix_Changing_Visitor() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public double visit(const int& row, const int& column, double value) \r\n\r\n            {\r\n\r\n                return my_data[row] * m.get_entry(column, row);\r\n\r\n            }\r\n\r\n        });\r\n\r\n        return product;\r\n\r\n       \r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of postmultiplying {@code this^T} by {@code m}.\r\n\r\n     * @param m matrix to first transpose and second postmultiply by\r\n\r\n     * @return {@code this^T * m}\r\n\r\n     * @ if\r\n\r\n     * {@code column_dimension(this) != column_dimension(m)}\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    Diagonal_Matrix transpose_multiply(const Diagonal_Matrix m)\r\n\r\n    {\r\n\r\n        // transposition is no-op for diagonal matrices\r\n\r\n        return multiply(m);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Real_Matrix transpose_multiply(const Real_Matrix& m) \r\n\r\n    {\r\n\r\n        if (m instanceof Diagonal_Matrix) \r\n\r\n        {\r\n\r\n            return transpose_multiply((Diagonal_Matrix) m);\r\n\r\n        }\r\n\r\n\r\n\r\n        // transposition is no-op for diagonal matrices\r\n\r\n        return multiply(m);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    std::vector<std::vector<double>> get_data() \r\n\r\n    {\r\n\r\n        const int dim = get_row_dimension();\r\n\r\n        auto out = std::vector<std::vector<double>>(dim, std::vector<double>(dim));\r\n\r\n\r\n\r\n        for (int i{}; i < dim; i++) \r\n\r\n        {\r\n\r\n            out[i][i] = my_data[i];\r\n\r\n        }\r\n\r\n\r\n\r\n        return out;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets a reference to the underlying data array.\r\n\r\n     *\r\n\r\n     * @return 1-dimensional array of entries.\r\n\r\n     */\r\n\r\n    std::vector<double> get_data_ref() const\r\n\r\n    {\r\n\r\n        return my_data; // NOPMD - returning an internal array is intentional and documented here\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    double get_entry(const int& row, const int column)\r\n\r\n    {\r\n\r\n        Matrix_Utils.check_matrix_index(this, row, column);\r\n\r\n        return row == column\r\n\r\n            ? my_data[row]\r\n\r\n            : 0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * @ if {@code row != column} and value is non-zero.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    void set_entry(const int& row, const int& column, const double value)\r\n\r\n    {\r\n\r\n        if (row == column) \r\n\r\n        {\r\n\r\n            Matrix_Utils.check_row_index(this, row);\r\n\r\n            my_data[row] = value;\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            ensure_zero(value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * @ if {@code row != column} and increment is non-zero.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    void add_to_entry(const int& row, const int& column, const double& increment)\r\n\r\n    {\r\n\r\n        if (row == column) \r\n\r\n        {\r\n\r\n            Matrix_Utils.check_row_index(this, row);\r\n\r\n            my_data[row] += increment;\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            ensure_zero(increment);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    void multiply_entry(const int& row, const int& column, const double& factor)\r\n\r\n    {\r\n\r\n        // we don't care about non-diagonal elements for multiplication\r\n\r\n        if (row == column) \r\n\r\n        {\r\n\r\n            Matrix_Utils.check_row_index(this, row);\r\n\r\n            my_data[row] *= factor;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int get_row_dimension() const\r\n\r\n    {\r\n\r\n        return my_data.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int get_column_dimension() const\r\n\r\n    {\r\n\r\n        return my_data.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    std::vector<double> operate(const std::vector<double>& v)\r\n\r\n    {\r\n\r\n        return multiply(new Diagonal_Matrix(v, false)).get_data_ref();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    std::vector<double> pre_multiply(const std::vector<double>& v)\r\n\r\n    {\r\n\r\n        return operate(v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Real_Vector pre_multiply(const Real_Vector v)  \r\n\r\n    {\r\n\r\n        const std::vector<double>& vector_data;\r\n\r\n        if (v instanceof Array_Real_Vector) \r\n\r\n        {\r\n\r\n            vector_data = ((Array_Real_Vector) v).get_data_ref();\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            vector_data = v.to_array();\r\n\r\n        }\r\n\r\n        return Matrix_Utils.create_real__vector(pre_multiply(vector_data));\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the inverse of this diagonal matrix.\r\n\r\n     * <p>\r\n\r\n     * Note: this method will use a singularity threshold of 0, * use {@link #inversestatic_cast<double>(} if a different threshold is needed.\r\n\r\n     *\r\n\r\n     * @return the inverse of {@code m}\r\n\r\n     * @ if the matrix is singular\r\n\r\n     */\r\n\r\n    Diagonal_Matrix inverse()  \r\n\r\n    {\r\n\r\n        return inverse(0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the inverse of this diagonal matrix.\r\n\r\n     *\r\n\r\n     * @param threshold Singularity threshold.\r\n\r\n     * @return the inverse of {@code m}\r\n\r\n     * @ if the matrix is singular\r\n\r\n     */\r\n\r\n    Diagonal_Matrix inverse(double threshold)  \r\n\r\n    {\r\n\r\n        if (is_singular(threshold)) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n        }\r\n\r\n\r\n\r\n        auto result = std::vector<double>(my_data.size()];\r\n\r\n        for (int i{}; i < my_data.size(); i++)\r\n\r\n        {\r\n\r\n            result[i] = 1.0 / my_data[i];\r\n\r\n        }\r\n\r\n        return Diagonal_Matrix(result, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Returns whether this diagonal matrix is singular, i.e. any diagonal entry\r\n\r\n     * is equal to {@code 0} within the given threshold.\r\n\r\n     *\r\n\r\n     * @param threshold Singularity threshold.\r\n\r\n     * @return {@code true} if the matrix is singular, {@code false} otherwise\r\n\r\n     */\r\n\r\n    bool is_singular(double threshold) \r\n\r\n    {\r\n\r\n        for (int i{}; i < my_data.size(); i++)\r\n\r\n        {\r\n\r\n            if (Precision.equals(my_data[i], 0.0, threshold))\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n};\r\n