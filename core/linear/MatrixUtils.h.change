/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import java.io.IOException;\r\n\r\n//import java.io.Object_Input_Stream;\r\n\r\n//import java.io.Object_Output_Stream;\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.Arrays;\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.fraction.Big_Fraction;\r\n\r\n//import org.hipparchus.fraction.Fraction;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n#include <vector>\r\n\r\n#include <cmath>\r\n\r\n#include "RealMatrixFormat.h"\r\n\r\n#include "DecompositionSolver.h"\r\n\r\n\r\n\r\n/**\r\n\r\n * A collection of static methods that operate on or return matrices.\r\n\r\n *\r\n\r\n */\r\n\r\nclass Matrix_Utils \r\n\r\n{\r\n\r\n\r\n\r\nprivate:\r\n\r\n    /** Pade coefficients required for the matrix exponential calculation. */\r\n\r\n    static const std::vector<double> PADE_COEFFICIENTS_3 = \r\n\r\n    {\r\n\r\n            120.0, 60.0, 12.0, 1.0\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Pade coefficients required for the matrix exponential calculation. */\r\n\r\n    static const std::vector<double> PADE_COEFFICIENTS_5 = \r\n\r\n    {\r\n\r\n            30240.0, 15120.0, 3360.0, 420.0, 30.0, 1\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Pade coefficients required for the matrix exponential calculation. */\r\n\r\n    static const std::vector<double> PADE_COEFFICIENTS_7 = \r\n\r\n    {\r\n\r\n            17297280.0, 8648640.0, 1995840.0, 277200.0, 25200.0, 1512.0, 56.0, 1.0\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Pade coefficients required for the matrix exponential calculation. */\r\n\r\n    static const std::vector<double> PADE_COEFFICIENTS_9 = \r\n\r\n    {\r\n\r\n            17643225600.0, 8821612800.0, 2075673600.0, 302702400.0, 30270240.0, 2162160.0, 110880.0, 3960.0, 90.0, 1.0\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Pade coefficients required for the matrix exponential calculation. */\r\n\r\n    static const std::vector<double> PADE_COEFFICIENTS_13 = \r\n\r\n    {\r\n\r\n            6.476475253248e+16, 3.238237626624e+16, 7.7717703038976e+15, 1.1873537964288e+15, 129060195264000.0, 10559470521600.0, 670442572800.0, 33522128640.0, 1323241920.0, 40840800.0, 960960.0, 16380.0, 182.0, 1.0\r\n\r\n    };\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Private constructor.\r\n\r\n     */\r\n\r\n    Matrix_Utils() \r\n\r\n    {\r\n\r\n        //super();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether a matrix is symmetric, within a given relative tolerance.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to check.\r\n\r\n     * @param relative_tolerance Tolerance of the symmetry check.\r\n\r\n     * @param raiseException If {@code true}, an exception will be raised if\r\n\r\n     * the matrix is not symmetric.\r\n\r\n     * @return {@code true} if {@code matrix} is symmetric.\r\n\r\n     * @ if the matrix is not square.\r\n\r\n     * @ if the matrix is not symmetric.\r\n\r\n     */\r\n\r\n    private static bool is_symmetricInternal(Real_Matrix matrix, double relative_tolerance, bool raiseException)\r\n\r\n    {\r\n\r\n        const int rows = matrix.get_row_dimension();\r\n\r\n        if (rows != matrix.get_column_dimension())\r\n\r\n        {\r\n\r\n            if (raiseException)\r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.NON_SQUARE_MATRIX, rows, matrix.get_column_dimension());\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for (int i{}; i < rows; i++)\r\n\r\n        {\r\n\r\n            for (int j = i + 1; j < rows; j++)\r\n\r\n            {\r\n\r\n                const double mij = matrix.get_entry(i, j);\r\n\r\n                const double mji = matrix.get_entry(j, i);\r\n\r\n                if (std::abs(mij - mji) >\r\n\r\n                    std::max(std::abs(mij), std::abs(mji)) * relative_tolerance)\r\n\r\n                {\r\n\r\n                    if (raiseException)\r\n\r\n                    {\r\n\r\n                        throw (Localized_Core_Formats.NON_SYMMETRIC_MATRIX, i, j, relative_tolerance);\r\n\r\n                    }\r\n\r\n                    else\r\n\r\n                    {\r\n\r\n                        return false;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /**\r\n\r\n     * The default format for {@link Real_Matrix} objects.\r\n\r\n     */\r\n\r\n    static const Real_Matrix_Format DEFAULT_FORMAT = Real_Matrix_Format.get_real__matrix_format();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * A format for {@link Real_Matrix} objects compatible with octave.\r\n\r\n     */\r\n\r\n    static const Real_Matrix_Format OCTAVE_FORMAT = Real_Matrix_Format("[", "]", "", "", "; ", ", ");\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@link Real_Matrix} with specified dimensions.\r\n\r\n     * <p>The type of matrix returned depends on the dimension. Below\r\n\r\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\r\n\r\n     * square matrix) which can be stored in a 32kB array, a {@link\r\n\r\n     * Array_2D_Row_Real_Matrix} instance is built. Above this threshold a {@link\r\n\r\n     * Block_Real_Matrix} instance is built.</p>\r\n\r\n     * <p>The matrix elements are all set to 0.0.</p>\r\n\r\n     * @param rows number of rows of the matrix\r\n\r\n     * @param columns number of columns of the matrix\r\n\r\n     * @return  Real_Matrix with specified dimensions\r\n\r\n     * @see #create_real_matrix(std::vector<std::vector<double>>)\r\n\r\n     */\r\n\r\n    static Real_Matrix create_real_matrix(const int rows, const int columns) \r\n\r\n    {\r\n\r\n        return (rows * columns <= 4096) ?\r\n\r\n                Array_2D_Row_Real_Matrix(rows, columns) : Block_Real_Matrix(rows, columns);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@link Field_Matrix} with specified dimensions.\r\n\r\n     * <p>The type of matrix returned depends on the dimension. Below\r\n\r\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\r\n\r\n     * square matrix), a {@link Field_Matrix} instance is built. Above\r\n\r\n     * this threshold a {@link BlockField_Matrix} instance is built.</p>\r\n\r\n     * <p>The matrix elements are all set to field.get_zero().</p>\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which the matrix elements belong\r\n\r\n     * @param rows number of rows of the matrix\r\n\r\n     * @param columns number of columns of the matrix\r\n\r\n     * @return  Field_Matrix with specified dimensions\r\n\r\n     * @see #create_field_matrix(Field_Element[][])\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T> create_field_matrix(const Field<T> field, const int rows, const int columns) \r\n\r\n    {\r\n\r\n        return (rows * columns <= 4096) ?\r\n\r\n                Array2DRowField_Matrix<T>(field, rows, columns) : BlockField_Matrix<T>(field, rows, columns);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@link Real_Matrix} whose entries are the the values in the\r\n\r\n     * the input array.\r\n\r\n     * <p>The type of matrix returned depends on the dimension. Below\r\n\r\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\r\n\r\n     * square matrix) which can be stored in a 32kB array, a {@link\r\n\r\n     * Array_2D_Row_Real_Matrix} instance is built. Above this threshold a {@link\r\n\r\n     * Block_Real_Matrix} instance is built.</p>\r\n\r\n     * <p>The input array is copied, not referenced.</p>\r\n\r\n     *\r\n\r\n     * @param data input array\r\n\r\n     * @return  Real_Matrix containing the values of the array\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code data} is not rectangular (not all rows have the same length).\r\n\r\n     * @ if a row or column is empty.\r\n\r\n     * @Null_Argument_Exception if either {@code data} or {@code data[0]}\r\n\r\n     * is {@code null}.\r\n\r\n     * @ if {@code data} is not rectangular.\r\n\r\n     * @see #create_real_matrix(int, int)\r\n\r\n     */\r\n\r\n    static Real_Matrix create_real_matrix(std::vector<std::vector<double>> data)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (data == null ||\r\n\r\n            data[0] == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        return (data.size() * data[0].size() <= 4096) ?\r\n\r\n                Array_2D_Row_Real_Matrix(data) : Block_Real_Matrix(data);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@link Field_Matrix} whose entries are the the values in the\r\n\r\n     * the input array.\r\n\r\n     * <p>The type of matrix returned depends on the dimension. Below\r\n\r\n     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\r\n\r\n     * square matrix), a {@link Field_Matrix} instance is built. Above\r\n\r\n     * this threshold a {@link BlockField_Matrix} instance is built.</p>\r\n\r\n     * <p>The input array is copied, not referenced.</p>\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param data input array\r\n\r\n     * @return a matrix containing the values of the array.\r\n\r\n     * @org.hipparchus.exception.\r\n\r\n     * if {@code data} is not rectangular (not all rows have the same length).\r\n\r\n     * @ if a row or column is empty.\r\n\r\n     * @Null_Argument_Exception if either {@code data} or {@code data[0]}\r\n\r\n     * is {@code null}.\r\n\r\n     * @see #create_field_matrix(Field, int, int)\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T> create_field_matrix(std::vector<std::vector<T>> data)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (data == null ||\r\n\r\n            data[0] == null) \r\n\r\n            {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        return (data.size() * data[0].size() <= 4096) ?\r\n\r\n                Array2DRowField_Matrix<T>(data) : BlockField_Matrix<T>(data);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns <code>dimension x dimension</code> identity matrix.\r\n\r\n     *\r\n\r\n     * @param dimension dimension of identity matrix to generate\r\n\r\n     * @return identity matrix\r\n\r\n     * @Illegal_Argument_Exception if dimension is not positive\r\n\r\n     */\r\n\r\n    static Real_Matrix create_real_identity_matrix(const int& dimension) \r\n\r\n    {\r\n\r\n        const Real_Matrix m = create_real_matrix(dimension, dimension);\r\n\r\n        for (int i{}; i < dimension; ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(i, i, 1.0);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns <code>dimension x dimension</code> identity matrix.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which the elements belong\r\n\r\n     * @param dimension dimension of identity matrix to generate\r\n\r\n     * @return identity matrix\r\n\r\n     * @Illegal_Argument_Exception if dimension is not positive\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T>\r\n\r\n        create_field_identity_matrix(const Field<T> field, const int& dimension) \r\n\r\n        {\r\n\r\n        const T zero = field.get_zero();\r\n\r\n        const T one  = field.get_one();\r\n\r\n        const std::vector<std::vector<T>> d = Math_Arrays::build_array(field, dimension, dimension);\r\n\r\n        for (int row = 0; row < dimension; row++) \r\n\r\n        {\r\n\r\n            const std::vector<T> d_row = d[row];\r\n\r\n            Arrays.fill(d_row, zero);\r\n\r\n            d_row[row] = one;\r\n\r\n        }\r\n\r\n        return Array2DRowField_Matrix<T>(field, d, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a diagonal matrix with specified elements.\r\n\r\n     *\r\n\r\n     * @param diagonal diagonal elements of the matrix (the array elements\r\n\r\n     * will be copied)\r\n\r\n     * @return diagonal matrix\r\n\r\n     */\r\n\r\n    static Real_Matrix create_real_diagonal_matrix(const std::vector<double> diagonal) \r\n\r\n    {\r\n\r\n        const Real_Matrix m = create_real_matrix(diagonal.size(), diagonal.size());\r\n\r\n        for (int i{}; i < diagonal.size(); ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(i, i, diagonal[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a diagonal matrix with specified elements.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param diagonal diagonal elements of the matrix (the array elements\r\n\r\n     * will be copied)\r\n\r\n     * @return diagonal matrix\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T>\r\n\r\n        createFieldDiagonal_Matrix(const std::vector<T> diagonal) \r\n\r\n        {\r\n\r\n        const Field_Matrix<T> m =\r\n\r\n            create_field_matrix(diagonal[0].get_field(), diagonal.size(), diagonal.size());\r\n\r\n        for (int i{}; i < diagonal.size(); ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(i, i, diagonal[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a {@link Real_Vector} using the data from the input array.\r\n\r\n     *\r\n\r\n     * @param data the input data\r\n\r\n     * @return a data.size() Real_Vector\r\n\r\n     * @ if {@code data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code data} is {@code null}.\r\n\r\n     */\r\n\r\n    static Real_Vector create_real__vector(std::vector<double> data)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        return Array_Real_Vector(data, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a {@link Real_Vector} with specified dimensions.\r\n\r\n     *\r\n\r\n     * @param dimension dimension of the vector\r\n\r\n     * @return a vector\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    static Real_Vector create_real__vector(const int& dimension) \r\n\r\n    {\r\n\r\n        return Array_Real_Vector(std::vector<double>(dimension]);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a {@link Field_Vector} using the data from the input array.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param data the input data\r\n\r\n     * @return a data.size() Field_Vector\r\n\r\n     * @ if {@code data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code data} is {@code null}.\r\n\r\n     * @ if {@code data} has 0 elements\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Vector<T> create_field_vector(const std::vector<T> data)\r\n\r\n    {\r\n\r\n        if (data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        if (data.size() == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\r\n\r\n        }\r\n\r\n        return ArrayField_Vector<T>(data[0].get_field(), data, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a {@link Field_Vector} with specified dimensions.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param field field to which array elements belong\r\n\r\n     * @param dimension dimension of the vector\r\n\r\n     * @return a vector\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Vector<T> create_field_vector(const Field<T> field, const int& dimension) \r\n\r\n    {\r\n\r\n        return ArrayField_Vector<>(Math_Arrays::build_array(field, dimension));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a row {@link Real_Matrix} using the data from the input\r\n\r\n     * array.\r\n\r\n     *\r\n\r\n     * @param row_data the input row data\r\n\r\n     * @return a 1 x row_data.size() Real_Matrix\r\n\r\n     * @ if {@code row_data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code row_data} is {@code null}.\r\n\r\n     */\r\n\r\n    static Real_Matrix createRowReal_Matrix(std::vector<double> row_data) \r\n\r\n    {\r\n\r\n        if (row_data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        const int& n_cols = row_data.size();\r\n\r\n        const Real_Matrix m = create_real_matrix(1, n_cols);\r\n\r\n        for (int i{}; i < n_cols; ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(0, i, row_data[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a row {@link Field_Matrix} using the data from the input\r\n\r\n     * array.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param row_data the input row data\r\n\r\n     * @return a 1 x row_data.size() Field_Matrix\r\n\r\n     * @ if {@code row_data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code row_data} is {@code null}.\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T>\r\n\r\n        createRowField_Matrix(const std::vector<T> row_data)\r\n\r\n        , Null_Argument_Exception \r\n\r\n        {\r\n\r\n        if (row_data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        const int& n_cols = row_data.size();\r\n\r\n        if (n_cols == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.AT_LEAST_ONE_COLUMN);\r\n\r\n        }\r\n\r\n        const Field_Matrix<T> m = create_field_matrix(row_data[0].get_field(), 1, n_cols);\r\n\r\n        for (int i{}; i < n_cols; ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(0, i, row_data[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a column {@link Real_Matrix} using the data from the input\r\n\r\n     * array.\r\n\r\n     *\r\n\r\n     * @param column_data  the input column data\r\n\r\n     * @return a column_data x 1 Real_Matrix\r\n\r\n     * @ if {@code column_data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code column_data} is {@code null}.\r\n\r\n     */\r\n\r\n    static Real_Matrix create_column_real__matrix(std::vector<double> column_data)\r\n\r\n    {\r\n\r\n        if (column_data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        const int& n_rows = column_data.size();\r\n\r\n        const Real_Matrix m = create_real_matrix(n_rows, 1);\r\n\r\n        for (int i{}; i < n_rows; ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(i, 0, column_data[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Creates a column {@link Field_Matrix} using the data from the input\r\n\r\n     * array.\r\n\r\n     *\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @param column_data  the input column data\r\n\r\n     * @return a column_data x 1 Field_Matrix\r\n\r\n     * @ if {@code data} is empty.\r\n\r\n     * @Null_Argument_Exception if {@code column_data} is {@code null}.\r\n\r\n     */\r\n\r\n    static <T extends Field_Element<T>> Field_Matrix<T>\r\n\r\n        createColumnField_Matrix(const std::vector<T> column_data)\r\n\r\n    {\r\n\r\n        if (column_data == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        const int& n_rows = column_data.size();\r\n\r\n        if (n_rows == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.AT_LEAST_ONE_ROW);\r\n\r\n        }\r\n\r\n        const Field_Matrix<T> m = create_field_matrix(column_data[0].get_field(), n_rows, 1);\r\n\r\n        for (int i{}; i < n_rows; ++i) \r\n\r\n        {\r\n\r\n            m.set_entry(i, 0, column_data[i]);\r\n\r\n        }\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    \r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether a matrix is symmetric.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to check.\r\n\r\n     * @param eps Relative tolerance.\r\n\r\n     * @ if the matrix is not square.\r\n\r\n     * @ if the matrix is not symmetric.\r\n\r\n     */\r\n\r\n    static void checkSymmetric(Real_Matrix matrix, double eps) \r\n\r\n    {\r\n\r\n        is_symmetricInternal(matrix, eps, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether a matrix is symmetric.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to check.\r\n\r\n     * @param eps Relative tolerance.\r\n\r\n     * @return {@code true} if {@code matrix} is symmetric.\r\n\r\n     */\r\n\r\n    static bool is_symmetric(Real_Matrix matrix, double eps) \r\n\r\n    {\r\n\r\n        return is_symmetricInternal(matrix, eps, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrix indices are valid.\r\n\r\n     *\r\n\r\n     * @param m Matrix.\r\n\r\n     * @param row Row index to check.\r\n\r\n     * @param column Column index to check.\r\n\r\n     * @ if {@code row} or {@code column} is not\r\n\r\n     * a valid index.\r\n\r\n     */\r\n\r\n    static void check_matrix_index(const Any_Matrix m, const int& row, const int column)\r\n\r\n    {\r\n\r\n        check_row_index(m, row);\r\n\r\n        check_column_index(m, column);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if a row index is valid.\r\n\r\n     *\r\n\r\n     * @param m Matrix.\r\n\r\n     * @param row Row index to check.\r\n\r\n     * @ if {@code row} is not a valid index.\r\n\r\n     */\r\n\r\n    public static void check_row_index(const Any_Matrix m, const int row)\r\n\r\n    {\r\n\r\n        if (row < 0 || row >= m.get_row_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.ROW_INDEX, row, 0, m.get_row_dimension() - 1);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if a column index is valid.\r\n\r\n     *\r\n\r\n     * @param m Matrix.\r\n\r\n     * @param column Column index to check.\r\n\r\n     * @ if {@code column} is not a valid index.\r\n\r\n     */\r\n\r\n    static void check_column_index(const Any_Matrix m, const int column)\r\n\r\n    {\r\n\r\n        if (column < 0 || column >= m.get_column_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.COLUMN_INDEX, column, 0, m.get_column_dimension() - 1);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if submatrix ranges indices are valid.\r\n\r\n     * Rows and columns are indicated counting from 0 to {@code n - 1}.\r\n\r\n     *\r\n\r\n     * @param m Matrix.\r\n\r\n     * @param start_row Initial row index.\r\n\r\n     * @param end_row Final row index.\r\n\r\n     * @param start_column Initial column index.\r\n\r\n     * @param end_column Final column index.\r\n\r\n     * @ if the indices are invalid.\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     */\r\n\r\n    static void check_sub_matrix_index(const Any_Matrix m, const int& start_row, const int& end_row, const int& start_column, const int& end_column)\r\n\r\n    {\r\n\r\n        check_row_index(m, start_row);\r\n\r\n        check_row_index(m, end_row);\r\n\r\n        if (end_row < start_row) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INITIAL_ROW_AFTER_FINAL_ROW, end_row, start_row, false);\r\n\r\n        }\r\n\r\n\r\n\r\n        check_column_index(m, start_column);\r\n\r\n        check_column_index(m, end_column);\r\n\r\n        if (end_column < start_column) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.INITIAL_COLUMN_AFTER_FINAL_COLUMN, end_column, start_column, false);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if submatrix ranges indices are valid.\r\n\r\n     * Rows and columns are indicated counting from 0 to n-1.\r\n\r\n     *\r\n\r\n     * @param m Matrix.\r\n\r\n     * @param selected_rows Array of row indices.\r\n\r\n     * @param selected_columns Array of column indices.\r\n\r\n     * @Null_Argument_Exception if {@code selected_rows} or\r\n\r\n     * {@code selected_columns} are {@code null}.\r\n\r\n     * @ if the row or column selections are empty (zero\r\n\r\n     * length).\r\n\r\n     * @ if row or column selections are not valid.\r\n\r\n     */\r\n\r\n    static void check_sub_matrix_index(const Any_Matrix m, const std::vector<int> selected_rows, const std::vector<int> selected_columns)\r\n\r\n    {\r\n\r\n        if (selected_rows == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        if (selected_columns == null) \r\n\r\n        {\r\n\r\n            throw Null_Argument_Exception();\r\n\r\n        }\r\n\r\n        if (selected_rows.size() == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\r\n\r\n        }\r\n\r\n        if (selected_columns.size() == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\r\n\r\n        }\r\n\r\n\r\n\r\n        for (const int row : selected_rows) \r\n\r\n        {\r\n\r\n            check_row_index(m, row);\r\n\r\n        }\r\n\r\n        for (const int column : selected_columns) \r\n\r\n        {\r\n\r\n            check_column_index(m, column);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrices are addition compatible.\r\n\r\n     *\r\n\r\n     * @param left Left hand side matrix.\r\n\r\n     * @param right Right hand side matrix.\r\n\r\n     * @ if the matrices are not addition\r\n\r\n     * compatible.\r\n\r\n     */\r\n\r\n    static void check_addition_compatible(const Any_Matrix left, const Any_Matrix right)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if ((left.get_row_dimension()    != right.get_row_dimension()) ||\r\n\r\n            (left.get_column_dimension() != right.get_column_dimension())) \r\n\r\n            {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH_2x2, left.get_row_dimension(), left.get_column_dimension(), right.get_row_dimension(), right.get_column_dimension());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrices are subtraction compatible\r\n\r\n     *\r\n\r\n     * @param left Left hand side matrix.\r\n\r\n     * @param right Right hand side matrix.\r\n\r\n     * @ if the matrices are not addition\r\n\r\n     * compatible.\r\n\r\n     */\r\n\r\n    static void check_subtraction_compatible(const Any_Matrix left, const Any_Matrix right)\r\n\r\n    {\r\n\r\n        if ((left.get_row_dimension()    != right.get_row_dimension()) ||\r\n\r\n            (left.get_column_dimension() != right.get_column_dimension())) \r\n\r\n            {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH_2x2, left.get_row_dimension(), left.get_column_dimension(), right.get_row_dimension(), right.get_column_dimension());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrices are multiplication compatible\r\n\r\n     *\r\n\r\n     * @param left Left hand side matrix.\r\n\r\n     * @param right Right hand side matrix.\r\n\r\n     * @ if matrices are not multiplication\r\n\r\n     * compatible.\r\n\r\n     */\r\n\r\n    static void check_multiplication_compatible(const Any_Matrix left, const Any_Matrix right)\r\n\r\n    {\r\n\r\n        if (left.get_column_dimension() != right.get_row_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, left.get_column_dimension(), right.get_row_dimension());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrices have the same number of columns.\r\n\r\n     *\r\n\r\n     * @param left Left hand side matrix.\r\n\r\n     * @param right Right hand side matrix.\r\n\r\n     * @ if matrices don't have the same number of columns.\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    static void check_same_column_dimension(const Any_Matrix left, const Any_Matrix right)\r\n\r\n    {\r\n\r\n        if (left.get_column_dimension() != right.get_column_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, left.get_column_dimension(), right.get_column_dimension());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check if matrices have the same number of rows.\r\n\r\n     *\r\n\r\n     * @param left Left hand side matrix.\r\n\r\n     * @param right Right hand side matrix.\r\n\r\n     * @ if matrices don't have the same number of rows.\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    static void check_same_row_dimension(const Any_Matrix left, const Any_Matrix right)\r\n\r\n    {\r\n\r\n        if (left.get_row_dimension() != right.get_row_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, left.get_row_dimension(), right.get_row_dimension());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Convert a {@link Field_Matrix}/{@link Fraction} matrix to a {@link Real_Matrix}.\r\n\r\n     * @param m Matrix to convert.\r\n\r\n     * @return the converted matrix.\r\n\r\n     */\r\n\r\n    static Array_2D_Row_Real_Matrix fractionMatrixToReal_Matrix(const Field_Matrix<Fraction> m) \r\n\r\n    {\r\n\r\n        const FractionMatrix_converter converter = FractionMatrix_converter();\r\n\r\n        m.walk_in_optimized_order(converter);\r\n\r\n        return converter.get_convertedMatrix();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //----------------------------------------------\r\n\r\n    \r\n\r\n    /** Converter for {@link Field_Matrix}/{@link Fraction}. */\r\n\r\n    private static class FractionMatrix_converter extends DefaultField_Matrix_Preserving_Visitor<Fraction> \r\n\r\n    {\r\n\r\n        /** Converted array. */\r\n\r\n        private std::vector<std::vector<double>> data;\r\n\r\n        /** Simple constructor. */\r\n\r\n        FractionMatrix_converter() \r\n\r\n        {\r\n\r\n            super(Fraction.ZERO);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void start(const int& rows, int columns, int start_row, int end_row, int start_column, int end_column) \r\n\r\n        {\r\n\r\n            data = std::vector<double>(rows][columns];\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void visit(const int& row, const int& column, Fraction value) \r\n\r\n        {\r\n\r\n            data[row][column] = value.double_value();\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the converted matrix.\r\n\r\n         *\r\n\r\n         * @return the converted matrix.\r\n\r\n         */\r\n\r\n        Array_2D_Row_Real_Matrix get_convertedMatrix() \r\n\r\n        {\r\n\r\n            return Array_2D_Row_Real_Matrix(data, false);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Convert a {@link Field_Matrix}/{@link Big_Fraction} matrix to a {@link Real_Matrix}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to convert.\r\n\r\n     * @return the converted matrix.\r\n\r\n     */\r\n\r\n    public static Array_2D_Row_Real_Matrix big_fraction_matrix_to_real__matrix(const Field_Matrix<Big_Fraction> m) \r\n\r\n    {\r\n\r\n        const Big_FractionMatrix_converter converter = Big_FractionMatrix_converter();\r\n\r\n        m.walk_in_optimized_order(converter);\r\n\r\n        return converter.get_convertedMatrix();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Converter for {@link Field_Matrix}/{@link Big_Fraction}. */\r\n\r\n    private static class Big_FractionMatrix_converter extends DefaultField_Matrix_Preserving_Visitor<Big_Fraction> \r\n\r\n    {\r\n\r\n        /** Converted array. */\r\n\r\n        private std::vector<std::vector<double>> data;\r\n\r\n        /** Simple constructor. */\r\n\r\n        Big_FractionMatrix_converter() \r\n\r\n        {\r\n\r\n            super(Big_Fraction.ZERO);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void start(const int& rows, int columns, int start_row, int end_row, int start_column, int end_column) \r\n\r\n        {\r\n\r\n            data = std::vector<double>(rows][columns];\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void visit(const int& row, const int& column, Big_Fraction value) \r\n\r\n        {\r\n\r\n            data[row][column] = value.double_value();\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the converted matrix.\r\n\r\n         *\r\n\r\n         * @return the converted matrix.\r\n\r\n         */\r\n\r\n        Array_2D_Row_Real_Matrix get_convertedMatrix() \r\n\r\n        {\r\n\r\n            return Array_2D_Row_Real_Matrix(data, false);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Serialize a {@link Real_Vector}.\r\n\r\n     * <p>\r\n\r\n     * This method is intended to be called from within a private\r\n\r\n     * <code>write_object</code> method (after a call to\r\n\r\n     * <code>oos.default_write_object()</code>) in a class that has a\r\n\r\n     * {@link Real_Vector} field, which should be declared <code>transient</code>.\r\n\r\n     * This way, the default handling does not serialize the vector (the {@link\r\n\r\n     * Real_Vector} interface is not serializable by default) but this method does\r\n\r\n     * serialize it specifically.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * The following example shows how a simple class with a name and a real vector\r\n\r\n     * should be written:\r\n\r\n     * <pre><code>\r\n\r\n     * class NamedVector  \r\n\r\n     {\r\n\r\n     *\r\n\r\n     *     private const std::string name;\r\n\r\n     *     private const Real_Vector coefficients;\r\n\r\n     *\r\n\r\n     *     // omitted constructors, getters ...\r\n\r\n     *\r\n\r\n     *     private void write_object(Object_Output_Stream oos) IOException \r\n\r\n     {\r\n\r\n     *         oos.default_write_object();  // takes care of name field\r\n\r\n     *         Matrix_Utils.serialize_real__vector(coefficients, oos);\r\n\r\n     *     }\r\n\r\n     *\r\n\r\n     *     private void read_object(Object_Input_Stream ois) Class_Not_Found_Exception, IOException \r\n\r\n     {\r\n\r\n     *         ois.default_read_object();  // takes care of name field\r\n\r\n     *         Matrix_Utils.deserialize_real__vector(this, "coefficients", ois);\r\n\r\n     *     }\r\n\r\n     *\r\n\r\n     * }\r\n\r\n     * </code></pre>\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param vector real vector to serialize\r\n\r\n     * @param oos stream where the real vector should be written\r\n\r\n     * @exception IOException if object cannot be written to stream\r\n\r\n     * @see #deserialize_real__vector(Object, std::string, Object_Input_Stream)\r\n\r\n     */\r\n\r\n    public static void serialize_real__vector(const Real_Vector vector, const Object_Output_Stream oos)\r\n\r\n        IOException \r\n\r\n        {\r\n\r\n        const int n = vector.get_dimension();\r\n\r\n        oos.writeInt(n);\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n            oos.writeDouble(vector.get_entry(i));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Deserialize  a {@link Real_Vector} field in a class.\r\n\r\n     * <p>\r\n\r\n     * This method is intended to be called from within a private\r\n\r\n     * <code>read_object</code> method (after a call to\r\n\r\n     * <code>ois.default_read_object()</code>) in a class that has a\r\n\r\n     * {@link Real_Vector} field, which should be declared <code>transient</code>.\r\n\r\n     * This way, the default handling does not deserialize the vector (the {@link\r\n\r\n     * Real_Vector} interface is not serializable by default) but this method does\r\n\r\n     * deserialize it specifically.\r\n\r\n     * </p>\r\n\r\n     * @param instance instance in which the field must be set up\r\n\r\n     * @param fieldName name of the field within the class (may be private and const)\r\n\r\n     * @param ois stream from which the real vector should be read\r\n\r\n     * @exception Class_Not_Found_Exception if a class in the stream cannot be found\r\n\r\n     * @exception IOException if object cannot be read from the stream\r\n\r\n     * @see #serialize_real__vector(Real_Vector, Object_Output_Stream)\r\n\r\n     */\r\n\r\n    public static void deserialize_real__vector(const Object instance, const std::string fieldName, const Object_Input_Stream ois)\r\n\r\n      Class_Not_Found_Exception, IOException \r\n\r\n      {\r\n\r\n        try \r\n\r\n        {\r\n\r\n\r\n\r\n            // read the vector data\r\n\r\n            const int n = ois.readInt();\r\n\r\n            const std::vector<double> data = std::vector<double>(n];\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                data[i] = ois.readDouble();\r\n\r\n            }\r\n\r\n\r\n\r\n            // create the instance\r\n\r\n            const Real_Vector vector = Array_Real_Vector(data, false);\r\n\r\n\r\n\r\n            // set up the field\r\n\r\n            const java.lang.reflect.Field f =\r\n\r\n                instance.get_class().get_declaredField(fieldName);\r\n\r\n            f.set_accessible(true);\r\n\r\n            f.set(instance, vector);\r\n\r\n\r\n\r\n        }\r\n\r\n        catch (NoSuchFieldException | Illegal_Access_Exception e) \r\n\r\n        {\r\n\r\n            IOException ioe = IOException();\r\n\r\n            ioe.initCause(e);\r\n\r\n            throw ioe;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Serialize a {@link Real_Matrix}.\r\n\r\n     * <p>\r\n\r\n     * This method is intended to be called from within a private\r\n\r\n     * <code>write_object</code> method (after a call to\r\n\r\n     * <code>oos.default_write_object()</code>) in a class that has a\r\n\r\n     * {@link Real_Matrix} field, which should be declared <code>transient</code>.\r\n\r\n     * This way, the default handling does not serialize the matrix (the {@link\r\n\r\n     * Real_Matrix} interface is not serializable by default) but this method does\r\n\r\n     * serialize it specifically.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * The following example shows how a simple class with a name and a real matrix\r\n\r\n     * should be written:\r\n\r\n     * <pre><code>\r\n\r\n     * class NamedMatrix  \r\n\r\n     {\r\n\r\n     *\r\n\r\n     *     private const std::string name;\r\n\r\n     *     private const Real_Matrix coefficients;\r\n\r\n     *\r\n\r\n     *     // omitted constructors, getters ...\r\n\r\n     *\r\n\r\n     *     private void write_object(Object_Output_Stream oos) IOException \r\n\r\n     {\r\n\r\n     *         oos.default_write_object();  // takes care of name field\r\n\r\n     *         Matrix_Utils.serialize_real__matrix(coefficients, oos);\r\n\r\n     *     }\r\n\r\n     *\r\n\r\n     *     private void read_object(Object_Input_Stream ois) Class_Not_Found_Exception, IOException \r\n\r\n     {\r\n\r\n     *         ois.default_read_object();  // takes care of name field\r\n\r\n     *         Matrix_Utils.deserialize_real__matrix(this, "coefficients", ois);\r\n\r\n     *     }\r\n\r\n     *\r\n\r\n     * }\r\n\r\n     * </code></pre>\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param matrix real matrix to serialize\r\n\r\n     * @param oos stream where the real matrix should be written\r\n\r\n     * @exception IOException if object cannot be written to stream\r\n\r\n     * @see #deserialize_real__matrix(Object, std::string, Object_Input_Stream)\r\n\r\n     */\r\n\r\n    public static void serialize_real__matrix(const Real_Matrix matrix, const Object_Output_Stream oos)\r\n\r\n        IOException \r\n\r\n        {\r\n\r\n        const int n = matrix.get_row_dimension();\r\n\r\n        const int m = matrix.get_column_dimension();\r\n\r\n        oos.writeInt(n);\r\n\r\n        oos.writeInt(m);\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n            for (int j{}; j < m; ++j) \r\n\r\n            {\r\n\r\n                oos.writeDouble(matrix.get_entry(i, j));\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Deserialize  a {@link Real_Matrix} field in a class.\r\n\r\n     * <p>\r\n\r\n     * This method is intended to be called from within a private\r\n\r\n     * <code>read_object</code> method (after a call to\r\n\r\n     * <code>ois.default_read_object()</code>) in a class that has a\r\n\r\n     * {@link Real_Matrix} field, which should be declared <code>transient</code>.\r\n\r\n     * This way, the default handling does not deserialize the matrix (the {@link\r\n\r\n     * Real_Matrix} interface is not serializable by default) but this method does\r\n\r\n     * deserialize it specifically.\r\n\r\n     * </p>\r\n\r\n     * @param instance instance in which the field must be set up\r\n\r\n     * @param fieldName name of the field within the class (may be private and const)\r\n\r\n     * @param ois stream from which the real matrix should be read\r\n\r\n     * @exception Class_Not_Found_Exception if a class in the stream cannot be found\r\n\r\n     * @exception IOException if object cannot be read from the stream\r\n\r\n     * @see #serialize_real__matrix(Real_Matrix, Object_Output_Stream)\r\n\r\n     */\r\n\r\n    public static void deserialize_real__matrix(const Object instance, const std::string fieldName, const Object_Input_Stream ois)\r\n\r\n      Class_Not_Found_Exception, IOException \r\n\r\n      {\r\n\r\n        try \r\n\r\n        {\r\n\r\n\r\n\r\n            // read the matrix data\r\n\r\n            const int n = ois.readInt();\r\n\r\n            const int m = ois.readInt();\r\n\r\n            const std::vector<std::vector<double>> data = std::vector<double>(n][m];\r\n\r\n            for (int i{}; i < n; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<double> data_i = data[i];\r\n\r\n                for (int j{}; j < m; ++j) \r\n\r\n                {\r\n\r\n                    data_i[j] = ois.readDouble();\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // create the instance\r\n\r\n            const Real_Matrix matrix = Array_2D_Row_Real_Matrix(data, false);\r\n\r\n\r\n\r\n            // set up the field\r\n\r\n            const java.lang.reflect.Field f =\r\n\r\n                instance.get_class().get_declaredField(fieldName);\r\n\r\n            f.set_accessible(true);\r\n\r\n            f.set(instance, matrix);\r\n\r\n\r\n\r\n        }\r\n\r\n        catch (NoSuchFieldException | Illegal_Access_Exception e) \r\n\r\n        {\r\n\r\n            IOException ioe = IOException();\r\n\r\n            ioe.initCause(e);\r\n\r\n            throw ioe;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**Solve  a  system of composed of a Lower Triangular Matrix\r\n\r\n     * {@link Real_Matrix}.\r\n\r\n     * <p>\r\n\r\n     * This method is called to solve systems of equations which are\r\n\r\n     * of the lower triangular form. The matrix {@link Real_Matrix}\r\n\r\n     * is assumed, though not checked, to be in lower triangular form.\r\n\r\n     * The vector {@link Real_Vector} is overwritten with the solution.\r\n\r\n     * The matrix is checked that it is square and its dimensions match\r\n\r\n     * the length of the vector.\r\n\r\n     * </p>\r\n\r\n     * @param rm Real_Matrix which is lower triangular\r\n\r\n     * @param b  Real_Vector this is overwritten\r\n\r\n     * @ if the matrix and vector are not\r\n\r\n     * conformable\r\n\r\n     * @ if the matrix {@code rm} is not square\r\n\r\n     * @Math_Runtime_Exception if the absolute value of one of the diagonal\r\n\r\n     * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}\r\n\r\n     */\r\n\r\n    public static void solve_uower_triangular_system(Real_Matrix rm, Real_Vector b)\r\n\r\n        , Math_Runtime_Exception \r\n\r\n        {\r\n\r\n        if ((rm == null) || (b == null) || ( rm.get_row_dimension() != b.get_dimension())) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, (rm == null) ? 0 : rm.get_row_dimension(), (b  == null) ? 0 : b.get_dimension());\r\n\r\n        }\r\n\r\n        if( rm.get_column_dimension() != rm.get_row_dimension() )\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, rm.get_row_dimension(), rm.get_column_dimension());\r\n\r\n        }\r\n\r\n        int rows = rm.get_row_dimension();\r\n\r\n        for( int i{}; i < rows ; i++ )\r\n\r\n        {\r\n\r\n            double diag = rm.get_entry(i, i);\r\n\r\n            if( std::abs(diag) < Precision.SAFE_MIN )\r\n\r\n            {\r\n\r\n                throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n            }\r\n\r\n            double bi = b.get_entry(i)/diag;\r\n\r\n            b.set_entry(i,  bi );\r\n\r\n            for( int j = i+1; j< rows; j++ )\r\n\r\n            {\r\n\r\n                b.set_entry(j, b.get_entry(j)-bi*rm.get_entry(j,i)  );\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Solver a  system composed  of an Upper Triangular Matrix\r\n\r\n     * {@link Real_Matrix}.\r\n\r\n     * <p>\r\n\r\n     * This method is called to solve systems of equations which are\r\n\r\n     * of the lower triangular form. The matrix {@link Real_Matrix}\r\n\r\n     * is assumed, though not checked, to be in upper triangular form.\r\n\r\n     * The vector {@link Real_Vector} is overwritten with the solution.\r\n\r\n     * The matrix is checked that it is square and its dimensions match\r\n\r\n     * the length of the vector.\r\n\r\n     * </p>\r\n\r\n     * @param rm Real_Matrix which is upper triangular\r\n\r\n     * @param b  Real_Vector this is overwritten\r\n\r\n     * @ if the matrix and vector are not\r\n\r\n     * conformable\r\n\r\n     * @ if the matrix {@code rm} is not\r\n\r\n     * square\r\n\r\n     * @Math_Runtime_Exception if the absolute value of one of the diagonal\r\n\r\n     * coefficient of {@code rm} is lower than {@link Precision#SAFE_MIN}\r\n\r\n     */\r\n\r\n    public static void solve_upper_triangular_system(Real_Matrix rm, Real_Vector b)\r\n\r\n        , Math_Runtime_Exception \r\n\r\n        {\r\n\r\n        if ((rm == null) || (b == null) || ( rm.get_row_dimension() != b.get_dimension())) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, (rm == null) ? 0 : rm.get_row_dimension(), (b  == null) ? 0 : b.get_dimension());\r\n\r\n        }\r\n\r\n        if( rm.get_column_dimension() != rm.get_row_dimension() )\r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, rm.get_row_dimension(), rm.get_column_dimension());\r\n\r\n        }\r\n\r\n        int rows = rm.get_row_dimension();\r\n\r\n        for( int i = rows-1 ; i >-1 ; i-- )\r\n\r\n        {\r\n\r\n            double diag = rm.get_entry(i, i);\r\n\r\n            if( std::abs(diag) < Precision.SAFE_MIN )\r\n\r\n            {\r\n\r\n                throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_DENOMINATOR);\r\n\r\n            }\r\n\r\n            double bi = b.get_entry(i)/diag;\r\n\r\n            b.set_entry(i,  bi );\r\n\r\n            for( int j = i-1; j>-1; j-- )\r\n\r\n            {\r\n\r\n                b.set_entry(j, b.get_entry(j)-bi*rm.get_entry(j,i)  );\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the inverse of the given matrix by splitting it into\r\n\r\n     * 4 sub-matrices.\r\n\r\n     *\r\n\r\n     * @param m Matrix whose inverse must be computed.\r\n\r\n     * @param splitIndex Index that determines the "split" line and\r\n\r\n     * column.\r\n\r\n     * The element corresponding to this index will part of the\r\n\r\n     * upper-left sub-matrix.\r\n\r\n     * @return the inverse of {@code m}.\r\n\r\n     * @ if {@code m} is not square.\r\n\r\n     */\r\n\r\n    public static Real_Matrix blockInverse(Real_Matrix m, int splitIndex) \r\n\r\n    {\r\n\r\n        const int n = m.get_row_dimension();\r\n\r\n        if (m.get_column_dimension() != n) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, m.get_row_dimension(), m.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int splitIndex1 = splitIndex + 1;\r\n\r\n\r\n\r\n        const Real_Matrix& a = m.get_sub_matrix(0, splitIndex, 0, splitIndex);\r\n\r\n        const Real_Matrix b = m.get_sub_matrix(0, splitIndex, splitIndex1, n - 1);\r\n\r\n        const Real_Matrix c = m.get_sub_matrix(splitIndex1, n - 1, 0, splitIndex);\r\n\r\n        const Real_Matrix d = m.get_sub_matrix(splitIndex1, n - 1, splitIndex1, n - 1);\r\n\r\n\r\n\r\n        const Singular_Value_Decomposition aDec = Singular_Value_Decomposition(a);\r\n\r\n        const Decomposition_Solver aSolver = aDec.get_solver();\r\n\r\n        if (!aSolver.is_non_singular()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n        }\r\n\r\n        const Real_Matrix& aInv = aSolver.get_inverse();\r\n\r\n\r\n\r\n        const Singular_Value_Decomposition dDec = Singular_Value_Decomposition(d);\r\n\r\n        const Decomposition_Solver dSolver = dDec.get_solver();\r\n\r\n        if (!dSolver.is_non_singular()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n        }\r\n\r\n        const Real_Matrix dInv = dSolver.get_inverse();\r\n\r\n\r\n\r\n        const Real_Matrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\r\n\r\n        const Singular_Value_Decomposition tmp1Dec = Singular_Value_Decomposition(tmp1);\r\n\r\n        const Decomposition_Solver tmp1Solver = tmp1Dec.get_solver();\r\n\r\n        if (!tmp1Solver.is_non_singular()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n        }\r\n\r\n        const Real_Matrix result00 = tmp1Solver.get_inverse();\r\n\r\n\r\n\r\n        const Real_Matrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\r\n\r\n        const Singular_Value_Decomposition tmp2_dec = Singular_Value_Decomposition(tmp2);\r\n\r\n        const Decomposition_Solver tmp2Solver = tmp2_dec.get_solver();\r\n\r\n        if (!tmp2Solver.is_non_singular()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n        }\r\n\r\n        const Real_Matrix result11 = tmp2Solver.get_inverse();\r\n\r\n\r\n\r\n        const Real_Matrix result01 = aInv.multiply(b).multiply(result11).scalar_multiply(-1);\r\n\r\n        const Real_Matrix result10 = dInv.multiply(c).multiply(result00).scalar_multiply(-1);\r\n\r\n\r\n\r\n        const Real_Matrix result = Array_2D_Row_Real_Matrix(n, n);\r\n\r\n        result.set_sub_matrix(result00.get_data(), 0, 0);\r\n\r\n        result.set_sub_matrix(result01.get_data(), 0, splitIndex1);\r\n\r\n        result.set_sub_matrix(result10.get_data(), splitIndex1, 0);\r\n\r\n        result.set_sub_matrix(result11.get_data(), splitIndex1, splitIndex1);\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the inverse of the given matrix.\r\n\r\n     * <p>\r\n\r\n     * By default, the inverse of the matrix is computed using the QR-decomposition, * unless a more efficient method can be determined for the input matrix.\r\n\r\n     * <p>\r\n\r\n     * Note: this method will use a singularity threshold of 0, * use {@link #inverse(Real_Matrix, double)} if a different threshold is needed.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix whose inverse shall be computed\r\n\r\n     * @return the inverse of {@code matrix}\r\n\r\n     * @Null_Argument_Exception if {@code matrix} is {@code null}\r\n\r\n     * @ if m is singular\r\n\r\n     * @ if matrix is not square\r\n\r\n     */\r\n\r\n    public static Real_Matrix inverse(Real_Matrix matrix)\r\n\r\n            , Null_Argument_Exception \r\n\r\n            {\r\n\r\n        return inverse(matrix, 0);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the inverse of the given matrix.\r\n\r\n     * <p>\r\n\r\n     * By default, the inverse of the matrix is computed using the QR-decomposition, * unless a more efficient method can be determined for the input matrix.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix whose inverse shall be computed\r\n\r\n     * @param threshold Singularity threshold\r\n\r\n     * @return the inverse of {@code m}\r\n\r\n     * @Null_Argument_Exception if {@code matrix} is {@code null}\r\n\r\n     * @ if matrix is singular\r\n\r\n     * @ if matrix is not square\r\n\r\n     */\r\n\r\n    public static Real_Matrix inverse(Real_Matrix matrix, double threshold)\r\n\r\n            , Null_Argument_Exception \r\n\r\n            {\r\n\r\n\r\n\r\n        //Math_Utils::check_not_null(matrix);\r\n\r\n\r\n\r\n        if (!matrix.is_square()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, matrix.get_row_dimension(), matrix.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (matrix instanceof Diagonal_Matrix) \r\n\r\n        {\r\n\r\n            return ((Diagonal_Matrix) matrix).inverse(threshold);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            QR_Decomposition decomposition = QR_Decomposition(matrix, threshold);\r\n\r\n            return decomposition.get_solver().get_inverse();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the <a href="https://mathworld.wolfram.com/MatrixExponential.html">\r\n\r\n     * matrix exponential</a> of the given matrix.\r\n\r\n     *\r\n\r\n     * The algorithm implementation follows the Pade approximant method of\r\n\r\n     * <p>Higham, Nicholas J. \xe2\x80\x9cThe Scaling and Squaring Method for the Matrix Exponential\r\n\r\n     * Revisited.\xe2\x80\x9d SIAM Journal on Matrix Analysis and Applications 26, no. 4 (January 2005): 1179\xe2\x80\x9393.</p>\r\n\r\n     *\r\n\r\n     * @param rm Real_Matrix whose inverse shall be computed\r\n\r\n     * @return The inverse of {@code rm}\r\n\r\n     * @ if matrix is not square\r\n\r\n     */\r\n\r\n    public static Real_Matrix matrixExponential(const Real_Matrix rm) \r\n\r\n    {\r\n\r\n\r\n\r\n        // Check that the input matrix is square\r\n\r\n        if (!rm.is_square()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, rm.get_row_dimension(), rm.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        // Preprocessing to reduce the norm\r\n\r\n        int dim = rm.get_row_dimension();\r\n\r\n        const Real_Matrix identity = Matrix_Utils.create_real_identity_matrix(dim);\r\n\r\n        const double preprocessScale = rm.get_trace() / dim;\r\n\r\n        Real_Matrix scaledMatrix = rm.copy();\r\n\r\n        scaledMatrix = scaledMatrix.subtract(identity.scalar_multiply(preprocessScale));\r\n\r\n\r\n\r\n        // Select pade degree required\r\n\r\n        const double l1Norm = rm.get_norm1();\r\n\r\n        std::vector<double> padeCoefficients;\r\n\r\n        int squaringCount = 0;\r\n\r\n\r\n\r\n        if (l1Norm < 1.495585217958292e-2) \r\n\r\n        {\r\n\r\n            padeCoefficients = PADE_COEFFICIENTS_3;\r\n\r\n        }\r\n\r\nelse if (l1Norm < 2.539398330063230e-1) \r\n\r\n        {\r\n\r\n            padeCoefficients = PADE_COEFFICIENTS_5;\r\n\r\n        }\r\n\r\nelse if (l1Norm < 9.504178996162932e-1) \r\n\r\n        {\r\n\r\n            padeCoefficients = PADE_COEFFICIENTS_7;\r\n\r\n        }\r\n\r\nelse if (l1Norm < 2.097847961257068) \r\n\r\n        {\r\n\r\n            padeCoefficients = PADE_COEFFICIENTS_9;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            padeCoefficients = PADE_COEFFICIENTS_13;\r\n\r\n\r\n\r\n            // Calculate scaling factor\r\n\r\n            const double normScale = 5.371920351148152;\r\n\r\n            squaringCount = Math.max(0, Math.get_exponent(l1Norm / normScale));\r\n\r\n\r\n\r\n            // Scale matrix by power of 2\r\n\r\n            const int const_squaring_count = squaringCount;\r\n\r\n            scaledMatrix.walk_in_optimized_order(new Default_Real_Matrix_Changing_Visitor() \r\n\r\n            {\r\n\r\n                //override\r\n\r\n                public double visit(const int& row, const int& column, double value) \r\n\r\n                {\r\n\r\n                    return Math.scalb(value, -const_squaring_count);\r\n\r\n                }\r\n\r\n            });\r\n\r\n        }\r\n\r\n\r\n\r\n        // Calculate U and V using Horner\r\n\r\n        // See Golub, Gene H., and Charles F. van Loan. Matrix Computations. 4th ed.\r\n\r\n        // John Hopkins University Press, 2013.  pages 530/531\r\n\r\n        const Real_Matrix scaledMatrix2 = scaledMatrix.multiply(scaledMatrix);\r\n\r\n        const int coeffLength = padeCoefficients.size();\r\n\r\n\r\n\r\n        // Calculate V\r\n\r\n        Real_Matrix padeV = Matrix_Utils.create_real_matrix(dim, dim);\r\n\r\n        for (int i = coeffLength - 1; i > 1; i -= 2) \r\n\r\n        {\r\n\r\n            padeV = scaledMatrix2.multiply(padeV.add(identity.scalar_multiply(padeCoefficients[i])));\r\n\r\n        }\r\n\r\n        padeV = scaledMatrix.multiply(padeV.add(identity.scalar_multiply(padeCoefficients[1])));\r\n\r\n\r\n\r\n        // Calculate U\r\n\r\n        Real_Matrix padeU = Matrix_Utils.create_real_matrix(dim, dim);\r\n\r\n        for (int i = coeffLength - 2; i > 1; i -= 2) \r\n\r\n        {\r\n\r\n            padeU = scaledMatrix2.multiply(padeU.add(identity.scalar_multiply(padeCoefficients[i])));\r\n\r\n        }\r\n\r\n        padeU = padeU.add(identity.scalar_multiply(padeCoefficients[0]));\r\n\r\n\r\n\r\n        // Calculate pade approximate by solving (U-V) F = (U+V) for F\r\n\r\n        Real_Matrix padeNumer = padeU.add(padeV);\r\n\r\n        Real_Matrix padeDenom = padeU.subtract(padeV);\r\n\r\n\r\n\r\n        // Calculate the matrix ratio\r\n\r\n        QR_Decomposition decomposition = QR_Decomposition(padeDenom);\r\n\r\n        Real_Matrix result = decomposition.get_solver().solve(padeNumer);\r\n\r\n\r\n\r\n        // Repeated squaring if matrix was scaled\r\n\r\n        for (int i{}; i < squaringCount; i++) \r\n\r\n        {\r\n\r\n            result = result.multiply(result);\r\n\r\n        }\r\n\r\n\r\n\r\n        // Undo preprocessing\r\n\r\n        result = result.scalar_multiply(Math.exp(preprocessScale));\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Orthonormalize a list of vectors.\r\n\r\n     * <p>\r\n\r\n     * Orthonormalization is performed by using the Modified Gram-Schmidt process.\r\n\r\n     * </p>\r\n\r\n     * @param independent list of independent vectors\r\n\r\n     * @param threshold projected vectors with a norm less than or equal to this threshold\r\n\r\n     * are considered to have zero norm, hence the vectors they come from are not independent from\r\n\r\n     * previous vectors\r\n\r\n     * @param handler handler for dependent vectors\r\n\r\n     * @return orthonormal basis having the same span as {@code independent}\r\n\r\n     * @since 2.1\r\n\r\n     */\r\n\r\n    public static List<Real_Vector> orthonormalize(const List<Real_Vector> independent, const double threshold, const Dependent_Vectors_Handler handler) \r\n\r\n    {\r\n\r\n\r\n\r\n        // create separate list\r\n\r\n        const List<Real_Vector> basis = Array_list<>(independent);\r\n\r\n\r\n\r\n        // loop over basis vectors\r\n\r\n        int index = 0;\r\n\r\n        while (index < basis.size()) \r\n\r\n        {\r\n\r\n\r\n\r\n            // check dependency\r\n\r\n            const Real_Vector vi = basis.get(index);\r\n\r\n            const double norm = vi.get_norm();\r\n\r\n            if (norm <= threshold) \r\n\r\n            {\r\n\r\n                // the current vector is dependent from the previous ones\r\n\r\n                index = handler.manage_dependent(index, basis);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n\r\n\r\n                // normalize basis vector in place\r\n\r\n                vi.map_divide_to_self(vi.get_norm());\r\n\r\n\r\n\r\n                // project remaining vectors in place\r\n\r\n                for (int j = index + 1; j < basis.size(); ++j) \r\n\r\n                {\r\n\r\n                    const Real_Vector vj  = basis.get(j);\r\n\r\n                    const double     dot = vi.dot_product(vj);\r\n\r\n                    for (int k{}; k < vj.get_dimension(); ++k) \r\n\r\n                    {\r\n\r\n                        vj.set_entry(k, vj.get_entry(k) - dot * vi.get_entry(k));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                ++index;\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return basis;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Orthonormalize a list of vectors.\r\n\r\n     * <p>\r\n\r\n     * Orthonormalization is performed by using the Modified Gram-Schmidt process.\r\n\r\n     * </p>\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @param independent list of independent vectors\r\n\r\n     * @param threshold projected vectors with a norm less than or equal to this threshold\r\n\r\n     * are considered to have zero norm, hence the vectors they come from are not independent from\r\n\r\n     * previous vectors\r\n\r\n     * @param field type of the files elements\r\n\r\n     * @param handler handler for dependent vectors\r\n\r\n     * @return orthonormal basis having the same span as {@code independent}\r\n\r\n     * @since 2.1\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static  List<Field_Vector<T>> orthonormalize(const Field<T> field, const List<Field_Vector<T>> independent, const T threshold, const Dependent_Vectors_Handler handler) \r\n\r\n    {\r\n\r\n\r\n\r\n        // create separate list\r\n\r\n        const List<Field_Vector<T>> basis = Array_list<>(independent);\r\n\r\n\r\n\r\n        // loop over basis vectors\r\n\r\n        int index = 0;\r\n\r\n        while (index < basis.size()) \r\n\r\n        {\r\n\r\n\r\n\r\n            // check dependency\r\n\r\n            const Field_Vector<T> vi = basis.get(index);\r\n\r\n            const T norm = vi.dot_product(vi).sqrt();\r\n\r\n            if (norm.subtract(threshold).get_real() <= 0) \r\n\r\n            {\r\n\r\n                // the current vector is dependent from the previous ones\r\n\r\n                index = handler.manage_dependent(field, index, basis);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n\r\n\r\n                // normalize basis vector in place\r\n\r\n                vi.map_divide_to_self(norm);\r\n\r\n\r\n\r\n                // project remaining vectors in place\r\n\r\n                for (int j = index + 1; j < basis.size(); ++j) \r\n\r\n                {\r\n\r\n                    const Field_Vector<T> vj  = basis.get(j);\r\n\r\n                    const T              dot = vi.dot_product(vj);\r\n\r\n                    for (int k{}; k < vj.get_dimension(); ++k) \r\n\r\n                    {\r\n\r\n                        vj.set_entry(k, vj.get_entry(k).subtract(dot.multiply(vi.get_entry(k))));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                ++index;\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return basis;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n