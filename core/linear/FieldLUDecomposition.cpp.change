/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import java.util.function.Predicate;\r\n\r\n#include "MatrixUtils.h"\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/**\r\n\r\n * Calculates the L_U_P-decomposition of a square matrix.\r\n\r\n * <p>The L_U_P-decomposition of a matrix A consists of three matrices\r\n\r\n * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\r\n\r\n * upper triangular and P is a permutation matrix. All matrices are\r\n\r\n * m&times;m.</p>\r\n\r\n * <p>This class is based on the class with similar name from the\r\n\r\n * <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> library.</p>\r\n\r\n * <ul>\r\n\r\n *   <li>a {@link #get_p() get_p} method has been added,</li>\r\n\r\n *   <li>the {@code det} method has been renamed as {@link #get_determinant()\r\n\r\n *   get_determinant},</li>\r\n\r\n *   <li>the {@code get_double_pivot} method has been removed (but the int based\r\n\r\n *   {@link #get_pivot() get_pivot} method has been kept),</li>\r\n\r\n *   <li>the {@code solve} and {@code is_non_singular} methods have been replaced\r\n\r\n *   by a {@link #get_solver() get_solver} method and the equivalent methods\r\n\r\n *   provided by the returned {@link Decomposition_Solver}.</li>\r\n\r\n * </ul>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @see <a href="http://mathworld.wolfram.com/LU_Decomposition.html">MathWorld</a>\r\n\r\n * @see <a href="http://en.wikipedia.org/wiki/LU_decomposition">Wikipedia</a>\r\n\r\n */\r\n\r\nclass FieldLU_Decomposition<T extends Field_Element<T>> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Field to which the elements belong. */\r\n\r\n    private const Field<T> field;\r\n\r\n\r\n\r\n    /** Entries of LU decomposition. */\r\n\r\n    private std::vector<std::vector<T>> lu;\r\n\r\n\r\n\r\n    /** Pivot permutation associated with LU decomposition. */\r\n\r\n    private std::vector<int> pivot;\r\n\r\n\r\n\r\n    /** Parity of the permutation associated with the LU decomposition. */\r\n\r\n    private bool even;\r\n\r\n\r\n\r\n    /** Singularity indicator. */\r\n\r\n    private bool singular;\r\n\r\n\r\n\r\n    /** Cached value of L. */\r\n\r\n    private Field_Matrix<T> cached_l;\r\n\r\n\r\n\r\n    /** Cached value of U. */\r\n\r\n    private Field_Matrix<T> cached_u;\r\n\r\n\r\n\r\n    /** Cached value of P. */\r\n\r\n    private Field_Matrix<T> cached_p;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the LU-decomposition of the given matrix.\r\n\r\n     * <p>\r\n\r\n     * By default, <code>numeric_permutation_choice</code> is set to <code>true</code>.\r\n\r\n     * </p>\r\n\r\n     * @param matrix The matrix to decompose.\r\n\r\n     * @ if matrix is not square\r\n\r\n     * @see #FieldLU_Decomposition(Field_Matrix, Predicate)\r\n\r\n     * @see #FieldLU_Decomposition(Field_Matrix, Predicate, bool)\r\n\r\n     */\r\n\r\n    public FieldLU_Decomposition(Field_Matrix<T> matrix) \r\n\r\n    {\r\n\r\n        this(matrix, e -> e.is_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the LU-decomposition of the given matrix.\r\n\r\n     * <p>\r\n\r\n     * By default, <code>numeric_permutation_choice</code> is set to <code>true</code>.\r\n\r\n     * </p>\r\n\r\n     * @param matrix The matrix to decompose.\r\n\r\n     * @param zero_checker checker for zero elements\r\n\r\n     * @ if matrix is not square\r\n\r\n     * @see #FieldLU_Decomposition(Field_Matrix, Predicate, bool)\r\n\r\n     */\r\n\r\n    public FieldLU_Decomposition(Field_Matrix<T> matrix, const Predicate<T> zero_checker ) \r\n\r\n    {\r\n\r\n        this(matrix, zero_checker, true);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the LU-decomposition of the given matrix.\r\n\r\n     * @param matrix The matrix to decompose.\r\n\r\n     * @param zero_checker checker for zero elements\r\n\r\n     * @param numeric_permutation_choice if <code>true</code> choose permutation index with numeric calculations, otherwise choose with <code>zero_checker</code>\r\n\r\n     * @ if matrix is not square\r\n\r\n     */\r\n\r\n    public FieldLU_Decomposition(Field_Matrix<T> matrix, const Predicate<T> zero_checker, bool numeric_permutation_choice) \r\n\r\n    {\r\n\r\n        if (!matrix.is_square()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, matrix.get_row_dimension(), matrix.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int m = matrix.get_column_dimension();\r\n\r\n        field = matrix.get_field();\r\n\r\n        lu = matrix.get_data();\r\n\r\n        pivot = int[m];\r\n\r\n        cached_l = null;\r\n\r\n        cached_u = null;\r\n\r\n        cached_p = null;\r\n\r\n\r\n\r\n        // Initialize permutation array and parity\r\n\r\n        for (int row = 0; row < m; row++) \r\n\r\n        {\r\n\r\n            pivot[row] = row;\r\n\r\n        }\r\n\r\n        even     = true;\r\n\r\n        singular = false;\r\n\r\n\r\n\r\n        // Loop over columns\r\n\r\n        for (int col = 0; col < m; col++) \r\n\r\n        {\r\n\r\n\r\n\r\n            // upper\r\n\r\n            for (int row = 0; row < col; row++) \r\n\r\n            {\r\n\r\n                const std::vector<T> lu_row = lu[row];\r\n\r\n                T sum = lu_row[col];\r\n\r\n                for (int i{}; i < row; i++) \r\n\r\n                {\r\n\r\n                    sum = sum.subtract(lu_row[i].multiply(lu[i][col]));\r\n\r\n                }\r\n\r\n                lu_row[col] = sum;\r\n\r\n            }\r\n\r\n\r\n\r\n            int max = col; // permutation row\r\n\r\n            if (numeric_permutation_choice) \r\n\r\n            {\r\n\r\n\r\n\r\n                // lower\r\n\r\n                double largest = -INFINITY;\r\n\r\n\r\n\r\n                for (int row = col; row < m; row++) \r\n\r\n                {\r\n\r\n                    const std::vector<T> lu_row = lu[row];\r\n\r\n                    T sum = lu_row[col];\r\n\r\n                    for (int i{}; i < col; i++) \r\n\r\n                    {\r\n\r\n                        sum = sum.subtract(lu_row[i].multiply(lu[i][col]));\r\n\r\n                    }\r\n\r\n                    lu_row[col] = sum;\r\n\r\n\r\n\r\n                    // maintain best permutation choice\r\n\r\n                    double abs_sum = std::abs(sum.get_real());\r\n\r\n                    if (abs_sum > largest) \r\n\r\n                    {\r\n\r\n                        largest = abs_sum;\r\n\r\n                        max = row;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n\r\n\r\n                // lower\r\n\r\n                int non_zero = col; // permutation row\r\n\r\n                for (int row = col; row < m; row++) \r\n\r\n                {\r\n\r\n                    const std::vector<T> lu_row = lu[row];\r\n\r\n                    T sum = lu_row[col];\r\n\r\n                    for (int i{}; i < col; i++) \r\n\r\n                    {\r\n\r\n                        sum = sum.subtract(lu_row[i].multiply(lu[i][col]));\r\n\r\n                    }\r\n\r\n                    lu_row[col] = sum;\r\n\r\n\r\n\r\n                    if (zero_checker.test(lu[non_zero][col])) \r\n\r\n                    {\r\n\r\n                        // try to select a better permutation choice\r\n\r\n                        ++non_zero;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n                max = std::min(m - 1, non_zero);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            // Singularity check\r\n\r\n            if (zero_checker.test(lu[max][col])) \r\n\r\n            {\r\n\r\n                singular = true;\r\n\r\n                return;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Pivot if necessary\r\n\r\n            if (max != col) \r\n\r\n            {\r\n\r\n                const std::vector<T> lu_max = lu[max];\r\n\r\n                const std::vector<T> lu_col = lu[col];\r\n\r\n                for (int i{}; i < m; i++) \r\n\r\n                {\r\n\r\n                    const T tmp = lu_max[i];\r\n\r\n                    lu_max[i] = lu_col[i];\r\n\r\n                    lu_col[i] = tmp;\r\n\r\n                }\r\n\r\n                int temp = pivot[max];\r\n\r\n                pivot[max] = pivot[col];\r\n\r\n                pivot[col] = temp;\r\n\r\n                even = !even;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Divide the lower elements by the "winning" diagonal elt.\r\n\r\n            const T lu_diag = lu[col][col];\r\n\r\n            for (int row = col + 1; row < m; row++) \r\n\r\n            {\r\n\r\n                lu[row][col] = lu[row][col].divide(lu_diag);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the matrix L of the decomposition.\r\n\r\n     * <p>L is a lower-triangular matrix</p>\r\n\r\n     * @return the L matrix (or null if decomposed matrix is singular)\r\n\r\n     */\r\n\r\n    public Field_Matrix<T> get_l() \r\n\r\n    {\r\n\r\n        if ((cached_l == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_l = Array2DRowField_Matrix<>(field, m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<T> lu_i = lu[i];\r\n\r\n                for (int j{}; j < i; ++j) \r\n\r\n                {\r\n\r\n                    cached_l.set_entry(i, j, lu_i[j]);\r\n\r\n                }\r\n\r\n                cached_l.set_entry(i, i, field.get_one());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_l;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the matrix U of the decomposition.\r\n\r\n     * <p>U is an upper-triangular matrix</p>\r\n\r\n     * @return the U matrix (or null if decomposed matrix is singular)\r\n\r\n     */\r\n\r\n    public Field_Matrix<T> get_u() \r\n\r\n    {\r\n\r\n        if ((cached_u == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_u = Array2DRowField_Matrix<>(field, m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<T> lu_i = lu[i];\r\n\r\n                for (int j = i; j < m; ++j) \r\n\r\n                {\r\n\r\n                    cached_u.set_entry(i, j, lu_i[j]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_u;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the P rows permutation matrix.\r\n\r\n     * <p>P is a sparse matrix with exactly one element set to 1.0 in\r\n\r\n     * each row and each column, all other elements being set to 0.0.</p>\r\n\r\n     * <p>The positions of the 1 elements are given by the {@link #get_pivot()\r\n\r\n     * pivot permutation vector}.</p>\r\n\r\n     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\r\n\r\n     * @see #get_pivot()\r\n\r\n     */\r\n\r\n    public Field_Matrix<T> get_p() \r\n\r\n    {\r\n\r\n        if ((cached_p == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_p = Array2DRowField_Matrix<>(field, m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                cached_p.set_entry(i, pivot[i], field.get_one());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_p;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the pivot permutation vector.\r\n\r\n     * @return the pivot permutation vector\r\n\r\n     * @see #get_p()\r\n\r\n     */\r\n\r\n    public std::vector<int> get_pivot() \r\n\r\n    {\r\n\r\n        return pivot.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the determinant of the matrix.\r\n\r\n     * @return determinant of the matrix\r\n\r\n     */\r\n\r\n    public T get_determinant() \r\n\r\n    {\r\n\r\n        if (singular) \r\n\r\n        {\r\n\r\n            return field.get_zero();\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            T determinant = even ? field.get_one() : field.get_zero().subtract(field.get_one());\r\n\r\n            for (int i{}; i < m; i++) \r\n\r\n            {\r\n\r\n                determinant = determinant.multiply(lu[i][i]);\r\n\r\n            }\r\n\r\n            return determinant;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a solver for finding the A &times; X = B solution in exact linear sense.\r\n\r\n     * @return a solver\r\n\r\n     */\r\n\r\n    public FieldDecomposition_Solver<T> get_solver() \r\n\r\n    {\r\n\r\n        return Solver();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Specialized solver.\r\n\r\n     */\r\n\r\n    private class Solver : FieldDecomposition_Solver<T> \r\n\r\n    {\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public bool is_non_singular() \r\n\r\n        {\r\n\r\n            return !singular;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Field_Vector<T> solve(Field_Vector<T> b) \r\n\r\n        {\r\n\r\n            if (b instanceof ArrayField_Vector) \r\n\r\n            {\r\n\r\n                return solve((ArrayField_Vector<T>) b);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n\r\n\r\n                const int m = pivot.size();\r\n\r\n                if (b.get_dimension() != m) \r\n\r\n                {\r\n\r\n                    throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_dimension(), m);\r\n\r\n                }\r\n\r\n                if (singular) \r\n\r\n                {\r\n\r\n                    throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n                }\r\n\r\n\r\n\r\n                // Apply permutations to b\r\n\r\n                const std::vector<T> bp = Math_Arrays::build_array(field, m);\r\n\r\n                for (int row = 0; row < m; row++) \r\n\r\n                {\r\n\r\n                    bp[row] = b.get_entry(pivot[row]);\r\n\r\n                }\r\n\r\n\r\n\r\n                // Solve LY = b\r\n\r\n                for (int col = 0; col < m; col++) \r\n\r\n                {\r\n\r\n                    const T& bp_col = bp[col];\r\n\r\n                    for (int i = col + 1; i < m; i++) \r\n\r\n                    {\r\n\r\n                        bp[i] = bp[i].subtract(bp_col.multiply(lu[i][col]));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                // Solve UX = Y\r\n\r\n                for (int col = m - 1; col >= 0; col--) \r\n\r\n                {\r\n\r\n                    bp[col] = bp[col].divide(lu[col][col]);\r\n\r\n                    const T& bp_col = bp[col];\r\n\r\n                    for (int i{}; i < col; i++) \r\n\r\n                    {\r\n\r\n                        bp[i] = bp[i].subtract(bp_col.multiply(lu[i][col]));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                return ArrayField_Vector<T>(field, bp, false);\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        /** Solve the linear equation A &times; X = B.\r\n\r\n         * <p>The A matrix is implicit here. It is </p>\r\n\r\n         * @param b right-hand side of the equation A &times; X = B\r\n\r\n         * @return a vector X such that A &times; X = B\r\n\r\n         * @ if the matrices dimensions do not match.\r\n\r\n         * @ if the decomposed matrix is singular.\r\n\r\n         */\r\n\r\n        public ArrayField_Vector<T> solve(ArrayField_Vector<T> b) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            const int length = b.get_dimension();\r\n\r\n            if (length != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, length, m);\r\n\r\n            }\r\n\r\n            if (singular) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            // Apply permutations to b\r\n\r\n            const std::vector<T> bp = Math_Arrays::build_array(field, m);\r\n\r\n            for (int row = 0; row < m; row++) \r\n\r\n            {\r\n\r\n                bp[row] = b.get_entry(pivot[row]);\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve LY = b\r\n\r\n            for (int col = 0; col < m; col++) \r\n\r\n            {\r\n\r\n                const T& bp_col = bp[col];\r\n\r\n                for (int i = col + 1; i < m; i++) \r\n\r\n                {\r\n\r\n                    bp[i] = bp[i].subtract(bp_col.multiply(lu[i][col]));\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve UX = Y\r\n\r\n            for (int col = m - 1; col >= 0; col--) \r\n\r\n            {\r\n\r\n                bp[col] = bp[col].divide(lu[col][col]);\r\n\r\n                const T& bp_col = bp[col];\r\n\r\n                for (int i{}; i < col; i++) \r\n\r\n                {\r\n\r\n                    bp[i] = bp[i].subtract(bp_col.multiply(lu[i][col]));\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return ArrayField_Vector<T>(bp, false);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Field_Matrix<T> solve(Field_Matrix<T> b) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            if (b.get_row_dimension() != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_row_dimension(), m);\r\n\r\n            }\r\n\r\n            if (singular) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int& n_col_b = b.get_column_dimension();\r\n\r\n\r\n\r\n            // Apply permutations to b\r\n\r\n            const std::vector<std::vector<T>> bp = Math_Arrays::build_array(field, m, n_col_b);\r\n\r\n            for (int row = 0; row < m; row++) \r\n\r\n            {\r\n\r\n                const std::vector<T> bp_row = bp[row];\r\n\r\n                const int p_row = pivot[row];\r\n\r\n                for (int col = 0; col < n_col_b; col++) \r\n\r\n                {\r\n\r\n                    bp_row[col] = b.get_entry(p_row, col);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve LY = b\r\n\r\n            for (int col = 0; col < m; col++) \r\n\r\n            {\r\n\r\n                const std::vector<T> bp_col = bp[col];\r\n\r\n                for (int i = col + 1; i < m; i++) \r\n\r\n                {\r\n\r\n                    const std::vector<T> bp_i = bp[i];\r\n\r\n                    const T lu_i_col = lu[i][col];\r\n\r\n                    for (int j{}; j < n_col_b; j++) \r\n\r\n                    {\r\n\r\n                        bp_i[j] = bp_i[j].subtract(bp_col[j].multiply(lu_i_col));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve UX = Y\r\n\r\n            for (int col = m - 1; col >= 0; col--) \r\n\r\n            {\r\n\r\n                const std::vector<T> bp_col = bp[col];\r\n\r\n                const T lu_diag = lu[col][col];\r\n\r\n                for (int j{}; j < n_col_b; j++) \r\n\r\n                {\r\n\r\n                    bp_col[j] = bp_col[j].divide(lu_diag);\r\n\r\n                }\r\n\r\n                for (int i{}; i < col; i++) \r\n\r\n                {\r\n\r\n                    const std::vector<T> bp_i = bp[i];\r\n\r\n                    const T lu_i_col = lu[i][col];\r\n\r\n                    for (int j{}; j < n_col_b; j++) \r\n\r\n                    {\r\n\r\n                        bp_i[j] = bp_i[j].subtract(bp_col[j].multiply(lu_i_col));\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return Array2DRowField_Matrix<T>(field, bp, false);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Field_Matrix<T> get_inverse() \r\n\r\n        {\r\n\r\n            return solve(Matrix_Utils.create_field_identity_matrix(field, pivot.size()));\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_row_dimension() \r\n\r\n        {\r\n\r\n            return lu.size();\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_column_dimension() \r\n\r\n        {\r\n\r\n            return lu[0].size();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n