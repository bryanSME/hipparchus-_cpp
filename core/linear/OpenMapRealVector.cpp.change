/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Open_Int_To_Double_Hash_Map;\r\n\r\n//import org.hipparchus.util.Open_Int_To_Double_Hash_Map.Iterator;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the {@link Real_Vector} interface with a\r\n\r\n * {@link Open_Int_To_Double_Hash_Map} backing store.\r\n\r\n * <p>\r\n\r\n *  Caveat: This implementation assumes that, for any {@code x}, *  the equality {@code x * 0d == 0d} holds. But it is is not true for\r\n\r\n *  {@code NaN}. Moreover, zero entries will lose their sign.\r\n\r\n *  Some operations (that involve {@code NaN} and/or infinities) may\r\n\r\n *  thus give incorrect results, like multiplications, divisions or\r\n\r\n *  functions mapping.\r\n\r\n * </p>\r\n\r\n */\r\n\r\nclass OpenMapReal_Vector extends SparseReal_Vector\r\n\r\n     \r\n\r\n    {\r\n\r\n    /** Default Tolerance for having a value considered zero. */\r\n\r\n    public static const double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\r\n\r\n    /** Serializable version identifier. */\r\n\r\n    private static const long serial_version_uid = 8772222695580707260L;\r\n\r\n    /** Entries of the vector. */\r\n\r\n    private const Open_Int_To_Double_Hash_Map entries;\r\n\r\n    /** Dimension of the vector. */\r\n\r\n    private const int virtual_size;\r\n\r\n    /** Tolerance for having a value considered zero. */\r\n\r\n    private const double epsilon;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a 0-length vector.\r\n\r\n     * Zero-length vectors may be used to initialized construction of vectors\r\n\r\n     * by data gathering. We start with zero-length and use either the {@link\r\n\r\n     * #OpenMapReal_Vector(OpenMapReal_Vector, int)} constructor\r\n\r\n     * or one of the {@code append} method ({@link #appendstatic_cast<double>(}, * {@link #append(Real_Vector)}) to gather data into this vector.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector() \r\n\r\n    {\r\n\r\n        this(0, DEFAULT_ZERO_TOLERANCE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a vector of zeroes.\r\n\r\n     *\r\n\r\n     * @param dimension Size of the vector.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(const int& dimension) \r\n\r\n    {\r\n\r\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Construct a vector of zeroes, specifying zero tolerance.\r\n\r\n     *\r\n\r\n     * @param dimension Size of the vector.\r\n\r\n     * @param epsilon Tolerance below which a value considered zero.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(const int& dimension, double epsilon) \r\n\r\n    {\r\n\r\n        virtual_size = dimension;\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(0.0);\r\n\r\n        this.epsilon = epsilon;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a resized vector, for use with append.\r\n\r\n     *\r\n\r\n     * @param v Original vector.\r\n\r\n     * @param resize Amount to add.\r\n\r\n     */\r\n\r\n    protected OpenMapReal_Vector(OpenMapReal_Vector v, int resize) \r\n\r\n    {\r\n\r\n        virtual_size = v.get_dimension() + resize;\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(v.entries);\r\n\r\n        epsilon = v.epsilon;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a vector with known the sparseness (for advanced use only).\r\n\r\n     *\r\n\r\n     * @param dimension Size of the vector.\r\n\r\n     * @param expected_size The expected number of non-zero entries.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(const int& dimension, int expected_size) \r\n\r\n    {\r\n\r\n        this(dimension, expected_size, DEFAULT_ZERO_TOLERANCE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a vector with known the sparseness and zero tolerance\r\n\r\n     * setting (for advanced use only).\r\n\r\n     *\r\n\r\n     * @param dimension Size of the vector.\r\n\r\n     * @param expected_size Expected number of non-zero entries.\r\n\r\n     * @param epsilon Tolerance below which a value is considered zero.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(const int& dimension, int expected_size, double epsilon) \r\n\r\n    {\r\n\r\n        virtual_size = dimension;\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(expected_size, 0.0);\r\n\r\n        this.epsilon = epsilon;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create from an array.\r\n\r\n     * Only non-zero entries will be stored.\r\n\r\n     *\r\n\r\n     * @param values Set of values to create from.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(std::vector<double> values) \r\n\r\n    {\r\n\r\n        this(values, DEFAULT_ZERO_TOLERANCE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create from an array, specifying zero tolerance.\r\n\r\n     * Only non-zero entries will be stored.\r\n\r\n     *\r\n\r\n     * @param values Set of values to create from.\r\n\r\n     * @param epsilon Tolerance below which a value is considered zero.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(std::vector<double> values, double epsilon) \r\n\r\n    {\r\n\r\n        virtual_size = values.size();\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(0.0);\r\n\r\n        this.epsilon = epsilon;\r\n\r\n        for (const int& key = 0; key < values.size(); key++) \r\n\r\n        {\r\n\r\n            double value = values[key];\r\n\r\n            if (!is_default_value(value)) \r\n\r\n            {\r\n\r\n                entries.put(key, value);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create from an array.\r\n\r\n     * Only non-zero entries will be stored.\r\n\r\n     *\r\n\r\n     * @param values The set of values to create from\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(Double[] values) \r\n\r\n    {\r\n\r\n        this(values, DEFAULT_ZERO_TOLERANCE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create from an array.\r\n\r\n     * Only non-zero entries will be stored.\r\n\r\n     *\r\n\r\n     * @param values Set of values to create from.\r\n\r\n     * @param epsilon Tolerance below which a value is considered zero.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(Double[] values, double epsilon) \r\n\r\n    {\r\n\r\n        virtual_size = values.size();\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(0.0);\r\n\r\n        this.epsilon = epsilon;\r\n\r\n        for (const int& key = 0; key < values.size(); key++) \r\n\r\n        {\r\n\r\n            double value = values[key].double_value();\r\n\r\n            if (!is_default_value(value)) \r\n\r\n            {\r\n\r\n                entries.put(key, value);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Copy constructor.\r\n\r\n     *\r\n\r\n     * @param v Instance to copy from.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(OpenMapReal_Vector v) \r\n\r\n    {\r\n\r\n        virtual_size = v.get_dimension();\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(v.get_entries());\r\n\r\n        epsilon = v.epsilon;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Generic copy constructor.\r\n\r\n     *\r\n\r\n     * @param v Instance to copy from.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector(Real_Vector v) \r\n\r\n    {\r\n\r\n        virtual_size = v.get_dimension();\r\n\r\n        entries = Open_Int_To_Double_Hash_Map(0.0);\r\n\r\n        epsilon = DEFAULT_ZERO_TOLERANCE;\r\n\r\n        for (const int& key = 0; key < virtual_size; key++) \r\n\r\n        {\r\n\r\n            double value = v.get_entry(key);\r\n\r\n            if (!is_default_value(value)) \r\n\r\n            {\r\n\r\n                entries.put(key, value);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the entries of this instance.\r\n\r\n     *\r\n\r\n     * @return the entries of this instance.\r\n\r\n     */\r\n\r\n    private Open_Int_To_Double_Hash_Map get_entries() \r\n\r\n    {\r\n\r\n        return entries;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Determine if this value is within epsilon of zero.\r\n\r\n     *\r\n\r\n     * @param value Value to test\r\n\r\n     * @return {@code true} if this value is within epsilon to zero, * {@code false} otherwise.\r\n\r\n     */\r\n\r\n    protected bool is_default_value(double value) \r\n\r\n    {\r\n\r\n        return std::abs(value) < epsilon;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Real_Vector add(Real_Vector v)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_vector_dimensions(v.get_bimension());\r\n\r\n        if (v instanceof OpenMapReal_Vector) \r\n\r\n        {\r\n\r\n            return add((OpenMapReal_Vector) v);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return super.add(v);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Optimized method to add two OpenMapReal_Vectors.\r\n\r\n     * It copies the larger vector, then iterates over the smaller.\r\n\r\n     *\r\n\r\n     * @param v Vector to add.\r\n\r\n     * @return the sum of {@code this} and {@code v}.\r\n\r\n     * @ if the dimensions do not match.\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector add(OpenMapReal_Vector v)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_vector_dimensions(v.get_bimension());\r\n\r\n        bool copy_this = entries.size() > v.entries.size();\r\n\r\n        OpenMapReal_Vector res = copy_this ? this.copy() : v.copy();\r\n\r\n        Iterator iter = copy_this ? v.entries.iterator() : entries.iterator();\r\n\r\n        Open_Int_To_Double_Hash_Map random_access = copy_this ? entries : v.entries;\r\n\r\n        while (iter.has_next()) \r\n\r\n        {\r\n\r\n            iter.advance();\r\n\r\n            int key = iter.key();\r\n\r\n            if (random_access.contains_key(key)) \r\n\r\n            {\r\n\r\n                res.set_entry(key, random_access.get(key) + iter.value());\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                res.set_entry(key, iter.value());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Optimized method to append a OpenMapReal_Vector.\r\n\r\n     * @param v vector to append\r\n\r\n     * @return The result of appending {@code v} to self\r\n\r\n     */\r\n\r\n    public OpenMapReal_Vector append(OpenMapReal_Vector v) \r\n\r\n    {\r\n\r\n        OpenMapReal_Vector res = OpenMapReal_Vector(this, v.get_dimension());\r\n\r\n        Iterator iter = v.entries.iterator();\r\n\r\n        while (iter.has_next()) \r\n\r\n        {\r\n\r\n            iter.advance();\r\n\r\n            res.set_entry(iter.key() + virtual_size, iter.value());\r\n\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector append(Real_Vector v) \r\n\r\n    {\r\n\r\n        if (v instanceof OpenMapReal_Vector) \r\n\r\n        {\r\n\r\n            return append((OpenMapReal_Vector) v);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const OpenMapReal_Vector res = OpenMapReal_Vector(this, v.get_dimension());\r\n\r\n            for (int i{}; i < v.get_dimension(); i++) \r\n\r\n            {\r\n\r\n                res.set_entry(i + virtual_size, v.get_entry(i));\r\n\r\n            }\r\n\r\n            return res;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector append(double d) \r\n\r\n    {\r\n\r\n        OpenMapReal_Vector res = OpenMapReal_Vector(this, 1);\r\n\r\n        res.set_entry(virtual_size, d);\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector copy() \r\n\r\n    {\r\n\r\n        return OpenMapReal_Vector(this);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector ebe_divide(Real_Vector v)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_vector_dimensions(v.get_bimension());\r\n\r\n        OpenMapReal_Vector res = OpenMapReal_Vector(this);\r\n\r\n        /*\r\n\r\n         * MATH-803: it is not sufficient to loop through non zero entries of\r\n\r\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\r\n\r\n         * this[i] / v[i] = NaN, and not 0d.\r\n\r\n         */\r\n\r\n        const int n = get_dimension();\r\n\r\n        for (int i{}; i < n; i++) \r\n\r\n        {\r\n\r\n            res.set_entry(i, this.get_entry(i) / v.get_entry(i));\r\n\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector ebe_multiply(Real_Vector v)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_vector_dimensions(v.get_bimension());\r\n\r\n        OpenMapReal_Vector res = OpenMapReal_Vector(this);\r\n\r\n        Iterator iter = entries.iterator();\r\n\r\n        while (iter.has_next()) \r\n\r\n        {\r\n\r\n            iter.advance();\r\n\r\n            res.set_entry(iter.key(), iter.value() * v.get_entry(iter.key()));\r\n\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public OpenMapReal_Vector get_sub_vector(const int& index, int n)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_index(index);\r\n\r\n        if (n < 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\r\n\r\n        }\r\n\r\n        check_index(index + n - 1);\r\n\r\n        OpenMapReal_Vector res = OpenMapReal_Vector(n);\r\n\r\n        int end = index + n;\r\n\r\n        Iterator iter = entries.iterator();\r\n\r\n        while (iter.has_next()) \r\n\r\n        {\r\n\r\n            iter.advance();\r\n\r\n            int key = iter.key();\r\n\r\n            if (key >= index && key < end) \r\n\r\n            {\r\n\r\n                res.set_entry(key - index, iter.value());\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_dimension() \r\n\r\n    {\r\n\r\n        return virtual_size;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Optimized method to compute distance.\r\n\r\n     *\r\n\r\n     * @param v Vector to compute distance to.\r\n\r\n     * @return the distance from {@code this} and {@code v}.\r\n\r\n     * @ if the dimensions do not match.\r\n\r\n     */\r\n\r\n    public double get_distance(OpenMapReal_Vector v)\r\n\r\n         \r\n\r\n