/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n#include "MatrixUtils.h"\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * Calculates the L_U_P-decomposition of a square matrix.\r\n\r\n * <p>The L_U_P-decomposition of a matrix A consists of three matrices L, U and\r\n\r\n * P that satisfy: P&times;A = L&times;U. L is lower triangular (with unit\r\n\r\n * diagonal terms), U is upper triangular and P is a permutation matrix. All\r\n\r\n * matrices are m&times;m.</p>\r\n\r\n * <p>As shown by the presence of the P matrix, this decomposition is\r\n\r\n * implemented using partial pivoting.</p>\r\n\r\n * <p>This class is based on the class with similar name from the\r\n\r\n * <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> library.</p>\r\n\r\n * <ul>\r\n\r\n *   <li>a {@link #get_p() get_p} method has been added,</li>\r\n\r\n *   <li>the {@code det} method has been renamed as {@link #get_determinant()\r\n\r\n *   get_determinant},</li>\r\n\r\n *   <li>the {@code get_double_pivot} method has been removed (but the int based\r\n\r\n *   {@link #get_pivot() get_pivot} method has been kept),</li>\r\n\r\n *   <li>the {@code solve} and {@code is_non_singular} methods have been replaced\r\n\r\n *   by a {@link #get_solver() get_solver} method and the equivalent methods\r\n\r\n *   provided by the returned {@link Decomposition_Solver}.</li>\r\n\r\n * </ul>\r\n\r\n *\r\n\r\n * @see <a href="http://mathworld.wolfram.com/LU_Decomposition.html">MathWorld</a>\r\n\r\n * @see <a href="http://en.wikipedia.org/wiki/LU_decomposition">Wikipedia</a>\r\n\r\n */\r\n\r\nclass LU_Decomposition \r\n\r\n{\r\n\r\n    /** Default bound to determine effective singularity in LU decomposition. */\r\n\r\n    private static const double DEFAULT_TOO_SMALL = 1e-11;\r\n\r\n    /** Entries of LU decomposition. */\r\n\r\n    private const std::vector<std::vector<double>> lu;\r\n\r\n    /** Pivot permutation associated with LU decomposition. */\r\n\r\n    private const std::vector<int> pivot;\r\n\r\n    /** Parity of the permutation associated with the LU decomposition. */\r\n\r\n    private bool even;\r\n\r\n    /** Singularity indicator. */\r\n\r\n    private bool singular;\r\n\r\n    /** Cached value of L. */\r\n\r\n    private Real_Matrix cached_l;\r\n\r\n    /** Cached value of U. */\r\n\r\n    private Real_Matrix cached_u;\r\n\r\n    /** Cached value of P. */\r\n\r\n    private Real_Matrix cached_p;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the LU-decomposition of the given matrix.\r\n\r\n     * This constructor uses 1e-11 as default value for the singularity\r\n\r\n     * threshold.\r\n\r\n     *\r\n\r\n     * @param matrix Matrix to decompose.\r\n\r\n     * @ if matrix is not square.\r\n\r\n     */\r\n\r\n    public LU_Decomposition(Real_Matrix matrix) \r\n\r\n    {\r\n\r\n        this(matrix, DEFAULT_TOO_SMALL);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Calculates the LU-decomposition of the given matrix.\r\n\r\n     * @param matrix The matrix to decompose.\r\n\r\n     * @param singularity_threshold threshold (based on partial row norm)\r\n\r\n     * under which a matrix is considered singular\r\n\r\n     * @ if matrix is not square\r\n\r\n     */\r\n\r\n    public LU_Decomposition(Real_Matrix matrix, const double& singularity_threshold) \r\n\r\n    {\r\n\r\n        if (!matrix.is_square()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, matrix.get_row_dimension(), matrix.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int m = matrix.get_column_dimension();\r\n\r\n        lu = matrix.get_data();\r\n\r\n        pivot = int[m];\r\n\r\n        cached_l = null;\r\n\r\n        cached_u = null;\r\n\r\n        cached_p = null;\r\n\r\n\r\n\r\n        // Initialize permutation array and parity\r\n\r\n        for (int row = 0; row < m; row++) \r\n\r\n        {\r\n\r\n            pivot[row] = row;\r\n\r\n        }\r\n\r\n        even     = true;\r\n\r\n        singular = false;\r\n\r\n\r\n\r\n        // Loop over columns\r\n\r\n        for (int col = 0; col < m; col++) \r\n\r\n        {\r\n\r\n\r\n\r\n            // upper\r\n\r\n            for (int row = 0; row < col; row++) \r\n\r\n            {\r\n\r\n                const std::vector<double> lu_row = lu[row];\r\n\r\n                double sum = lu_row[col];\r\n\r\n                for (int i{}; i < row; i++) \r\n\r\n                {\r\n\r\n                    sum -= lu_row[i] * lu[i][col];\r\n\r\n                }\r\n\r\n                lu_row[col] = sum;\r\n\r\n            }\r\n\r\n\r\n\r\n            // lower\r\n\r\n            int max = col; // permutation row\r\n\r\n            double largest = -INFINITY;\r\n\r\n            for (int row = col; row < m; row++) \r\n\r\n            {\r\n\r\n                const std::vector<double> lu_row = lu[row];\r\n\r\n                double sum = lu_row[col];\r\n\r\n                for (int i{}; i < col; i++) \r\n\r\n                {\r\n\r\n                    sum -= lu_row[i] * lu[i][col];\r\n\r\n                }\r\n\r\n                lu_row[col] = sum;\r\n\r\n\r\n\r\n                // maintain best permutation choice\r\n\r\n                if (std::abs(sum) > largest) \r\n\r\n                {\r\n\r\n                    largest = std::abs(sum);\r\n\r\n                    max = row;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Singularity check\r\n\r\n            if (std::abs(lu[max][col]) < singularity_threshold) \r\n\r\n            {\r\n\r\n                singular = true;\r\n\r\n                return;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Pivot if necessary\r\n\r\n            if (max != col) \r\n\r\n            {\r\n\r\n                const std::vector<double> lu_max = lu[max];\r\n\r\n                const std::vector<double> lu_col = lu[col];\r\n\r\n                for (int i{}; i < m; i++) \r\n\r\n                {\r\n\r\n                    const double tmp = lu_max[i];\r\n\r\n                    lu_max[i] = lu_col[i];\r\n\r\n                    lu_col[i] = tmp;\r\n\r\n                }\r\n\r\n                int temp = pivot[max];\r\n\r\n                pivot[max] = pivot[col];\r\n\r\n                pivot[col] = temp;\r\n\r\n                even = !even;\r\n\r\n            }\r\n\r\n\r\n\r\n            // Divide the lower elements by the "winning" diagonal elt.\r\n\r\n            const double lu_diag = lu[col][col];\r\n\r\n            for (int row = col + 1; row < m; row++) \r\n\r\n            {\r\n\r\n                lu[row][col] /= lu_diag;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the matrix L of the decomposition.\r\n\r\n     * <p>L is a lower-triangular matrix</p>\r\n\r\n     * @return the L matrix (or null if decomposed matrix is singular)\r\n\r\n     */\r\n\r\n    public Real_Matrix get_l() \r\n\r\n    {\r\n\r\n        if ((cached_l == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_l = Matrix_Utils.create_real_matrix(m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<double> lu_i = lu[i];\r\n\r\n                for (int j{}; j < i; ++j) \r\n\r\n                {\r\n\r\n                    cached_l.set_entry(i, j, lu_i[j]);\r\n\r\n                }\r\n\r\n                cached_l.set_entry(i, i, 1.0);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_l;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the matrix U of the decomposition.\r\n\r\n     * <p>U is an upper-triangular matrix</p>\r\n\r\n     * @return the U matrix (or null if decomposed matrix is singular)\r\n\r\n     */\r\n\r\n    public Real_Matrix get_u() \r\n\r\n    {\r\n\r\n        if ((cached_u == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_u = Matrix_Utils.create_real_matrix(m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                const std::vector<double> lu_i = lu[i];\r\n\r\n                for (int j = i; j < m; ++j) \r\n\r\n                {\r\n\r\n                    cached_u.set_entry(i, j, lu_i[j]);\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_u;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the P rows permutation matrix.\r\n\r\n     * <p>P is a sparse matrix with exactly one element set to 1.0 in\r\n\r\n     * each row and each column, all other elements being set to 0.0.</p>\r\n\r\n     * <p>The positions of the 1 elements are given by the {@link #get_pivot()\r\n\r\n     * pivot permutation vector}.</p>\r\n\r\n     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\r\n\r\n     * @see #get_pivot()\r\n\r\n     */\r\n\r\n    public Real_Matrix get_p() \r\n\r\n    {\r\n\r\n        if ((cached_p == null) && !singular) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            cached_p = Matrix_Utils.create_real_matrix(m, m);\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                cached_p.set_entry(i, pivot[i], 1.0);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return cached_p;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the pivot permutation vector.\r\n\r\n     * @return the pivot permutation vector\r\n\r\n     * @see #get_p()\r\n\r\n     */\r\n\r\n    public std::vector<int> get_pivot() \r\n\r\n    {\r\n\r\n        return pivot.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the determinant of the matrix\r\n\r\n     * @return determinant of the matrix\r\n\r\n     */\r\n\r\n    public double get_determinant() \r\n\r\n    {\r\n\r\n        if (singular) \r\n\r\n        {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            double determinant = even ? 1 : -1;\r\n\r\n            for (int i{}; i < m; i++) \r\n\r\n            {\r\n\r\n                determinant *= lu[i][i];\r\n\r\n            }\r\n\r\n            return determinant;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a solver for finding the A &times; X = B solution in exact linear\r\n\r\n     * sense.\r\n\r\n     * @return a solver\r\n\r\n     */\r\n\r\n    public Decomposition_Solver get_solver() \r\n\r\n    {\r\n\r\n        return Solver();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Specialized solver. */\r\n\r\n    private class Solver : Decomposition_Solver \r\n\r\n    {\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public bool is_non_singular() \r\n\r\n        {\r\n\r\n            return !singular;\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Real_Vector solve(Real_Vector b) \r\n\r\n        {\r\n\r\n            const int m = pivot.size();\r\n\r\n            if (b.get_dimension() != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_dimension(), m);\r\n\r\n            }\r\n\r\n            if (singular) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const std::vector<double> bp = std::vector<double>(m];\r\n\r\n\r\n\r\n            // Apply permutations to b\r\n\r\n            for (int row = 0; row < m; row++) \r\n\r\n            {\r\n\r\n                bp[row] = b.get_entry(pivot[row]);\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve LY = b\r\n\r\n            for (int col = 0; col < m; col++) \r\n\r\n            {\r\n\r\n                const double bp_col = bp[col];\r\n\r\n                for (int i = col + 1; i < m; i++) \r\n\r\n                {\r\n\r\n                    bp[i] -= bp_col * lu[i][col];\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve UX = Y\r\n\r\n            for (int col = m - 1; col >= 0; col--) \r\n\r\n            {\r\n\r\n                bp[col] /= lu[col][col];\r\n\r\n                const double bp_col = bp[col];\r\n\r\n                for (int i{}; i < col; i++) \r\n\r\n                {\r\n\r\n                    bp[i] -= bp_col * lu[i][col];\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return Array_Real_Vector(bp, false);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public Real_Matrix solve(Real_Matrix b) \r\n\r\n        {\r\n\r\n\r\n\r\n            const int m = pivot.size();\r\n\r\n            if (b.get_row_dimension() != m) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, b.get_row_dimension(), m);\r\n\r\n            }\r\n\r\n            if (singular) \r\n\r\n            {\r\n\r\n                throw (Localized_Core_Formats.SINGULAR_MATRIX);\r\n\r\n            }\r\n\r\n\r\n\r\n            const int& n_col_b = b.get_column_dimension();\r\n\r\n\r\n\r\n            // Apply permutations to b\r\n\r\n            const std::vector<std::vector<double>> bp = std::vector<double>(m][n_col_b];\r\n\r\n            for (int row = 0; row < m; row++) \r\n\r\n            {\r\n\r\n                const std::vector<double> bp_row = bp[row];\r\n\r\n                const int p_row = pivot[row];\r\n\r\n                for (int col = 0; col < n_col_b; col++) \r\n\r\n                {\r\n\r\n                    bp_row[col] = b.get_entry(p_row, col);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve LY = b\r\n\r\n            for (int col = 0; col < m; col++) \r\n\r\n            {\r\n\r\n                const std::vector<double> bp_col = bp[col];\r\n\r\n                for (int i = col + 1; i < m; i++) \r\n\r\n                {\r\n\r\n                    const std::vector<double> bp_i = bp[i];\r\n\r\n                    const double lu_i_col = lu[i][col];\r\n\r\n                    for (int j{}; j < n_col_b; j++) \r\n\r\n                    {\r\n\r\n                        bp_i[j] -= bp_col[j] * lu_i_col;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            // Solve UX = Y\r\n\r\n            for (int col = m - 1; col >= 0; col--) \r\n\r\n            {\r\n\r\n                const std::vector<double> bp_col = bp[col];\r\n\r\n                const double lu_diag = lu[col][col];\r\n\r\n                for (int j{}; j < n_col_b; j++) \r\n\r\n                {\r\n\r\n                    bp_col[j] /= lu_diag;\r\n\r\n                }\r\n\r\n                for (int i{}; i < col; i++) \r\n\r\n                {\r\n\r\n                    const std::vector<double> bp_i = bp[i];\r\n\r\n                    const double lu_i_col = lu[i][col];\r\n\r\n                    for (int j{}; j < n_col_b; j++) \r\n\r\n                    {\r\n\r\n                        bp_i[j] -= bp_col[j] * lu_i_col;\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            return Array_2D_Row_Real_Matrix(bp, false);\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the inverse of the decomposed matrix.\r\n\r\n         *\r\n\r\n         * @return the inverse matrix.\r\n\r\n         * @ if the decomposed matrix is singular.\r\n\r\n         */\r\n\r\n        //override\r\n\r\n        public Real_Matrix get_inverse() \r\n\r\n        {\r\n\r\n            return solve(Matrix_Utils.create_real_identity_matrix(pivot.size()));\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_row_dimension() \r\n\r\n        {\r\n\r\n            return lu.size();\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int get_column_dimension() \r\n\r\n        {\r\n\r\n            return lu[0].size();\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n