/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n\r\n\r\n//import java.util.function.Function;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Field_Element;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n\r\n\r\n/**\r\n\r\n * Interface defining field-valued matrix with basic algebraic operations.\r\n\r\n * <p>\r\n\r\n * Matrix element indexing is 0-based -- e.g., <code>get_entry(0, 0)</code>\r\n\r\n * returns the element in the first row, first column of the matrix.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\nclass Field_Matrix<T extends Field_Element<T>> extends Any_Matrix \r\n\r\n{\r\n\r\n    /**\r\n\r\n     * Get the type of field elements of the matrix.\r\n\r\n     *\r\n\r\n     * @return the type of field elements of the matrix.\r\n\r\n     */\r\n\r\n    Field<T> get_field();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a Field_Matrix<T> of the same type as the instance with\r\n\r\n     * the supplied row and column dimensions.\r\n\r\n     *\r\n\r\n     * @param row_dimension  the number of rows in the matrix\r\n\r\n     * @param column_dimension  the number of columns in the matrix\r\n\r\n     * @return a matrix of the same type as the instance\r\n\r\n     * @ if row or column dimension is not\r\n\r\n     * positive.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> create_matrix(const int& row_dimension, int column_dimension)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Make a (deep) copy of this.\r\n\r\n     *\r\n\r\n     * @return a copy of this matrix.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> copy();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the sum of this and m.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be added.\r\n\r\n     * @return {@code this} + {@code m}.\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this} matrix.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> add(Field_Matrix<T> m) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtract {@code m} from this matrix.\r\n\r\n     *\r\n\r\n     * @param m Matrix to be subtracted.\r\n\r\n     * @return {@code this} - {@code m}.\r\n\r\n     * @ if {@code m} is not the same\r\n\r\n     * size as {@code this} matrix.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> subtract(Field_Matrix<T> m) ;\r\n\r\n\r\n\r\n     /**\r\n\r\n     * Increment each entry of this matrix.\r\n\r\n     *\r\n\r\n     * @param d Value to be added to each entry.\r\n\r\n     * @return {@code d} + {@code this}.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> scalar_add(T d);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiply each entry by {@code d}.\r\n\r\n     *\r\n\r\n     * @param d Value to multiply all entries by.\r\n\r\n     * @return {@code d} * {@code this}.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> scalar_multiply(T d);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Postmultiply this matrix by {@code m}.\r\n\r\n     *\r\n\r\n     * @param m  Matrix to postmultiply by.\r\n\r\n     * @return {@code this} * {@code m}.\r\n\r\n     * @ if the number of columns of\r\n\r\n     * {@code this} matrix is not equal to the number of rows of matrix\r\n\r\n     * {@code m}.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> multiply(Field_Matrix<T> m) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of postmultiplying {@code this} by {@code m^T}.\r\n\r\n     * <p>\r\n\r\n     * This is equivalent to call {@link #multiply(Field_Matrix) multiply}(m.{@link #transpose()}), * but some implementations may avoid building the intermediate transposed matrix.\r\n\r\n     * </p>\r\n\r\n     * @param m matrix to first transpose and second postmultiply by\r\n\r\n     * @return {@code this * m^T}\r\n\r\n     * @ if\r\n\r\n     * {@code column_dimension(this) != column_dimension(m)}\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    default Field_Matrix<T> multiply_transposed(const Field_Matrix<T> m)\r\n\r\n         \r\n\r\n        {\r\n\r\n        return multiply(m.transpose());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of postmultiplying {@code this^T} by {@code m}.\r\n\r\n     * <p>\r\n\r\n     * This is equivalent to call {@link #transpose()}.{@link #multiply(Field_Matrix) multiply(m)}, * but some implementations may avoid building the intermediate transposed matrix.\r\n\r\n     * </p>\r\n\r\n     * @param m matrix to postmultiply by\r\n\r\n     * @return {@code this^T * m}\r\n\r\n     * @ if\r\n\r\n     * {@code column_dimension(this) != column_dimension(m)}\r\n\r\n     * @since 1.3\r\n\r\n     */\r\n\r\n    default Field_Matrix<T> transpose_multiply(const Field_Matrix<T> m)\r\n\r\n         \r\n\r\n        {\r\n\r\n        return transpose().multiply(m);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Premultiply this matrix by {@code m}.\r\n\r\n     *\r\n\r\n     * @param m Matrix to premultiply by.\r\n\r\n     * @return {@code m} * {@code this}.\r\n\r\n     * @ if the number of columns of {@code m}\r\n\r\n     * differs from the number of rows of {@code this} matrix.\r\n\r\n     */\r\n\r\n    Field_Matrix<T> pre_multiply(Field_Matrix<T> m) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result multiplying this with itself <code>p</code> times.\r\n\r\n     * Depending on the type of the field elements, T, instability for high\r\n\r\n     * powers might occur.\r\n\r\n     *\r\n\r\n     * @param p raise this to power p\r\n\r\n     * @return this^p\r\n\r\n     * @ if {@code p < 0}\r\n\r\n     * @ if {@code this matrix} is not square\r\n\r\n     */\r\n\r\n    Field_Matrix<T> power(const int& p) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns matrix entries as a two-dimensional array.\r\n\r\n     *\r\n\r\n     * @return a 2-dimensional array of entries.\r\n\r\n     */\r\n\r\n    std::vector<std::vector<T>> get_data();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a submatrix. Rows and columns are indicated\r\n\r\n     * counting from 0 to n - 1.\r\n\r\n     *\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index (inclusive)\r\n\r\n     * @return the matrix containing the data of the specified rows and columns.\r\n\r\n     * @ is {@code end_row < start_row} of\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     */\r\n\r\n   Field_Matrix<T> get_sub_matrix(const int& start_row, int end_row, int start_column, int end_column)\r\n\r\n   ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Get a submatrix. Rows and columns are indicated\r\n\r\n    * counting from 0 to n - 1.\r\n\r\n    *\r\n\r\n    * @param selected_rows Array of row indices.\r\n\r\n    * @param selected_columns Array of column indices.\r\n\r\n    * @return the matrix containing the data in the\r\n\r\n    * specified rows and columns.\r\n\r\n    * @ if {@code selected_rows} or\r\n\r\n    * {@code selected_columns} is empty\r\n\r\n    * @Null_Argument_Exception if {@code selected_rows} or\r\n\r\n    * {@code selected_columns} is {@code null}.\r\n\r\n    * @ if row or column selections are not valid.\r\n\r\n    */\r\n\r\n   Field_Matrix<T> get_sub_matrix(std::vector<int> selected_rows, std::vector<int> selected_columns)\r\n\r\n   , Null_Argument_Exception;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Copy a submatrix. Rows and columns are 0-based. The designated submatrix\r\n\r\n    * is copied into the top left portion of the destination array.\r\n\r\n    *\r\n\r\n    * @param start_row Initial row index.\r\n\r\n    * @param end_row Final row index (inclusive).\r\n\r\n    * @param start_column Initial column index.\r\n\r\n    * @param end_column Final column index (inclusive).\r\n\r\n    * @param destination The array where the submatrix data should be copied\r\n\r\n    * (if larger than rows/columns counts, only the upper-left part will be modified).\r\n\r\n    * @ if the dimensions of\r\n\r\n    * {@code destination} are not large enough to hold the submatrix.\r\n\r\n    * @ if {@code end_row < start_row} or\r\n\r\n    * {@code end_column < start_column}.\r\n\r\n    * @ if the indices are not valid.\r\n\r\n    */\r\n\r\n    void copy_sub_matrix(const int& start_row, int end_row, int start_column, int end_column, std::vector<std::vector<T>> destination)\r\n\r\n    ;\r\n\r\n\r\n\r\n  /**\r\n\r\n   * Copy a submatrix. Rows and columns are indicated\r\n\r\n   * counting from 0 to n - 1.\r\n\r\n   *\r\n\r\n   * @param selected_rows Array of row indices.\r\n\r\n   * @param selected_columns Array of column indices.\r\n\r\n   * @param destination Arrays where the submatrix data should be copied\r\n\r\n   * (if larger than rows/columns counts, only the upper-left part will be used)\r\n\r\n   * @ if the dimensions of\r\n\r\n   * {@code destination} do not match those of {@code this}.\r\n\r\n   * @ if {@code selected_rows} or\r\n\r\n   * {@code selected_columns} is empty\r\n\r\n   * @Null_Argument_Exception if {@code selected_rows} or\r\n\r\n   * {@code selected_columns} is {@code null}.\r\n\r\n   * @ if the indices are not valid.\r\n\r\n   */\r\n\r\n  void copy_sub_matrix(std::vector<int> selected_rows, std::vector<int> selected_columns, std::vector<std::vector<T>> destination)\r\n\r\n  , Null_Argument_Exception;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Replace the submatrix starting at {@code (row, column)} using data in the\r\n\r\n     * input {@code sub_matrix} array. Indexes are 0-based.\r\n\r\n     * <p>\r\n\r\n     * Example:<br>\r\n\r\n     * Starting with\r\n\r\n     *\r\n\r\n     * <pre>\r\n\r\n     * 1  2  3  4\r\n\r\n     * 5  6  7  8\r\n\r\n     * 9  0  1  2\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * and <code>sub_matrix = {{3, 4} {5,6}}</code>, invoking\r\n\r\n     * <code>set_sub_matrix(sub_matrix,1,1))</code> will result in\r\n\r\n     *\r\n\r\n     * <pre>\r\n\r\n     * 1  2  3  4\r\n\r\n     * 5  3  4  8\r\n\r\n     * 9  5  6  2\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param sub_matrix Array containing the submatrix replacement data.\r\n\r\n     * @param row Row coordinate of the top-left element to be replaced.\r\n\r\n     * @param column Column coordinate of the top-left element to be replaced.\r\n\r\n     * @ if {@code sub_matrix} does not fit into this\r\n\r\n     * matrix from element in {@code (row, column)}.\r\n\r\n     * @ if a row or column of {@code sub_matrix} is empty.\r\n\r\n     * @ if {@code sub_matrix} is not\r\n\r\n     * rectangular (not all rows have the same length).\r\n\r\n     * @Null_Argument_Exception if {@code sub_matrix} is {@code null}.\r\n\r\n     */\r\n\r\n    void set_sub_matrix(std::vector<std::vector<T>> sub_matrix, int row, int column)\r\n\r\n        , Null_Argument_Exception;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Get the entries in row number {@code row}\r\n\r\n    * as a row matrix.\r\n\r\n    *\r\n\r\n    * @param row Row to be fetched.\r\n\r\n    * @return a row matrix.\r\n\r\n    * @ if the specified row index is invalid.\r\n\r\n    */\r\n\r\n   Field_Matrix<T> get_row_matrix(const int& row) ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Set the entries in row number {@code row}\r\n\r\n    * as a row matrix.\r\n\r\n    *\r\n\r\n    * @param row Row to be set.\r\n\r\n    * @param matrix Row matrix (must have one row and the same number\r\n\r\n    * of columns as the instance).\r\n\r\n    * @ if the specified row index is invalid.\r\n\r\n    * @\r\n\r\n    * if the matrix dimensions do not match one instance row.\r\n\r\n    */\r\n\r\n   void set_row_matrix(const int& row, Field_Matrix<T> matrix)\r\n\r\n   ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Get the entries in column number {@code column}\r\n\r\n    * as a column matrix.\r\n\r\n    *\r\n\r\n    * @param column Column to be fetched.\r\n\r\n    * @return a column matrix.\r\n\r\n    * @ if the specified column index is invalid.\r\n\r\n    */\r\n\r\n   Field_Matrix<T> get_column_matrix(const int& column) ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Set the entries in column number {@code column}\r\n\r\n    * as a column matrix.\r\n\r\n    *\r\n\r\n    * @param column Column to be set.\r\n\r\n    * @param matrix column matrix (must have one column and the same\r\n\r\n    * number of rows as the instance).\r\n\r\n    * @ if the specified column index is invalid.\r\n\r\n    * @ if the matrix dimensions do\r\n\r\n    * not match one instance column.\r\n\r\n    */\r\n\r\n   void set_column_matrix(const int& column, Field_Matrix<T> matrix)\r\n\r\n   ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Get the entries in row number {@code row}\r\n\r\n    * as a vector.\r\n\r\n    *\r\n\r\n    * @param row Row to be fetched\r\n\r\n    * @return a row vector.\r\n\r\n    * @ if the specified row index is invalid.\r\n\r\n    */\r\n\r\n   Field_Vector<T> get_row_vector(const int& row) ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Set the entries in row number {@code row}\r\n\r\n    * as a vector.\r\n\r\n    *\r\n\r\n    * @param row Row to be set.\r\n\r\n    * @param vector row vector (must have the same number of columns\r\n\r\n    * as the instance).\r\n\r\n    * @ if the specified row index is invalid.\r\n\r\n    * @ if the vector dimension does not\r\n\r\n    * match one instance row.\r\n\r\n    */\r\n\r\n   void set_row_vector(const int& row, Field_Vector<T> vector)\r\n\r\n   ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Returns the entries in column number {@code column}\r\n\r\n    * as a vector.\r\n\r\n    *\r\n\r\n    * @param column Column to be fetched.\r\n\r\n    * @return a column vector.\r\n\r\n    * @ if the specified column index is invalid.\r\n\r\n    */\r\n\r\n   Field_Vector<T> get_column_vector(const int& column) ;\r\n\r\n\r\n\r\n   /**\r\n\r\n    * Set the entries in column number {@code column}\r\n\r\n    * as a vector.\r\n\r\n    *\r\n\r\n    * @param column Column to be set.\r\n\r\n    * @param vector Column vector (must have the same number of rows\r\n\r\n    * as the instance).\r\n\r\n    * @ if the specified column index is invalid.\r\n\r\n    * @ if the vector dimension does not\r\n\r\n    * match one instance column.\r\n\r\n    */\r\n\r\n   void set_column_vector(const int& column, Field_Vector<T> vector)\r\n\r\n   ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the entries in row number {@code row} as an array.\r\n\r\n     *\r\n\r\n     * @param row Row to be fetched.\r\n\r\n     * @return array of entries in the row.\r\n\r\n     * @ if the specified row index is not valid.\r\n\r\n     */\r\n\r\n    std::vector<T> get_row(const int& row) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set the entries in row number {@code row}\r\n\r\n     * as a row matrix.\r\n\r\n     *\r\n\r\n     * @param row Row to be set.\r\n\r\n     * @param array Row matrix (must have the same number of columns as\r\n\r\n     * the instance).\r\n\r\n     * @ if the specified row index is invalid.\r\n\r\n     * @ if the array size does not match\r\n\r\n     * one instance row.\r\n\r\n     */\r\n\r\n    void set_row(const int& row, std::vector<T> array) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the entries in column number {@code col} as an array.\r\n\r\n     *\r\n\r\n     * @param column the column to be fetched\r\n\r\n     * @return array of entries in the column\r\n\r\n     * @ if the specified column index is not valid.\r\n\r\n     */\r\n\r\n    std::vector<T> get_column(const int& column) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set the entries in column number {@code column}\r\n\r\n     * as a column matrix.\r\n\r\n     *\r\n\r\n     * @param column the column to be set\r\n\r\n     * @param array column array (must have the same number of rows as the instance)\r\n\r\n     * @ if the specified column index is invalid.\r\n\r\n     * @ if the array size does not match\r\n\r\n     * one instance column.\r\n\r\n     */\r\n\r\n    void set_column(const int& column, std::vector<T> array) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the entry in the specified row and column.\r\n\r\n     *\r\n\r\n     * @param row  row location of entry to be fetched\r\n\r\n     * @param column  column location of entry to be fetched\r\n\r\n     * @return matrix entry in row,column\r\n\r\n     * @ if the row or column index is not valid.\r\n\r\n     */\r\n\r\n    T get_entry(const int& row, const int& column) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set the entry in the specified row and column.\r\n\r\n     *\r\n\r\n     * @param row  row location of entry to be set\r\n\r\n     * @param column  column location of entry to be set\r\n\r\n     * @param value matrix entry to be set in row,column\r\n\r\n     * @ if the row or column index is not valid.\r\n\r\n     */\r\n\r\n    void set_entry(const int& row, const int& column, T value) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Change an entry in the specified row and column.\r\n\r\n     *\r\n\r\n     * @param row Row location of entry to be set.\r\n\r\n     * @param column Column location of entry to be set.\r\n\r\n     * @param increment Value to add to the current matrix entry in\r\n\r\n     * {@code (row, column)}.\r\n\r\n     * @ if the row or column index is not valid.\r\n\r\n     */\r\n\r\n    void add_to_entry(const int& row, const int& column, T increment) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Change an entry in the specified row and column.\r\n\r\n     *\r\n\r\n     * @param row Row location of entry to be set.\r\n\r\n     * @param column Column location of entry to be set.\r\n\r\n     * @param factor Multiplication factor for the current matrix entry\r\n\r\n     * in {@code (row,column)}\r\n\r\n     * @ if the row or column index is not valid.\r\n\r\n     */\r\n\r\n    void multiply_entry(const int& row, const int& column, T factor) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the transpose of this matrix.\r\n\r\n     *\r\n\r\n     * @return transpose matrix\r\n\r\n     */\r\n\r\n    Field_Matrix<T> transpose();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the <a href="http://mathworld.wolfram.com/MatrixTrace.html">\r\n\r\n     * trace</a> of the matrix (the sum of the elements on the main diagonal).\r\n\r\n     *\r\n\r\n     * @return trace\r\n\r\n     * @ if the matrix is not square.\r\n\r\n     */\r\n\r\n    T get_trace() ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of multiplying this by the vector {@code v}.\r\n\r\n     *\r\n\r\n     * @param v the vector to operate on\r\n\r\n     * @return {@code this * v}\r\n\r\n     * @ if the number of columns of\r\n\r\n     * {@code this} matrix is not equal to the size of the vector {@code v}.\r\n\r\n     */\r\n\r\n    std::vector<T> operate(std::vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the result of multiplying this by the vector {@code v}.\r\n\r\n     *\r\n\r\n     * @param v the vector to operate on\r\n\r\n     * @return {@code this * v}\r\n\r\n     * @ if the number of columns of\r\n\r\n     * {@code this} matrix is not equal to the size of the vector {@code v}.\r\n\r\n     */\r\n\r\n    Field_Vector<T> operate(Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the (row) vector result of premultiplying this by the vector\r\n\r\n     * {@code v}.\r\n\r\n     *\r\n\r\n     * @param v the row vector to premultiply by\r\n\r\n     * @return {@code v * this}\r\n\r\n     * @ if the number of rows of {@code this}\r\n\r\n     * matrix is not equal to the size of the vector {@code v}\r\n\r\n     */\r\n\r\n    std::vector<T> pre_multiply(std::vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the (row) vector result of premultiplying this by the vector\r\n\r\n     * {@code v}.\r\n\r\n     *\r\n\r\n     * @param v the row vector to premultiply by\r\n\r\n     * @return {@code v * this}\r\n\r\n     * @ if the number of rows of {@code this}\r\n\r\n     * matrix is not equal to the size of the vector {@code v}\r\n\r\n     */\r\n\r\n    Field_Vector<T> pre_multiply(Field_Vector<T> v) ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) all matrix entries in row order.\r\n\r\n     * <p>Row order starts at upper left and iterating through all elements\r\n\r\n     * of a row from left to right before going to the leftmost element\r\n\r\n     * of the next row.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_row_order(Field_Matrix_changingVisitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) all matrix entries in row order.\r\n\r\n     * <p>Row order starts at upper left and iterating through all elements\r\n\r\n     * of a row from left to right before going to the leftmost element\r\n\r\n     * of the next row.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_row_order(Field_Matrix_Preserving_Visitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) some matrix entries in row order.\r\n\r\n     * <p>Row order starts at upper left and iterating through all elements\r\n\r\n     * of a row from left to right before going to the leftmost element\r\n\r\n     * of the next row.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_row_order(Field_Matrix_changingVisitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) some matrix entries in row order.\r\n\r\n     * <p>Row order starts at upper left and iterating through all elements\r\n\r\n     * of a row from left to right before going to the leftmost element\r\n\r\n     * of the next row.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_row_order(Field_Matrix_Preserving_Visitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) all matrix entries in column order.\r\n\r\n     * <p>Column order starts at upper left and iterating through all elements\r\n\r\n     * of a column from top to bottom before going to the topmost element\r\n\r\n     * of the next column.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_column_order(Field_Matrix_changingVisitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) all matrix entries in column order.\r\n\r\n     * <p>Column order starts at upper left and iterating through all elements\r\n\r\n     * of a column from top to bottom before going to the topmost element\r\n\r\n     * of the next column.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_column_order(Field_Matrix_Preserving_Visitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) some matrix entries in column order.\r\n\r\n     * <p>Column order starts at upper left and iterating through all elements\r\n\r\n     * of a column from top to bottom before going to the topmost element\r\n\r\n     * of the next column.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_column_order(Field_Matrix_changingVisitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) some matrix entries in column order.\r\n\r\n     * <p>Column order starts at upper left and iterating through all elements\r\n\r\n     * of a column from top to bottom before going to the topmost element\r\n\r\n     * of the next column.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_column_order(Field_Matrix_Preserving_Visitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) all matrix entries using the fastest possible order.\r\n\r\n     * <p>The fastest walking order depends on the exact matrix class. It may be\r\n\r\n     * different from traditional row or column orders.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_optimized_order(Field_Matrix_changingVisitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) all matrix entries using the fastest possible order.\r\n\r\n     * <p>The fastest walking order depends on the exact matrix class. It may be\r\n\r\n     * different from traditional row or column orders.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_optimized_order(Field_Matrix_Preserving_Visitor<T> visitor);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (and possibly change) some matrix entries using the fastest possible order.\r\n\r\n     * <p>The fastest walking order depends on the exact matrix class. It may be\r\n\r\n     * different from traditional row or column orders.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index (inclusive)\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_changingVisitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_optimized_order(Field_Matrix_changingVisitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Visit (but don't change) some matrix entries using the fastest possible order.\r\n\r\n     * <p>The fastest walking order depends on the exact matrix class. It may be\r\n\r\n     * different from traditional row or column orders.</p>\r\n\r\n     * @param visitor visitor used to process all matrix entries\r\n\r\n     * @param start_row Initial row index\r\n\r\n     * @param end_row Final row index (inclusive)\r\n\r\n     * @param start_column Initial column index\r\n\r\n     * @param end_column Final column index (inclusive)\r\n\r\n     * @ if {@code end_row < start_row} or\r\n\r\n     * {@code end_column < start_column}.\r\n\r\n     * @ if the indices are not valid.\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_row_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @see #walk_in_column_order(Field_Matrix_Preserving_Visitor, int, int, int, int)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_Preserving_Visitor)\r\n\r\n     * @see #walk_in_optimized_order(Field_Matrix_changingVisitor, int, int, int, int)\r\n\r\n     * @return the value returned by {@link Field_Matrix_Preserving_Visitor#end()} at the end\r\n\r\n     * of the walk\r\n\r\n     */\r\n\r\n    T walk_in_optimized_order(Field_Matrix_Preserving_Visitor<T> visitor, int start_row, int end_row, int start_column, int end_column)\r\n\r\n    ;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Acts as if implemented as:\r\n\r\n     * <pre>\r\n\r\n     *  return copy().map_to_self(function);\r\n\r\n     * </pre>\r\n\r\n     * Returns a matrix. Does not change instance data.\r\n\r\n     *\r\n\r\n     * @param function Function to apply to each entry.\r\n\r\n     * @return a matrix.\r\n\r\n     * @since 1.7\r\n\r\n     */\r\n\r\n    default Field_Matrix<T> map(Function<T, T> function) \r\n\r\n    {\r\n\r\n        return copy().map_to_self(function);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Replace each entry by the result of applying the function to it.\r\n\r\n     *\r\n\r\n     * @param function Function to apply to each entry.\r\n\r\n     * @return a reference to this matrix.\r\n\r\n     * @since 1.7\r\n\r\n     */\r\n\r\n    default Field_Matrix<T> map_to_self(const Function<T,T> function) \r\n\r\n    {\r\n\r\n        walk_in_optimized_order(new Field_Matrix_changingVisitor<T>() \r\n\r\n        {\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public T visit(const int& row, const int& column, T value) \r\n\r\n            {\r\n\r\n                // apply the function to the current entry\r\n\r\n                return function.apply(value);\r\n\r\n            }\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public void start(const int& rows, int columns, int start_row, int end_row, int start_column, int end_column) \r\n\r\n            {\r\n\r\n            }\r\n\r\n\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public T end() \r\n\r\n            {\r\n\r\n                return get_field().get_zero();\r\n\r\n            }\r\n\r\n\r\n\r\n        });\r\n\r\n\r\n\r\n        return this;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n