/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n#include "MatrixUtils.h"\r\n\r\n//package org.hipparchus.linear;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/**\r\n\r\n * Class transforming a general real matrix to Hessenberg form.\r\n\r\n * <p>A m &times; m matrix A can be written as the product of three matrices: A = P\r\n\r\n * &times; H &times; P<sup>T</sup> with P an orthogonal matrix and H a Hessenberg\r\n\r\n * matrix. Both P and H are m &times; m matrices.</p>\r\n\r\n * <p>Transformation to Hessenberg form is often not a goal by itself, but it is an\r\n\r\n * intermediate step in more general decomposition algorithms like\r\n\r\n * {@link Eigen_Decomposition eigen decomposition}. This class is therefore\r\n\r\n * intended for internal use by the library and is not public. As a consequence\r\n\r\n * of this explicitly limited scope, many methods directly returns references to\r\n\r\n * internal arrays, not copies.</p>\r\n\r\n * <p>This class is based on the method orthes in class Eigenvalue_Decomposition\r\n\r\n * from the <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> library.</p>\r\n\r\n *\r\n\r\n * @see <a href="http://mathworld.wolfram.com/HessenbergDecomposition.html">MathWorld</a>\r\n\r\n * @see <a href="http://en.wikipedia.org/wiki/Householder_transformation">Householder Transformations</a>\r\n\r\n */\r\n\r\nclass Hessenberg_Transformer \r\n\r\n{\r\n\r\n    /** Householder vectors. */\r\n\r\n    private const double householder_vectors[][];\r\n\r\n    /** Temporary storage vector. */\r\n\r\n    private const double ort[];\r\n\r\n    /** Cached value of P. */\r\n\r\n    private Real_Matrix cached_p;\r\n\r\n    /** Cached value of Pt. */\r\n\r\n    private Real_Matrix cached_pt;\r\n\r\n    /** Cached value of H. */\r\n\r\n    private Real_Matrix cached_h;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build the transformation to Hessenberg form of a general matrix.\r\n\r\n     *\r\n\r\n     * @param matrix matrix to transform\r\n\r\n     * @ if the matrix is not square\r\n\r\n     */\r\n\r\n    Hessenberg_Transformer(const Real_Matrix matrix) \r\n\r\n    {\r\n\r\n        if (!matrix.is_square()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NON_SQUARE_MATRIX, matrix.get_row_dimension(), matrix.get_column_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int m = matrix.get_row_dimension();\r\n\r\n        householder_vectors = matrix.get_data();\r\n\r\n        ort = std::vector<double>(m];\r\n\r\n        cached_p = null;\r\n\r\n        cached_pt = null;\r\n\r\n        cached_h = null;\r\n\r\n\r\n\r\n        // transform matrix\r\n\r\n        transform();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the matrix P of the transform.\r\n\r\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\r\n\r\n     *\r\n\r\n     * @return the P matrix\r\n\r\n     */\r\n\r\n    public Real_Matrix get_p() \r\n\r\n    {\r\n\r\n        if (cached_p == null) \r\n\r\n        {\r\n\r\n            const int n = householder_vectors.size();\r\n\r\n            const int high = n - 1;\r\n\r\n            const std::vector<std::vector<double>> pa = std::vector<double>(n][n];\r\n\r\n\r\n\r\n            for (int i{}; i < n; i++) \r\n\r\n            {\r\n\r\n                for (int j{}; j < n; j++) \r\n\r\n                {\r\n\r\n                    pa[i][j] = (i == j) ? 1 : 0;\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            for (const int& m = high - 1; m >= 1; m--) \r\n\r\n            {\r\n\r\n                if (householder_vectors[m][m - 1] != 0.0) \r\n\r\n                {\r\n\r\n                    for (int i = m + 1; i <= high; i++) \r\n\r\n                    {\r\n\r\n                        ort[i] = householder_vectors[i][m - 1];\r\n\r\n                    }\r\n\r\n\r\n\r\n                    for (int j = m; j <= high; j++) \r\n\r\n                    {\r\n\r\n                        double g = 0.0;\r\n\r\n\r\n\r\n                        for (int i = m; i <= high; i++) \r\n\r\n                        {\r\n\r\n                            g += ort[i] * pa[i][j];\r\n\r\n                        }\r\n\r\n\r\n\r\n                        // Double division avoids possible underflow\r\n\r\n                        g = (g / ort[m]) / householder_vectors[m][m - 1];\r\n\r\n\r\n\r\n                        for (int i = m; i <= high; i++) \r\n\r\n                        {\r\n\r\n                            pa[i][j] += g * ort[i];\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n            cached_p = Matrix_Utils.create_real_matrix(pa);\r\n\r\n        }\r\n\r\n        return cached_p;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the transpose of the matrix P of the transform.\r\n\r\n     * <p>P is an orthogonal matrix, i.e. its inverse is also its transpose.</p>\r\n\r\n     *\r\n\r\n     * @return the transpose of the P matrix\r\n\r\n     */\r\n\r\n    public Real_Matrix get_p_t() \r\n\r\n    {\r\n\r\n        if (cached_pt == null) \r\n\r\n        {\r\n\r\n            cached_pt = get_p().transpose();\r\n\r\n        }\r\n\r\n\r\n\r\n        // return the cached matrix\r\n\r\n        return cached_pt;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the Hessenberg matrix H of the transform.\r\n\r\n     *\r\n\r\n     * @return the H matrix\r\n\r\n     */\r\n\r\n    public Real_Matrix get_h() \r\n\r\n    {\r\n\r\n        if (cached_h == null) \r\n\r\n        {\r\n\r\n            const int m = householder_vectors.size();\r\n\r\n            const std::vector<std::vector<double>> h = std::vector<double>(m][m];\r\n\r\n            for (int i{}; i < m; ++i) \r\n\r\n            {\r\n\r\n                if (i > 0) \r\n\r\n                {\r\n\r\n                    // copy the entry of the lower sub-diagonal\r\n\r\n                    h[i][i - 1] = householder_vectors[i][i - 1];\r\n\r\n                }\r\n\r\n\r\n\r\n                // copy upper triangular part of the matrix\r\n\r\n                for (int j = i; j < m; ++j) \r\n\r\n                {\r\n\r\n                    h[i][j] = householder_vectors[i][j];\r\n\r\n                }\r\n\r\n            }\r\n\r\n            cached_h = Matrix_Utils.create_real_matrix(h);\r\n\r\n        }\r\n\r\n\r\n\r\n        // return the cached matrix\r\n\r\n        return cached_h;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the Householder vectors of the transform.\r\n\r\n     * <p>Note that since this class is only intended for internal use, it returns\r\n\r\n     * directly a reference to its internal arrays, not a copy.</p>\r\n\r\n     *\r\n\r\n     * @return the main diagonal elements of the B matrix\r\n\r\n     */\r\n\r\n    std::vector<std::vector<double>> get_householder_vectors_ref() \r\n\r\n    {\r\n\r\n        return householder_vectors; // NOPMD - returning an internal array is intentional and documented here\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Transform original matrix to Hessenberg form.\r\n\r\n     * <p>Transformation is done using Householder transforms.</p>\r\n\r\n     */\r\n\r\n    private void transform() \r\n\r\n    {\r\n\r\n        const int n = householder_vectors.size();\r\n\r\n        const int high = n - 1;\r\n\r\n\r\n\r\n        for (const int& m = 1; m <= high - 1; m++) \r\n\r\n        {\r\n\r\n            // Scale column.\r\n\r\n            double scale = 0;\r\n\r\n            for (int i = m; i <= high; i++) \r\n\r\n            {\r\n\r\n                scale += std::abs(householder_vectors[i][m - 1]);\r\n\r\n            }\r\n\r\n\r\n\r\n            if (!Precision.equals(scale, 0)) \r\n\r\n            {\r\n\r\n                // Compute Householder transformation.\r\n\r\n                double h = 0;\r\n\r\n                for (int i = high; i >= m; i--) \r\n\r\n                {\r\n\r\n                    ort[i] = householder_vectors[i][m - 1] / scale;\r\n\r\n                    h += ort[i] * ort[i];\r\n\r\n                }\r\n\r\n                const double g = (ort[m] > 0) ? -std::sqrt(h) : std::sqrt(h);\r\n\r\n\r\n\r\n                h -= ort[m] * g;\r\n\r\n                ort[m] -= g;\r\n\r\n\r\n\r\n                // Apply Householder similarity transformation\r\n\r\n                // H = (I - u*u' / h) * H * (I - u*u' / h)\r\n\r\n\r\n\r\n                for (int j = m; j < n; j++) \r\n\r\n                {\r\n\r\n                    double f = 0;\r\n\r\n                    for (int i = high; i >= m; i--) \r\n\r\n                    {\r\n\r\n                        f += ort[i] * householder_vectors[i][j];\r\n\r\n                    }\r\n\r\n                    f /= h;\r\n\r\n                    for (int i = m; i <= high; i++) \r\n\r\n                    {\r\n\r\n                        householder_vectors[i][j] -= f * ort[i];\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                for (int i{}; i <= high; i++) \r\n\r\n                {\r\n\r\n                    double f = 0;\r\n\r\n                    for (int j = high; j >= m; j--) \r\n\r\n                    {\r\n\r\n                        f += ort[j] * householder_vectors[i][j];\r\n\r\n                    }\r\n\r\n                    f /= h;\r\n\r\n                    for (int j = m; j <= high; j++) \r\n\r\n                    {\r\n\r\n                        householder_vectors[i][j] -= f * ort[j];\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                ort[m] = scale * ort[m];\r\n\r\n                householder_vectors[m][m - 1] = scale * g;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n