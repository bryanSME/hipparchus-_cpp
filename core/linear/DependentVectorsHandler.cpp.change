/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.linear;\r\n\r\n#include "MatrixUtils.h"\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n\r\n\r\n/** Enumerate to specify how dependent vectors should be handled in\r\n\r\n * {@link Matrix_Utils#orthonormalize(List, double, Dependent_Vectors_Handler)} and\r\n\r\n * {@link Matrix_Utils#orthonormalize(Field, List, Calculus_Field_Element, Dependent_Vectors_Handler)}.\r\n\r\n * @since 2.1\r\n\r\n */\r\n\r\npublic enum Dependent_Vectors_Handler \r\n\r\n{\r\n\r\n\r\n\r\n    /** Generate a {@link } if dependent vectors are found. */\r\n\r\n    GENERATE_EXCEPTION \r\n\r\n    {\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int manage_dependent(const int index, const List<Real_Vector> basis) \r\n\r\n        {\r\n\r\n            // generate exception, dependent vectors are forbidden with this settings\r\n\r\n            throw (Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n        public  int manage_dependent(const Field<T> field, const int index, const List<Field_Vector<T>> basis) \r\n\r\n        {\r\n\r\n            // generate exception, dependent vectors are forbidden with this settings\r\n\r\n            throw (Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n    }, \r\n\r\n    /** Replace dependent vectors by vectors with norm 0.\r\n\r\n     * <p>\r\n\r\n     * This behavior matches the Wolfram language API. It keeps the\r\n\r\n     * number of output vectors equal to the number of input vectors.\r\n\r\n     * The only two norms output vectors can have are 0 and 1.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    ADD_ZERO_VECTOR \r\n\r\n    {\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int manage_dependent(const int index, const List<Real_Vector> basis) \r\n\r\n        {\r\n\r\n            // add a zero vector, preserving output vector size (and dropping its normalization property)\r\n\r\n            basis.set(index, Matrix_Utils.create_real__vector(basis.get(index).get_dimension()));\r\n\r\n            return index + 1;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n        public  int manage_dependent(const Field<T> field, const int index, const List<Field_Vector<T>> basis) \r\n\r\n        {\r\n\r\n            // add a zero vector, preserving output vector size (and dropping its normalization property)\r\n\r\n            basis.set(index, Matrix_Utils.create_field_vector(field, basis.get(index).get_dimension()));\r\n\r\n            return index + 1;\r\n\r\n        }\r\n\r\n\r\n\r\n    }, \r\n\r\n    /** Ignore dependent vectors.\r\n\r\n     * <p>\r\n\r\n     * This behavior ensures the output vectors form an orthonormal\r\n\r\n     * basis, i.e. all vectors are independent and they all have norm 1.\r\n\r\n     * The number of output vectors may be smaller than the number of\r\n\r\n     * input vectors, this number corresponds to the dimension of the\r\n\r\n     * span of the input vectors.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    REDUCE_BASE_TO_SPAN \r\n\r\n    {\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public int manage_dependent(const int index, const List<Real_Vector> basis) \r\n\r\n        {\r\n\r\n            // remove dependent vector\r\n\r\n            basis.remove(index);\r\n\r\n            return index;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n        public  int manage_dependent(const Field<T> field, const int index, const List<Field_Vector<T>> basis) \r\n\r\n        {\r\n\r\n            // remove dependent vector\r\n\r\n            basis.remove(index);\r\n\r\n            return index;\r\n\r\n        }\r\n\r\n\r\n\r\n    };\r\n\r\n\r\n\r\n    /** Manage a dependent vector.\r\n\r\n     * @param index of the vector in the basis\r\n\r\n     * @param basis placeholder for basis vectors\r\n\r\n     * @return next index to manage\r\n\r\n     */\r\n\r\n    public virtual int manage_dependent(const int& index, List<Real_Vector> basis);\r\n\r\n\r\n\r\n    /** Manage a dependent vector.\r\n\r\n     * @param <T> type of the vectors components\r\n\r\n     * @param field field to which the vectors belong\r\n\r\n     * @param index of the vector in the basis\r\n\r\n     * @param basis placeholder for basis vectors\r\n\r\n     * @return next index to manage\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public virtual  int manage_dependent(Field<T> field, int index, List<Field_Vector<T>> basis);\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n