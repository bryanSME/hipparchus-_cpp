/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.complex;\r\n\r\n\r\n\r\n//import java.util.Hash_Map;\r\n\r\n//import java.util.Map;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n#include <type_traits>\r\n\r\n#include "../CalculusFieldElement.h"\r\n\r\n#include <unordered_map>\r\n\r\n\r\n\r\n/**\r\n\r\n * Representation of the complex numbers field.\r\n\r\n * <p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @see Field_std::complex<double>\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\ntemplate<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element<T>, T>::value>::type* = nullptr>\r\n\r\nclass Field_Complex_Field : public Field<Field_Complex<T>>\r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** Cached fields. */\r\n\r\n    static const Map<Field< ? >, Field_Complex_Field< ? >> CACHE = std::unordered_map<>();\r\n\r\n\r\n\r\n    /** Constant 0. */\r\n\r\n    const Field_Complex<T> my_zero;\r\n\r\n\r\n\r\n    /** Constant 1. */\r\n\r\n    const Field_Complex<T> my_one;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param field type of the field element\r\n\r\n     */\r\n\r\n    Field_Complex_Field(const Field<T> field) \r\n\r\n    {\r\n\r\n        zero = Field_std::complex<double>.get_zero(field);\r\n\r\n        one = Field_std::complex<double>.get_one(field);\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Get the field for complex numbers.\r\n\r\n     * @param parts_field field for the real and imaginary parts\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return cached field\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex_Field<T> get_field(const Field<T> parts_field)\r\n\r\n    {\r\n\r\n        Field_Complex_Field< ? > cached_field;\r\n\r\n        synchronized(CACHE)\r\n\r\n        {\r\n\r\n            cached_field = CACHE.get(parts_field);\r\n\r\n            if (cached_field == null)\r\n\r\n            {\r\n\r\n                cached_field = Field_Complex_Field<>(parts_field);\r\n\r\n                CACHE.put(parts_field, cached_field);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        //@Suppress_Warnings("unchecked")\r\n\r\n        const Field_Complex_Field<T> t_cached = (Field_Complex_Field<T>) cached_field;\r\n\r\n        return t_cached;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> get_one() const\r\n\r\n    {\r\n\r\n        return my_one;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> get_zero() const\r\n\r\n    {\r\n\r\n        return my_zero;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    //override\r\n\r\n    Class<Field_Complex<T>> get_runtime_class()\r\n\r\n    {\r\n\r\n        return (Class<Field_Complex<T>>) get_zero().get_class();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    bool equals(const Object& other)\r\n\r\n    {\r\n\r\n        return this == other;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    int hash_code() const\r\n\r\n    {\r\n\r\n        return 0xd368f208;\r\n\r\n    }\r\n\r\n\r\n\r\n};\r\n