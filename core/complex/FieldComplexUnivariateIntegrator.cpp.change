/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.complex;\r\n\r\n\r\n\r\n//import java.util.function.Function;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.analysis.integration.Field_Univariate_Integrator;\r\n\r\n\r\n\r\n/**\r\n\r\n * Wrapper to perform univariate complex integration using an underlying real integration algorithms.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 2.0\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_std::complex<double>_Univariate_Integrator  \r\n\r\n{\r\n\r\n\r\n\r\n    /** Underlying real integrator. */\r\n\r\n    private Field_Univariate_Integrator<T> integrator;\r\n\r\n\r\n\r\n    /** Crate a complex integrator from a real integrator.\r\n\r\n     * @param integrator underlying real integrator to use\r\n\r\n     */\r\n\r\n    public Field_std::complex<double>_Univariate_Integrator(const Field_Univariate_Integrator<T> integrator) \r\n\r\n    {\r\n\r\n        this.integrator = integrator;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Integrate a function along a straight path between points.\r\n\r\n     *\r\n\r\n     * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n     * parts are evaluated separately, so up to twice this number may be used)\r\n\r\n     * @param f the integrand function\r\n\r\n     * @param start start point of the integration path\r\n\r\n     * @param end end point of the integration path\r\n\r\n     * @return the value of integral along the straight path\r\n\r\n     */\r\n\r\n    public Field_Complex<T> integrate(const int max_eval, const Calculus_Field_Univariate_Function<Field_Complex<T>> f, const Field_Complex<T> start, const Field_Complex<T> end) \r\n\r\n    {\r\n\r\n\r\n\r\n        // linear mapping from real interval [0; 1] to function value along complex straight path from start to end\r\n\r\n        const Field_Complex<T>              rate   = end.subtract(start);\r\n\r\n        const Function<T, Field_Complex<T>> mapped = t -> f.value(start.add(rate.multiply(t)));\r\n\r\n\r\n\r\n        const T zero = start.get_real_part().get_field().get_zero();\r\n\r\n        const T one  = start.get_real_part().get_field().get_one();\r\n\r\n\r\n\r\n        // integrate real and imaginary parts separately\r\n\r\n        const T real      = integrator.integrate(max_eval, t -> mapped.apply(t).get_real_part(),      zero, one);\r\n\r\n        const T imaginary = integrator.integrate(max_eval, t -> mapped.apply(t).get_imaginary_part(), zero, one);\r\n\r\n\r\n\r\n        // combine integrals\r\n\r\n        return Field_std::complex<double><>(real, imaginary).multiply(rate);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Integrate a function along a polyline path between any number of points.\r\n\r\n     *\r\n\r\n     * @param max_eval maximum number of evaluations (real and imaginary\r\n\r\n     * parts are evaluated separately and each path segments are also evaluated\r\n\r\n     * separately, so up to 2n times this number may be used for n segments)\r\n\r\n     * @param f the integrand function\r\n\r\n     * @param start start point of the integration path\r\n\r\n     * @param path successive points defining the path vertices\r\n\r\n     * @return the value of integral along the polyline path\r\n\r\n     */\r\n\r\n    public Field_Complex<T> integrate(const int max_eval, const Calculus_Field_Univariate_Function<Field_Complex<T>> f, const Field_Complex<T> start, ////@Suppress_Warnings("unchecked") const Field_Complex<T>...path) \r\n\r\n    {\r\n\r\n        Field_Complex<T> sum      = start.new_instance(0);\r\n\r\n        Field_Complex<T> previous = start;\r\n\r\n        for (const Field_Complex<T> current : path) \r\n\r\n        {\r\n\r\n            sum = sum.add(integrate(max_eval, f, previous, current));\r\n\r\n            previous = current;\r\n\r\n        }\r\n\r\n        return sum;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n