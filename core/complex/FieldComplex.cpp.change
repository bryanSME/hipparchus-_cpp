/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Null_Argument_Exception;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n//import org.hipparchus.util.Field_Sinh_Cosh;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n#include <cmath>\r\n\r\n#include "../CalculusFieldElement.h"\r\n\r\n#include <type_traits>\r\n\r\n\r\n\r\n/**\r\n\r\n * Representation of a std::complex<double> number, i.e. a number which has both a\r\n\r\n * real and imaginary part.\r\n\r\n * <p>\r\n\r\n * Implementations of arithmetic operations handle {@code NaN} and\r\n\r\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\r\n\r\n * {@link #equals} is an equivalence relation for all instances that have\r\n\r\n * a {@code NaN} in either real or imaginary part, e.g. the following are\r\n\r\n * considered equal:\r\n\r\n * <ul>\r\n\r\n *  <li>{@code 1 + NaNi}</li>\r\n\r\n *  <li>{@code NaN + i}</li>\r\n\r\n *  <li>{@code NaN + NaNi}</li>\r\n\r\n * </ul>\r\n\r\n * <p>\r\n\r\n * Note that this contradicts the IEEE-754 standard for floating\r\n\r\n * point numbers (according to which the test {@code x == x} must fail if\r\n\r\n * {@code x} is {@code NaN}). The method\r\n\r\n * {@link org.hipparchus.util.Precision#equals(double,double,int)\r\n\r\n * equals for primitive double} in {@link org.hipparchus.util.Precision}\r\n\r\n * conforms with IEEE-754 while this class conforms with the standard behavior\r\n\r\n * for Java object types.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\ntemplate<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element<T>, T>::value>::type* = nullptr>\r\n\r\nclass Field_std::complex<double> : Calculus_Field_Element<Field_Complex<T>>  \r\n\r\n{\r\n\r\nprivate:\r\n\r\n    /** A real number representing log(10). */\r\n\r\n    static constexpr double LOG10{ 2.302585092994045684 };\r\n\r\n\r\n\r\n    /** The imaginary part. */\r\n\r\n    const T my_imaginary;\r\n\r\n\r\n\r\n    /** The real part. */\r\n\r\n    const T my_real;\r\n\r\n\r\n\r\n    /** Record whether this complex number is equal to NaN. */\r\n\r\n    const bool my_is_nan;\r\n\r\n\r\n\r\n    /** Record whether this complex number is infinite. */\r\n\r\n    const bool my_is_infinite;\r\n\r\n\r\n\r\nprotected:\r\n\r\n    /**\r\n\r\n     * Create a complex number given the real and imaginary parts.\r\n\r\n     *\r\n\r\n     * @param real_part Real part.\r\n\r\n     * @param imaginary_part Imaginary part.\r\n\r\n     * @return a complex number instance.\r\n\r\n     *\r\n\r\n     * @see #value_of(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    Field_Complex<T> create_complex(const T real_part, const T imaginary_part)\r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(real_part, imaginary_part);\r\n\r\n    }\r\n\r\n\r\n\r\npublic:\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a complex number given only the real part.\r\n\r\n     *\r\n\r\n     * @param real Real part.\r\n\r\n     */\r\n\r\n    Field_std::complex<double>(T real) \r\n\r\n    {\r\n\r\n        Field_std::complex<double>(real, real.get_field().get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a complex number given the real and imaginary parts.\r\n\r\n     *\r\n\r\n     * @param real Real part.\r\n\r\n     * @param imaginary Imaginary part.\r\n\r\n     */\r\n\r\n    Field_std::complex<double>(const T& real, const T& imaginary) : my_real{ real }, my_imaginary{ imaginary }\r\n\r\n    {\r\n\r\n        my_is_nan = real.get_is_nan() || imaginary.get_is_nan();\r\n\r\n        my_is_infinite = !is_nan && (real.get_is_infinite() || imaginary.get_is_infinite());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the square root of -1.\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return number representing "0.0 + 1.0i"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_i(const Field<T>& field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_zero(), field.get_one());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the square root of -1.\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return number representing "0.0 _ 1.0i"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_minus_i(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_zero(), field.get_one().negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "NaN + NaNi".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "NaN + NaNi"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_nan(const Field<T> field) \r\n\r\n    {\r\n\r\n\r\n\r\n        return Field_std::complex<double><>(field.get_zero().add(NAN), field.get_zero().add(NAN));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "+INF + INFi".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "+INF + INFi"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_inf(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_zero().add(INFINITY), field.get_zero().add(INFINITY));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "1.0 + 0.0i".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "1.0 + 0.0i"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_one(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_one(), field.get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "-1.0 + 0.0i".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "-1.0 + 0.0i"\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_minus_one(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_one().negate(), field.get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "0.0 + 0.0i".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "0.0 + 0.0i\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_zero(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_zero(), field.get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a complex number representing "\xcf\x80 + 0.0i".\r\n\r\n     * @param field field the complex components belong to\r\n\r\n     * @return complex number representing "\xcf\x80 + 0.0i\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T> get_pi(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_std::complex<double><>(field.get_zero().get_pi(), field.get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Return the absolute value of this complex number.\r\n\r\n     * Returns {@code NaN} if either real or imaginary part is {@code NaN}\r\n\r\n     * and {@code INFINITY} if neither part is {@code NaN}, * but at least one part is infinite.\r\n\r\n     *\r\n\r\n     * @return the absolute value.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> abs() \r\n\r\n    {\r\n\r\n        // we check NaN here because std::hypot checks it after infinity\r\n\r\n        return is_nan ? get_nan(get_parts_field()) : create_complex(std::hypot(my_real, my_imaginary), get_parts_field().get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    T get_real() const\r\n\r\n    {\r\n\r\n        return my_real;\r\n\r\n    }\r\n\r\n\r\n\r\n    T get_imaginary() const\r\n\r\n    {\r\n\r\n        return my_imaginary;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is\r\n\r\n     * {@code (this + addend)}.\r\n\r\n     * Uses the definitional formula\r\n\r\n     * <p>\r\n\r\n     *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\r\n\r\n     * </p>\r\n\r\n     * If either {@code this} or {@code addend} has a {@code NaN} value in\r\n\r\n     * either part, {@link #get_nan(Field)} is returned; otherwise {@code Infinite}\r\n\r\n     * and {@code NaN} values are returned in the parts of the result\r\n\r\n     * according to the rules for {@link java.lang.Double} arithmetic.\r\n\r\n     *\r\n\r\n     * @param  addend Value to be added to this {@code std::complex<double>}.\r\n\r\n     * @return {@code this + addend}.\r\n\r\n     * @Null_Argument_Exception if {@code addend} is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> add(Field_Complex<T> addend) Null_Argument_Exception \r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(addend);\r\n\r\n        if (is_nan || addend.is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(my_real.add(addend.get_real_part()), my_imaginary.add(addend.get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code (this + addend)}, * with {@code addend} interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param addend Value to be added to this {@code std::complex<double>}.\r\n\r\n     * @return {@code this + addend}.\r\n\r\n     * @see #add(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    Field_Complex<T> add(T addend) \r\n\r\n    {\r\n\r\n        if (is_nan || addend.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(my_real.add(addend), my_imaginary);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code (this + addend)}, * with {@code addend} interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param addend Value to be added to this {@code std::complex<double>}.\r\n\r\n     * @return {@code this + addend}.\r\n\r\n     * @see #add(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> add(const double& addend) \r\n\r\n    {\r\n\r\n        if (is_nan || std::isnan(addend)) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(my_real.add(addend), my_imaginary);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the conjugate of this complex number.\r\n\r\n     * The conjugate of {@code a + bi} is {@code a - bi}.\r\n\r\n     * <p>\r\n\r\n     * {@link #get_nan(Field)} is returned if either the real or imaginary\r\n\r\n     * part of this std::complex<double> number equals {@codeNAN}.\r\n\r\n     * </p><p>\r\n\r\n     * If the imaginary part is infinite, and the real part is not\r\n\r\n     * {@code NaN}, the returned value has infinite imaginary part\r\n\r\n     * of the opposite sign, e.g. the conjugate of\r\n\r\n     * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\r\n\r\n     * </p>\r\n\r\n     * @return the conjugate of this std::complex<double> object.\r\n\r\n     */\r\n\r\n    Field_Complex<T> conjugate() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(real, my_imaginary.negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is\r\n\r\n     * {@code (this / divisor)}.\r\n\r\n     * Implements the definitional formula\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *    a + bi          ac + bd + (bc - ad)i\r\n\r\n     *    ----------- = -------------------------\r\n\r\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * but uses\r\n\r\n     * <a href="http://doi.acm.org/10.1145/1039813.1039814">\r\n\r\n     * prescaling of operands</a> to limit the effects of overflows and\r\n\r\n     * underflows in the computation.\r\n\r\n     * <p>\r\n\r\n     * {@code Infinite} and {@code NaN} values are handled according to the\r\n\r\n     * following rules, applied in the order presented:\r\n\r\n     * <ul>\r\n\r\n     *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\r\n\r\n     *   in either part, {@link #get_nan(Field)} is returned.\r\n\r\n     *  </li>\r\n\r\n     *  <li>If {@code divisor} equals {@link #get_zero(Field)}, {@link #get_nan(Field)} is returned.\r\n\r\n     *  </li>\r\n\r\n     *  <li>If {@code this} and {@code divisor} are both infinite, *   {@link #get_nan(Field)} is returned.\r\n\r\n     *  </li>\r\n\r\n     *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\r\n\r\n     *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\r\n\r\n     *   infinite), {@link #get_zero(Field)} is returned.\r\n\r\n     *  </li>\r\n\r\n     *  <li>If {@code this} is infinite and {@code divisor} is finite, *   {@code NaN} values are returned in the parts of the result if the\r\n\r\n     *   {@link java.lang.Double} rules applied to the definitional formula\r\n\r\n     *   force {@code NaN} results.\r\n\r\n     *  </li>\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param divisor Value by which this {@code std::complex<double>} is to be divided.\r\n\r\n     * @return {@code this / divisor}.\r\n\r\n     * @Null_Argument_Exception if {@code divisor} is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> divide(const Field_Complex<T>& divisor)\r\n\r\n    {\r\n\r\n        //Math_Utils::check_not_null(divisor);\r\n\r\n        if (is_nan || divisor.is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const T c = divisor.get_real_part();\r\n\r\n        const T d = divisor.get_imaginary_part();\r\n\r\n        if (c.is_zero() && d.is_zero()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (divisor.is_infinite() && !is_infinite()) \r\n\r\n        {\r\n\r\n            return get_zero(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (std::abs(c).get_real() < std::abs(d).get_real()) \r\n\r\n        {\r\n\r\n            T q = c.divide(d);\r\n\r\n            T inv_den = c.multiply(q).add(d).reciprocal();\r\n\r\n            return create_complex(my_real.multiply(q).add(my_imaginary).multiply(inv_den), my_imaginary.multiply(q).subtract(my_real).multiply(inv_den));\r\n\r\n        }\r\n\r\n\r\n\r\n        T q = d.divide(c);\r\n\r\n        T inv_den = d.multiply(q).add(c).reciprocal();\r\n\r\n        return create_complex(my_imaginary.multiply(q).add(my_real).multiply(inv_den), my_imaginary.subtract(my_real.multiply(q)).multiply(inv_den));\r\n\r\n        \r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code (this / divisor)}, * with {@code divisor} interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param  divisor Value by which this {@code std::complex<double>} is to be divided.\r\n\r\n     * @return {@code this / divisor}.\r\n\r\n     * @see #divide(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    Field_Complex<T> divide(const T& divisor) \r\n\r\n    {\r\n\r\n        if (is_nan || divisor.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (divisor.is_zero()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (divisor.get_is_infinite()) \r\n\r\n        {\r\n\r\n            return !std::isinfinite()\r\n\r\n                ? get_zero(get_parts_field())\r\n\r\n                : get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(my_real.divide(divisor), my_imaginary.divide(divisor));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code (this / divisor)}, * with {@code divisor} interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param  divisor Value by which this {@code std::complex<double>} is to be divided.\r\n\r\n     * @return {@code this / divisor}.\r\n\r\n     * @see #divide(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> divide(const double& divisor) \r\n\r\n    {\r\n\r\n        if (my_is_nan || std::isnan(divisor)) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (divisor == 0.0) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (Double.std::isinfinite(divisor)) \r\n\r\n        {\r\n\r\n            return !std::isinfinite()\r\n\r\n                ? get_zero(get_parts_field())\r\n\r\n                : get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(my_real.divide(divisor), my_imaginary.divide(divisor));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> reciprocal() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (real.is_zero() && imaginary.is_zero()) \r\n\r\n        {\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (std::isinfinite) \r\n\r\n        {\r\n\r\n            return get_zero(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (std::abs(real).get_real() < std::abs(imaginary).get_real()) \r\n\r\n        {\r\n\r\n            T q = real.divide(imaginary);\r\n\r\n            T scale = real.multiply(q).add(imaginary).reciprocal();\r\n\r\n            return create_complex(scale.multiply(q), scale.negate());\r\n\r\n        }\r\n\r\n            T q = imaginary.divide(real);\r\n\r\n            T scale = imaginary.multiply(q).add(real).reciprocal();\r\n\r\n            return create_complex(scale, scale.negate().multiply(q));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Test for equality with another object.\r\n\r\n     * If both the real and imaginary parts of two complex numbers\r\n\r\n     * are exactly the same, and neither is {@codeNAN}, the two\r\n\r\n     * std::complex<double> objects are considered to be equal.\r\n\r\n     * The behavior is the same as for JDK's {@link Double#equals(Object)\r\n\r\n     * Double}:\r\n\r\n     * <ul>\r\n\r\n     *  <li>All {@code NaN} values are considered to be equal, *   i.e, if either (or both) real and imaginary parts of the complex\r\n\r\n     *   number are equal to {@codeNAN}, the complex number is equal\r\n\r\n     *   to {@code NaN}.\r\n\r\n     *  </li>\r\n\r\n     *  <li>\r\n\r\n     *   Instances constructed with different representations of zero (i.e.\r\n\r\n     *   either "0" or "-0") are <em>not</em> considered to be equal.\r\n\r\n     *  </li>\r\n\r\n     * </ul>\r\n\r\n     *\r\n\r\n     * @param other Object to test for equality with this instance.\r\n\r\n     * @return {@code true} if the objects are equal, {@code false} if object\r\n\r\n     * is {@code null}, not an instance of {@code std::complex<double>}, or not equal to\r\n\r\n     * this instance.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool equals(Object other) \r\n\r\n    {\r\n\r\n        if (this == other) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        if (other instanceof Field_std::complex<double>)\r\n\r\n        {\r\n\r\n            //@Suppress_Warnings("unchecked")\r\n\r\n            Field_Complex<T> c = (Field_Complex<T>) other;\r\n\r\n            if (c.is_nan) \r\n\r\n            {\r\n\r\n                return my_is_nan;\r\n\r\n            }\r\n\r\n            else \r\n\r\n            {\r\n\r\n                return my_real.equals(c.get_real) && imaginary.equals(c.imaginary);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Test for the floating-point equality between std::complex<double> objects.\r\n\r\n     * It returns {@code true} if both arguments are equal or within the\r\n\r\n     * range of allowed error (inclusive).\r\n\r\n     *\r\n\r\n     * @param x First value (cannot be {@code null}).\r\n\r\n     * @param y Second value (cannot be {@code null}).\r\n\r\n     * @param max_ulps {@code (max_ulps - 1)} is the number of floating point\r\n\r\n     * values between the real (resp. imaginary) parts of {@code x} and\r\n\r\n     * {@code y}.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return {@code true} if there are fewer than {@code max_ulps} floating\r\n\r\n     * point values between the real (resp. imaginary) parts of {@code x}\r\n\r\n     * and {@code y}.\r\n\r\n     *\r\n\r\n     * @see Precision#equals(double,double,int)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static bool equals(Field_Complex<T> x, Field_Complex<T> y, int max_ulps) \r\n\r\n    {\r\n\r\n        return Precision.equals(x.real.get_real(), y.real.get_real(), max_ulps) &&\r\n\r\n               Precision.equals(x.imaginary.get_real(), y.imaginary.get_real(), max_ulps);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} iff the values are equal as defined by\r\n\r\n     * {@link #equals(Field_std::complex<double>,Field_std::complex<double>,int) equals(x, y, 1)}.\r\n\r\n     *\r\n\r\n     * @param x First value (cannot be {@code null}).\r\n\r\n     * @param y Second value (cannot be {@code null}).\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return {@code true} if the values are equal.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static bool equals(Field_Complex<T> x, Field_Complex<T> y) \r\n\r\n    {\r\n\r\n        return equals(x, y, 1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if, both for the real part and for the imaginary\r\n\r\n     * part, there is no T value strictly between the arguments or the\r\n\r\n     * difference between them is within the range of allowed error\r\n\r\n     * (inclusive).  Returns {@code false} if either of the arguments is NaN.\r\n\r\n     *\r\n\r\n     * @param x First value (cannot be {@code null}).\r\n\r\n     * @param y Second value (cannot be {@code null}).\r\n\r\n     * @param eps Amount of allowed absolute error.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return {@code true} if the values are two adjacent floating point\r\n\r\n     * numbers or they are within range of each other.\r\n\r\n     *\r\n\r\n     * @see Precision#equals(double,double,double)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static bool equals(Field_Complex<T> x, Field_Complex<T> y, double eps) \r\n\r\n    {\r\n\r\n        return Precision.equals(x.real.get_real(), y.real.get_real(), eps) &&\r\n\r\n               Precision.equals(x.imaginary.get_real(), y.imaginary.get_real(), eps);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns {@code true} if, both for the real part and for the imaginary\r\n\r\n     * part, there is no T value strictly between the arguments or the\r\n\r\n     * relative difference between them is smaller or equal to the given\r\n\r\n     * tolerance. Returns {@code false} if either of the arguments is NaN.\r\n\r\n     *\r\n\r\n     * @param x First value (cannot be {@code null}).\r\n\r\n     * @param y Second value (cannot be {@code null}).\r\n\r\n     * @param eps Amount of allowed relative error.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return {@code true} if the values are two adjacent floating point\r\n\r\n     * numbers or they are within range of each other.\r\n\r\n     *\r\n\r\n     * @see Precision#equals_with_relative_tolerance(double,double,double)\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static bool equals_with_relative_tolerance(Field_Complex<T> x, Field_Complex<T> y, double eps) \r\n\r\n    {\r\n\r\n        return Precision.equals_with_relative_tolerance(x.real.get_real(), y.real.get_real(), eps) &&\r\n\r\n               Precision.equals_with_relative_tolerance(x.imaginary.get_real(), y.imaginary.get_real(), eps);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a hash_code for the complex number.\r\n\r\n     * Any {@codeNAN} value in real or imaginary part produces\r\n\r\n     * the same hash code {@code 7}.\r\n\r\n     *\r\n\r\n     * @return a hash code value for this object.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    int hash_code() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return 7;\r\n\r\n        }\r\n\r\n        return 37 * (17 * imaginary.hash_code() + real.hash_code());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * This implementation considers +0.0 and -0.0 to be equal for both\r\n\r\n     * real and imaginary components.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool is_zero() \r\n\r\n    {\r\n\r\n        return real.is_zero() && imaginary.is_zero();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Access the imaginary part.\r\n\r\n     *\r\n\r\n     * @return the imaginary part.\r\n\r\n     */\r\n\r\n    T get_imaginary() \r\n\r\n    {\r\n\r\n        return my_imaginary;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Access the imaginary part.\r\n\r\n     *\r\n\r\n     * @return the imaginary part.\r\n\r\n     */\r\n\r\n    T get_imaginary_part() \r\n\r\n    {\r\n\r\n        return my_imaginary;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Access the real part.\r\n\r\n     *\r\n\r\n     * @return the real part.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    double get_real() \r\n\r\n    {\r\n\r\n        return real.get_real();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Access the real part.\r\n\r\n     *\r\n\r\n     * @return the real part.\r\n\r\n     */\r\n\r\n    T get_real_part() \r\n\r\n    {\r\n\r\n        return real;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether either or both parts of this complex number is\r\n\r\n     * {@code NaN}.\r\n\r\n     *\r\n\r\n     * @return true if either or both parts of this complex number is\r\n\r\n     * {@code NaN}; false otherwise.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool is_nan() \r\n\r\n    {\r\n\r\n        return is_nan;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check whether the instance is real (i.e. imaginary part is zero).\r\n\r\n     * @return true if imaginary part is zero\r\n\r\n      */\r\n\r\n    bool is_real() \r\n\r\n    {\r\n\r\n        return imaginary.is_zero();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check whether the instance is an integer (i.e. imaginary part is zero and real part has no fractional part).\r\n\r\n     * @return true if imaginary part is zero and real part has no fractional part\r\n\r\n     */\r\n\r\n    bool is_mathematical_integer() \r\n\r\n    {\r\n\r\n        return is_real() && Precision.is_mathematical_integer(real.get_real());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether either the real or imaginary part of this complex number\r\n\r\n     * takes an infinite value (either {@code INFINITY} or\r\n\r\n     * {@code -INFINITY}) and neither part\r\n\r\n     * is {@code NaN}.\r\n\r\n     *\r\n\r\n     * @return true if one or both parts of this complex number are infinite\r\n\r\n     * and neither part is {@code NaN}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool is_infinite() \r\n\r\n    {\r\n\r\n        return std::isinfinite;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code this * factor}.\r\n\r\n     * Implements preliminary checks for {@code NaN} and infinity followed by\r\n\r\n     * the definitional formula:\r\n\r\n     * <p>\r\n\r\n     *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\r\n\r\n     * </p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either {@code this} or {@code factor} has one or\r\n\r\n     * more {@code NaN} parts.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_inf(Field)} if neither {@code this} nor {@code factor} has one\r\n\r\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\r\n\r\n     * has one or more infinite parts (same result is returned regardless of\r\n\r\n     * the sign of the components).\r\n\r\n     * </p><p>\r\n\r\n     * Returns finite values in components of the result per the definitional\r\n\r\n     * formula in all remaining cases.</p>\r\n\r\n     *\r\n\r\n     * @param  factor value to be multiplied by this {@code std::complex<double>}.\r\n\r\n     * @return {@code this * factor}.\r\n\r\n     * @Null_Argument_Exception if {@code factor} is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> multiply(Field_Complex<T> factor)\r\n\r\n        Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(factor);\r\n\r\n        if (is_nan || factor.is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.std::isinfinite() ||\r\n\r\n            imaginary.std::isinfinite() ||\r\n\r\n            factor.real.std::isinfinite() ||\r\n\r\n            factor.imaginary.std::isinfinite()) \r\n\r\n            {\r\n\r\n            // we don't use std::isinfinite() to avoid testing for NaN again\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.linear_combination(real, factor.real, imaginary.negate(), factor.imaginary), real.linear_combination(real, factor.imaginary, imaginary, factor.real));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code this * factor}, with {@code factor}\r\n\r\n     * interpreted as a integer number.\r\n\r\n     *\r\n\r\n     * @param  factor value to be multiplied by this {@code std::complex<double>}.\r\n\r\n     * @return {@code this * factor}.\r\n\r\n     * @see #multiply(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> multiply(const int factor) \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.std::isinfinite() || imaginary.std::isinfinite()) \r\n\r\n        {\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.multiply(factor), imaginary.multiply(factor));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code this * factor}, with {@code factor}\r\n\r\n     * interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param  factor value to be multiplied by this {@code std::complex<double>}.\r\n\r\n     * @return {@code this * factor}.\r\n\r\n     * @see #multiply(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> multiply(double factor) \r\n\r\n    {\r\n\r\n        if (is_nan || std::isnan(factor)) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.std::isinfinite() ||\r\n\r\n            imaginary.std::isinfinite() ||\r\n\r\n            Double.std::isinfinite(factor)) \r\n\r\n            {\r\n\r\n            // we don't use std::isinfinite() to avoid testing for NaN again\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.multiply(factor), imaginary.multiply(factor));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code this * factor}, with {@code factor}\r\n\r\n     * interpreted as a real number.\r\n\r\n     *\r\n\r\n     * @param  factor value to be multiplied by this {@code std::complex<double>}.\r\n\r\n     * @return {@code this * factor}.\r\n\r\n     * @see #multiply(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    Field_Complex<T> multiply(T factor) \r\n\r\n    {\r\n\r\n        if (is_nan || factor.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.std::isinfinite() ||\r\n\r\n            imaginary.std::isinfinite() ||\r\n\r\n            factor.std::isinfinite()) \r\n\r\n            {\r\n\r\n            // we don't use std::isinfinite() to avoid testing for NaN again\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.multiply(factor), imaginary.multiply(factor));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute this * i.\r\n\r\n     * @return this * i\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    Field_Complex<T> multiply_plus_i() \r\n\r\n    {\r\n\r\n        return create_complex(imaginary.negate(), real);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute this *- -i.\r\n\r\n     * @return this * i\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    Field_Complex<T> multiply_minus_i() \r\n\r\n    {\r\n\r\n        return create_complex(imaginary, real.negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is {@code (-this)}.\r\n\r\n     * Returns {@code NaN} if either real or imaginary\r\n\r\n     * part of this std::complex<double> number is {@codeNAN}.\r\n\r\n     *\r\n\r\n     * @return {@code -this}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> negate() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(real.negate(), imaginary.negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is\r\n\r\n     * {@code (this - subtrahend)}.\r\n\r\n     * Uses the definitional formula\r\n\r\n     * <p>\r\n\r\n     *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\r\n\r\n     * </p>\r\n\r\n     * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part, * {@link #get_nan(Field)} is returned; otherwise infinite and {@code NaN} values are\r\n\r\n     * returned in the parts of the result according to the rules for\r\n\r\n     * {@link java.lang.Double} arithmetic.\r\n\r\n     *\r\n\r\n     * @param  subtrahend value to be subtracted from this {@code std::complex<double>}.\r\n\r\n     * @return {@code this - subtrahend}.\r\n\r\n     * @Null_Argument_Exception if {@code subtrahend} is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> subtract(Field_Complex<T> subtrahend)\r\n\r\n        Null_Argument_Exception \r\n\r\n        {\r\n\r\n        //Math_Utils::check_not_null(subtrahend);\r\n\r\n        if (is_nan || subtrahend.is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(real.subtract(subtrahend.get_real_part()), imaginary.subtract(subtrahend.get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is\r\n\r\n     * {@code (this - subtrahend)}.\r\n\r\n     *\r\n\r\n     * @param  subtrahend value to be subtracted from this {@code std::complex<double>}.\r\n\r\n     * @return {@code this - subtrahend}.\r\n\r\n     * @see #subtract(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> subtract(double subtrahend) \r\n\r\n    {\r\n\r\n        if (is_nan || std::isnan(subtrahend)) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.subtract(subtrahend), imaginary);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns a {@code std::complex<double>} whose value is\r\n\r\n     * {@code (this - subtrahend)}.\r\n\r\n     *\r\n\r\n     * @param  subtrahend value to be subtracted from this {@code std::complex<double>}.\r\n\r\n     * @return {@code this - subtrahend}.\r\n\r\n     * @see #subtract(Field_std::complex<double>)\r\n\r\n     */\r\n\r\n    Field_Complex<T> subtract(T subtrahend) \r\n\r\n    {\r\n\r\n        if (is_nan || subtrahend.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        return create_complex(real.subtract(subtrahend), imaginary);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/InverseCosine.html" TARGET="_top">\r\n\r\n     * inverse cosine</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <p>\r\n\r\n     *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\r\n\r\n     * </p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN} or infinite.\r\n\r\n     *\r\n\r\n     * @return the inverse cosine of this complex number.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> acos() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return this.add(this.sqrt1z().multiply_plus_i()).log().multiply_minus_i();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/InverseSine.html" TARGET="_top">\r\n\r\n     * inverse sine</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <p>\r\n\r\n     *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\r\n\r\n     * </p><p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN} or infinite.</p>\r\n\r\n     *\r\n\r\n     * @return the inverse sine of this complex number.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> asin() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return sqrt1z().add(this.multiply_plus_i()).log().multiply_minus_i();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/InverseTangent.html" TARGET="_top">\r\n\r\n     * inverse tangent</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <p>\r\n\r\n     * {@code atan(z) = (i/2) log((1 - iz)/(1 + iz))}\r\n\r\n     * </p><p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN} or infinite.</p>\r\n\r\n     *\r\n\r\n     * @return the inverse tangent of this complex number\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> atan() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const T one = get_parts_field().get_one();\r\n\r\n        if (real.is_zero()) \r\n\r\n        {\r\n\r\n\r\n\r\n            // singularity at \xc2\xb1i\r\n\r\n            if (imaginary.multiply(imaginary).subtract(one).is_zero()) \r\n\r\n            {\r\n\r\n                return get_nan(get_parts_field());\r\n\r\n            }\r\n\r\n\r\n\r\n            // branch cut on imaginary axis\r\n\r\n            const T zero = get_parts_field().get_zero();\r\n\r\n            const Field_Complex<T> tmp = create_complex(one.add(imaginary).divide(one.subtract(imaginary)), zero).\r\n\r\n                                        log().multiply_plus_i().multiply(0.5);\r\n\r\n            return create_complex(std::copysign(tmp.real, real), tmp.imaginary);\r\n\r\n\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // regular formula\r\n\r\n            const Field_Complex<T> n = create_complex(one.add(imaginary), real.negate());\r\n\r\n            const Field_Complex<T> d = create_complex(one.subtract(imaginary),  real);\r\n\r\n            return n.divide(d).log().multiply_plus_i().multiply(0.5);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/Cosine.html" TARGET="_top">\r\n\r\n     * cosine</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <p>\r\n\r\n     *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\r\n\r\n     * </p><p>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n\r\n     * </p><p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p><p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.</p>\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   cos(1 &plusmn; INFINITY i) = 1 \u2213 INFINITY i\r\n\r\n     *   cos(&plusmn;INFINITY + i) = NaN + NaN i\r\n\r\n     *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the cosine of this complex number.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> cos() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sin_Cos<T>   scr  = Sin_Cos(real);\r\n\r\n        const Field_Sinh_Cosh<T> schi = std::sinh_cosh(imaginary);\r\n\r\n        return create_complex(scr.cos().multiply(schi.cosh()), scr.sin().negate().multiply(schi.sinh()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/HyperbolicCosine.html" TARGET="_top">\r\n\r\n     * hyperbolic cosine</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\r\n\r\n     *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the hyperbolic cosine of this complex number.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> cosh() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sinh_Cosh<T> schr = std::sinh_cosh(real);\r\n\r\n        const Field_Sin_Cos<T>   sci  = Sin_Cos(imaginary);\r\n\r\n        return create_complex(schr.cosh().multiply(sci.cos()), schr.sinh().multiply(sci.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/ExponentialFunction.html" TARGET="_top">\r\n\r\n     * exponential function</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#exp}, {@link FastMath#cos}, and\r\n\r\n     * {@link FastMath#sin}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   exp(INFINITY + i) = INFINITY + INFINITY i\r\n\r\n     *   exp(-INFINITY + i) = 0 + 0i\r\n\r\n     *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return <code><i>e</i><sup>this</sup></code>.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> exp() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const T              exp_real = std::exp(real);\r\n\r\n        const Field_Sin_Cos<T> sc      = Sin_Cos(imaginary);\r\n\r\n        return create_complex(exp_real.multiply(sc.cos()), exp_real.multiply(sc.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> expm1() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const T              expm1_real = std::expm1(real);\r\n\r\n        const Field_Sin_Cos<T> sc        = Sin_Cos(imaginary);\r\n\r\n        return create_complex(expm1_real.multiply(sc.cos()), expm1_real.multiply(sc.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/NaturalLogarithm.html" TARGET="_top">\r\n\r\n     * natural logarithm</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where ln on the right hand side is {@link FastMath#log}, * {@code |a + bi|} is the modulus, {@link #abs},  and\r\n\r\n     * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite (or critical) values in real or imaginary parts of the input may\r\n\r\n     * result in infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\r\n\r\n     *   log(INFINITY + i) = INFINITY + 0i\r\n\r\n     *   log(-INFINITY + i) = INFINITY + &pi;i\r\n\r\n     *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\r\n\r\n     *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\r\n\r\n     *   log(0 + 0i) = -INFINITY + 0i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the value <code>ln &nbsp; this</code>, the natural logarithm\r\n\r\n     * of {@code this}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> log() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        return create_complex(std::log(std::hypot(real, imaginary)), std::atan2(imaginary, real));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> log1p() \r\n\r\n    {\r\n\r\n        return add(1.0).log();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> log10() \r\n\r\n    {\r\n\r\n        return log().divide(LOG10);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns of value of this complex number raised to the power of {@code x}.\r\n\r\n     * <p>\r\n\r\n     * If {@code x} is a real number whose real part has an integer value, returns {@link #powstatic_cast<int>(}, * if both {@code this} and {@code x} are real and {@link FastMath#pow(double, double)}\r\n\r\n     * with the corresponding real arguments would return a finite number (neither NaN\r\n\r\n     * nor infinite), then returns the same value converted to {@code std::complex<double>}, * with the same special cases.\r\n\r\n     * In all other cases real cases, : y<sup>x</sup> = exp(x&middot;log(y)).\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param  x exponent to which this {@code std::complex<double>} is to be raised.\r\n\r\n     * @return <code> this<sup>x</sup></code>.\r\n\r\n     * @Null_Argument_Exception if x is {@code null}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> pow(Field_Complex<T> x)\r\n\r\n        Null_Argument_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        //Math_Utils::check_not_null(x);\r\n\r\n\r\n\r\n        if (x.imaginary.is_zero()) \r\n\r\n        {\r\n\r\n            const int& nx = static_cast<int>( FastMath.rint(x.real.get_real());\r\n\r\n            if (x.real.get_real() == nx) \r\n\r\n            {\r\n\r\n                // integer power\r\n\r\n                return pow(nx);\r\n\r\n            }\r\n\r\nelse if (this.imaginary.is_zero()) \r\n\r\n            {\r\n\r\n                // check real implementation that handles a bunch of special cases\r\n\r\n                const T real_pow = std::pow(this.real, x.real);\r\n\r\n                if (real_pow.is_finite()) \r\n\r\n                {\r\n\r\n                    return create_complex(real_pow, get_parts_field().get_zero());\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // generic implementation\r\n\r\n        return this.log().multiply(x).exp();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns of value of this complex number raised to the power of {@code x}.\r\n\r\n     * <p>\r\n\r\n     * If {@code x} has an integer value, returns {@link #powstatic_cast<int>(}, * if {@code this} is real and {@link FastMath#pow(double, double)}\r\n\r\n     * with the corresponding real arguments would return a finite number (neither NaN\r\n\r\n     * nor infinite), then returns the same value converted to {@code std::complex<double>}, * with the same special cases.\r\n\r\n     * In all other cases real cases, : y<sup>x</sup> = exp(x&middot;log(y)).\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param  x exponent to which this {@code std::complex<double>} is to be raised.\r\n\r\n     * @return <code> this<sup>x</sup></code>.\r\n\r\n     */\r\n\r\n    Field_Complex<T> pow(T x) \r\n\r\n    {\r\n\r\n\r\n\r\n        const int& nx = static_cast<int>( FastMath.rint(x.get_real());\r\n\r\n        if (x.get_real() == nx) \r\n\r\n        {\r\n\r\n            // integer power\r\n\r\n            return pow(nx);\r\n\r\n        }\r\n\r\nelse if (this.imaginary.is_zero()) \r\n\r\n        {\r\n\r\n            // check real implementation that handles a bunch of special cases\r\n\r\n            const T real_pow = std::pow(this.real, x);\r\n\r\n            if (real_pow.is_finite()) \r\n\r\n            {\r\n\r\n                return create_complex(real_pow, get_parts_field().get_zero());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // generic implementation\r\n\r\n        return this.log().multiply(x).exp();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns of value of this complex number raised to the power of {@code x}.\r\n\r\n     * <p>\r\n\r\n     * If {@code x} has an integer value, returns {@link #powstatic_cast<int>(}, * if {@code this} is real and {@link FastMath#pow(double, double)}\r\n\r\n     * with the corresponding real arguments would return a finite number (neither NaN\r\n\r\n     * nor infinite), then returns the same value converted to {@code std::complex<double>}, * with the same special cases.\r\n\r\n     * In all other cases real cases, : y<sup>x</sup> = exp(x&middot;log(y)).\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param  x exponent to which this {@code std::complex<double>} is to be raised.\r\n\r\n     * @return <code> this<sup>x</sup></code>.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> pow(double x) \r\n\r\n    {\r\n\r\n\r\n\r\n        const int& nx = static_cast<int>( FastMath.rint(x);\r\n\r\n        if (x == nx) \r\n\r\n        {\r\n\r\n            // integer power\r\n\r\n            return pow(nx);\r\n\r\n        }\r\n\r\nelse if (this.imaginary.is_zero()) \r\n\r\n        {\r\n\r\n            // check real implementation that handles a bunch of special cases\r\n\r\n            const T real_pow = std::pow(this.real, x);\r\n\r\n            if (real_pow.is_finite()) \r\n\r\n            {\r\n\r\n                return create_complex(real_pow, get_parts_field().get_zero());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // generic implementation\r\n\r\n        return this.log().multiply(x).exp();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n     /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> pow(const int& n) \r\n\r\n    {\r\n\r\n\r\n\r\n        Field_Complex<T> result = get_field().get_one();\r\n\r\n        const bool invert;\r\n\r\n        int p = n;\r\n\r\n        if (p < 0) \r\n\r\n        {\r\n\r\n            invert = true;\r\n\r\n            p = -p;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            invert = false;\r\n\r\n        }\r\n\r\n\r\n\r\n        // Exponentiate by successive squaring\r\n\r\n        Field_Complex<T> square = this;\r\n\r\n        while (p > 0) \r\n\r\n        {\r\n\r\n            if ((p & 0x1) > 0) \r\n\r\n            {\r\n\r\n                result = result.multiply(square);\r\n\r\n            }\r\n\r\n            square = square.multiply(square);\r\n\r\n            p = p >> 1;\r\n\r\n        }\r\n\r\n\r\n\r\n        return invert ? result.reciprocal() : result;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n     /**\r\n\r\n      * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/Sine.html" TARGET="_top">\r\n\r\n     * sine</a>\r\n\r\n     * of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   sin(a + bi) = sin(a)cosh(b) + cos(a)sinh(b)i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p><p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or {@code NaN} values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\r\n\r\n     *   sin(&plusmn;INFINITY + i) = NaN + NaN i\r\n\r\n     *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the sine of this complex number.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> sin() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sin_Cos<T>   scr  = Sin_Cos(real);\r\n\r\n        const Field_Sinh_Cosh<T> schi = std::sinh_cosh(imaginary);\r\n\r\n        return create_complex(scr.sin().multiply(schi.cosh()), scr.cos().multiply(schi.sinh()));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Sin_Cos<Field_Complex<T>> sin_cos() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return Field_Sin_Cos<>(get_nan(get_parts_field()), get_nan(get_parts_field()));\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sin_Cos<T>   scr = Sin_Cos(real);\r\n\r\n        const Field_Sinh_Cosh<T> schi = std::sinh_cosh(imaginary);\r\n\r\n        return Field_Sin_Cos<>(create_complex(scr.sin().multiply(schi.cosh()), scr.cos().multiply(schi.sinh())), create_complex(scr.cos().multiply(schi.cosh()), scr.sin().negate().multiply(schi.sinh())));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> atan2(Field_Complex<T> x) \r\n\r\n    {\r\n\r\n\r\n\r\n        // compute r = sqrt(x^2+y^2)\r\n\r\n        const Field_Complex<T> r = x.multiply(x).add(multiply(this)).sqrt();\r\n\r\n\r\n\r\n        if (x.real.get_real() >= 0) \r\n\r\n        {\r\n\r\n            // compute atan2(y, x) = 2 atan(y / (r + x))\r\n\r\n            return divide(r.add(x)).atan().multiply(2);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\r\n\r\n            return divide(r.subtract(x)).atan().multiply(-2).add(x.real.get_pi());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * Branch cuts are on the real axis, below +1.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> acosh() \r\n\r\n    {\r\n\r\n        const Field_Complex<T> sqrt_plus  = add(1).sqrt();\r\n\r\n        const Field_Complex<T> sqrt_minus = subtract(1).sqrt();\r\n\r\n        return add(sqrt_plus.multiply(sqrt_minus)).log();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * Branch cuts are on the imaginary axis, above +i and below -i.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> asinh() \r\n\r\n    {\r\n\r\n        return add(multiply(this).add(1.0).sqrt()).log();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * Branch cuts are on the real axis, above +1 and below -1.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> atanh() \r\n\r\n    {\r\n\r\n        const Field_Complex<T> log_plus  = add(1).log();\r\n\r\n        const Field_Complex<T> log_minus = create_complex(get_parts_field().get_one().subtract(real), imaginary.negate()).log();\r\n\r\n        return log_plus.subtract(log_minus).multiply(0.5);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/HyperbolicSine.html" TARGET="_top">\r\n\r\n     * hyperbolic sine</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, * {@link FastMath#cosh} and {@link FastMath#sinh}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p><p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\r\n\r\n     *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the hyperbolic sine of {@code this}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> sinh() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sinh_Cosh<T> schr = std::sinh_cosh(real);\r\n\r\n        const Field_Sin_Cos<T>   sci  = Sin_Cos(imaginary);\r\n\r\n        return create_complex(schr.sinh().multiply(sci.cos()), schr.cosh().multiply(sci.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Sinh_Cosh<Field_Complex<T>> sinh_cosh() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return Field_Sinh_Cosh<>(get_nan(get_parts_field()), get_nan(get_parts_field()));\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sinh_Cosh<T> schr = std::sinh_cosh(real);\r\n\r\n        const Field_Sin_Cos<T>   sci  = Sin_Cos(imaginary);\r\n\r\n        return Field_Sinh_Cosh<>(create_complex(schr.sinh().multiply(sci.cos()), schr.cosh().multiply(sci.sin())), create_complex(schr.cosh().multiply(sci.cos()), schr.sinh().multiply(sci.sin())));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">\r\n\r\n     * square root</a> of this complex number.\r\n\r\n     * Implements the following algorithm to compute {@code sqrt(a + bi)}:\r\n\r\n     * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\r\n\r\n     * <li><pre>if {@code  a \xe2\x89\xa5 0} return {@code t + (b/2t)i}\r\n\r\n     *  else return {@code |b|/2t + sign(b)t i }</pre></li>\r\n\r\n     * </ol>\r\n\r\n     * where <ul>\r\n\r\n     * <li>{@code |a| = }{@link FastMath#abs(Calculus_Field_Element) abs(a)}</li>\r\n\r\n     * <li>{@code |a + bi| = }{@link FastMath#hypot(Calculus_Field_Element, Calculus_Field_Element) hypot(a, b)}</li>\r\n\r\n     * <li>{@code sign(b) = }{@link FastMath#copy_sign(Calculus_Field_Element, Calculus_Field_Element) copy_sign(1, b)}\r\n\r\n     * </ul>\r\n\r\n     * The real part is therefore always nonnegative.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field) NaN} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     * </p>\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   sqrt(1 \xc2\xb1 \xe2\x88\x9e i) = \xe2\x88\x9e + NaN i\r\n\r\n     *   sqrt(\xe2\x88\x9e + i) = \xe2\x88\x9e + 0i\r\n\r\n     *   sqrt(-\xe2\x88\x9e + i) = 0 + \xe2\x88\x9e i\r\n\r\n     *   sqrt(\xe2\x88\x9e \xc2\xb1 \xe2\x88\x9e i) = \xe2\x88\x9e + NaN i\r\n\r\n     *   sqrt(-\xe2\x88\x9e \xc2\xb1 \xe2\x88\x9e i) = NaN \xc2\xb1 \xe2\x88\x9e i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the square root of {@code this} with nonnegative real part.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> sqrt() \r\n\r\n    {\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (is_zero()) \r\n\r\n        {\r\n\r\n            return get_zero(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        T t = std::sqrt((std::abs(real).add(std::hypot(real, imaginary))).multiply(0.5));\r\n\r\n        if (real.get_real() >= 0.0) \r\n\r\n        {\r\n\r\n            return create_complex(t, imaginary.divide(t.multiply(2)));\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return create_complex(std::abs(imaginary).divide(t.multiply(2)), std::copysign(t, imaginary));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/SquareRoot.html" TARGET="_top">\r\n\r\n     * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\r\n\r\n     * number.\r\n\r\n     * Computes the result directly as\r\n\r\n     * {@code sqrt(ONE.subtract(z.multiply(z)))}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     *\r\n\r\n     * @return the square root of <code>1 - this<sup>2</sup></code>.\r\n\r\n     */\r\n\r\n    Field_Complex<T> sqrt1z() \r\n\r\n    {\r\n\r\n        const Field_Complex<T> t2 = this.multiply(this);\r\n\r\n        return create_complex(get_parts_field().get_one().subtract(t2.real), t2.imaginary.negate()).sqrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * This implementation compute the principal cube root by using a branch cut along real negative axis.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> cbrt() \r\n\r\n    {\r\n\r\n        const T              magnitude = std::cbrt(abs().get_real_part());\r\n\r\n        const Field_Sin_Cos<T> sc        = Sin_Cos(get_argument().divide(3));\r\n\r\n        return create_complex(magnitude.multiply(sc.cos()), magnitude.multiply(sc.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * This implementation compute the principal n<sup>th</sup> root by using a branch cut along real negative axis.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> root_n(const int& n) \r\n\r\n    {\r\n\r\n        const T              magnitude = std::pow(abs().get_real_part(), 1.0 / n);\r\n\r\n        const Field_Sin_Cos<T> sc        = Sin_Cos(get_argument().divide(n));\r\n\r\n        return create_complex(magnitude.multiply(sc.cos()), magnitude.multiply(sc.sin()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/Tangent.html" TARGET="_top">\r\n\r\n     * tangent</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n\r\n     * {@link FastMath#sinh}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite (or critical) values in real or imaginary parts of the input may\r\n\r\n     * result in infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\r\n\r\n     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\r\n\r\n     *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the tangent of {@code this}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> tan() \r\n\r\n    {\r\n\r\n        if (is_nan || real.std::isinfinite()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (imaginary.get_real() > 20.0) \r\n\r\n        {\r\n\r\n            return get_i(get_parts_field());\r\n\r\n        }\r\n\r\n        if (imaginary.get_real() < -20.0) \r\n\r\n        {\r\n\r\n            return get_minus_i(get_parts_field());\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Sin_Cos<T> sc2r = Sin_Cos(real.multiply(2));\r\n\r\n        T imaginary2 = imaginary.multiply(2);\r\n\r\n        T d = sc2r.cos().add(std::cosh(imaginary2));\r\n\r\n\r\n\r\n        return create_complex(sc2r.sin().divide(d), std::sinh(imaginary2).divide(d));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the\r\n\r\n     * <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" TARGET="_top">\r\n\r\n     * hyperbolic tangent</a> of this complex number.\r\n\r\n     * Implements the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * where the (real) functions on the right-hand side are\r\n\r\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\r\n\r\n     * {@link FastMath#sinh}.\r\n\r\n     * <p>\r\n\r\n     * Returns {@link #get_nan(Field)} if either real or imaginary part of the\r\n\r\n     * input argument is {@code NaN}.\r\n\r\n     * </p>\r\n\r\n     * Infinite values in real or imaginary parts of the input may result in\r\n\r\n     * infinite or NaN values returned in parts of the result.\r\n\r\n     * <pre>\r\n\r\n     *  Examples:\r\n\r\n     *  <code>\r\n\r\n     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\r\n\r\n     *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\r\n\r\n     *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     *\r\n\r\n     * @return the hyperbolic tangent of {@code this}.\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> tanh() \r\n\r\n    {\r\n\r\n        if (is_nan || imaginary.std::isinfinite()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.get_real() > 20.0) \r\n\r\n        {\r\n\r\n            return get_one(get_parts_field());\r\n\r\n        }\r\n\r\n        if (real.get_real() < -20.0) \r\n\r\n        {\r\n\r\n            return get_minus_one(get_parts_field());\r\n\r\n        }\r\n\r\n        T real2 = real.multiply(2);\r\n\r\n        const Field_Sin_Cos<T> sc2i = Sin_Cos(imaginary.multiply(2));\r\n\r\n        T d = std::cosh(real2).add(sc2i.cos());\r\n\r\n\r\n\r\n        return create_complex(std::sinh(real2).divide(d), sc2i.sin().divide(d));\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Compute the argument of this complex number.\r\n\r\n     * The argument is the angle phi between the positive real axis and\r\n\r\n     * the point representing this number in the complex plane.\r\n\r\n     * The value returned is between -PI (not inclusive)\r\n\r\n     * and PI (inclusive), with negative values returned for numbers with\r\n\r\n     * negative imaginary parts.\r\n\r\n     * <p>\r\n\r\n     * If either real or imaginary part (or both) is NaN, NaN is returned.\r\n\r\n     * Infinite parts are handled as {@code Math.atan2} handles them, * essentially treating finite parts as zero in the presence of an\r\n\r\n     * infinite coordinate and returning a multiple of pi/4 depending on\r\n\r\n     * the signs of the infinite parts.\r\n\r\n     * See the javadoc for {@code Math.atan2} for full details.\r\n\r\n     *\r\n\r\n     * @return the argument of {@code this}.\r\n\r\n     */\r\n\r\n    T get_argument() \r\n\r\n    {\r\n\r\n        return std::atan2(get_imaginary_part(), get_real_part());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the n-th roots of this complex number.\r\n\r\n     * The nth roots are defined by the formula:\r\n\r\n     * <pre>\r\n\r\n     *  <code>\r\n\r\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\r\n\r\n     *  </code>\r\n\r\n     * </pre>\r\n\r\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\r\n\r\n     * are respectively the {@link #abs() modulus} and\r\n\r\n     * {@link #get_argument() argument} of this complex number.\r\n\r\n     * <p>\r\n\r\n     * If one or both parts of this complex number is NaN, a list with just\r\n\r\n     * one element, {@link #get_nan(Field)} is returned.\r\n\r\n     * if neither part is NaN, but at least one part is infinite, the result\r\n\r\n     * is a one-element list containing {@link #get_inf(Field)}.\r\n\r\n     *\r\n\r\n     * @param n Degree of root.\r\n\r\n     * @return a List of all {@code n}-th roots of {@code this}.\r\n\r\n     * @ if {@code n <= 0}.\r\n\r\n     */\r\n\r\n    List<Field_Complex<T>> nth_root(const int& n)  \r\n\r\n    {\r\n\r\n\r\n\r\n        if (n <= 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);\r\n\r\n        }\r\n\r\n\r\n\r\n        const List<Field_Complex<T>> result = Array_list<>();\r\n\r\n\r\n\r\n        if (is_nan) \r\n\r\n        {\r\n\r\n            result.add(get_nan(get_parts_field()));\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n        if (std::isinfinite()) \r\n\r\n        {\r\n\r\n            result.add(get_inf(get_parts_field()));\r\n\r\n            return result;\r\n\r\n        }\r\n\r\n\r\n\r\n        // nth root of abs -- faster / more accurate to use a solver here?\r\n\r\n        const T nth_root_of_abs = std::pow(std::hypot(real, imaginary), 1.0 / n);\r\n\r\n\r\n\r\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\r\n\r\n        const T nth_phi = get_argument().divide(n);\r\n\r\n        const double slice = 2 * std::numbers::pi / n;\r\n\r\n        T inner_part = nth_phi;\r\n\r\n        for (int k{}; k < n ; k++) \r\n\r\n        {\r\n\r\n            // inner part\r\n\r\n            const Field_Sin_Cos<T> sc_inner = Sin_Cos(inner_part);\r\n\r\n            const T real_part = nth_root_of_abs.multiply(sc_inner.cos());\r\n\r\n            const T imaginary_part = nth_root_of_abs.multiply(sc_inner.sin());\r\n\r\n            result.add(create_complex(real_part, imaginary_part));\r\n\r\n            inner_part = inner_part.add(slice);\r\n\r\n        }\r\n\r\n\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a complex number given the real and imaginary parts.\r\n\r\n     *\r\n\r\n     * @param real_part Real part.\r\n\r\n     * @param imaginary_part Imaginary part.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a std::complex<double> instance.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T>\r\n\r\n        value_of(T real_part, T imaginary_part) \r\n\r\n        {\r\n\r\n        if (real_part.is_nan() || imaginary_part.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(real_part.get_field());\r\n\r\n        }\r\n\r\n        return Field_std::complex<double><>(real_part, imaginary_part);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Create a complex number given only the real part.\r\n\r\n     *\r\n\r\n     * @param real_part Real part.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a std::complex<double> instance.\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Complex<T>\r\n\r\n        value_of(T real_part) \r\n\r\n        {\r\n\r\n        if (real_part.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(real_part.get_field());\r\n\r\n        }\r\n\r\n        return Field_std::complex<double><>(real_part);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> new_instance(double real_part) \r\n\r\n    {\r\n\r\n        return value_of(get_parts_field().get_zero().new_instance(real_part));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex_Field<T> get_field() \r\n\r\n    {\r\n\r\n        return Field_Complex_Field.get_field(get_parts_field());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the {@link Field} the real and imaginary parts belong to.\r\n\r\n     * @return {@link Field} the real and imaginary parts belong to\r\n\r\n     */\r\n\r\n    Field<T> get_parts_field() \r\n\r\n    {\r\n\r\n        return real.get_field();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    std::string to_string() const \r\n\r\n    {\r\n\r\n        return "(" + real + ", " + imaginary + ")";\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> scalb(const int& n) \r\n\r\n    {\r\n\r\n        return create_complex(std::scalbn(real, n), std::scalbn(imaginary, n));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> ulp() \r\n\r\n    {\r\n\r\n        return create_complex(FastMath.ulp(real), FastMath.ulp(imaginary));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> hypot(Field_Complex<T> y) \r\n\r\n    {\r\n\r\n        if (std::isinfinite() || y.std::isinfinite()) \r\n\r\n        {\r\n\r\n            return get_inf(get_parts_field());\r\n\r\n        }\r\n\r\nelse if (is_nan() || y.is_nan()) \r\n\r\n        {\r\n\r\n            return get_nan(get_parts_field());\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return multiply(this).add(y.multiply(y)).sqrt();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const Field_Complex<T>[] a, const Field_Complex<T>[] b)\r\n\r\n         \r\n\r\n        {\r\n\r\n        const int n = 2 * a.size();\r\n\r\n        const std::vector<T> real_a      = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        const std::vector<T> real_b      = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        const std::vector<T> imaginary_a = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        const std::vector<T> imaginary_b = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        for (int i{}; i < a.size(); ++i)  \r\n\r\n        {\r\n\r\n            const Field_Complex<T> ai = a[i];\r\n\r\n            const Field_Complex<T> bi = b[i];\r\n\r\n            real_a[2 * i    ]      = ai.real;\r\n\r\n            real_a[2 * i + 1]      = ai.imaginary.negate();\r\n\r\n            real_b[2 * i    ]      = bi.real;\r\n\r\n            real_b[2 * i + 1]      = bi.imaginary;\r\n\r\n            imaginary_a[2 * i    ] = ai.real;\r\n\r\n            imaginary_a[2 * i + 1] = ai.imaginary;\r\n\r\n            imaginary_b[2 * i    ] = bi.imaginary;\r\n\r\n            imaginary_b[2 * i + 1] = bi.real;\r\n\r\n        }\r\n\r\n        return create_complex(real.linear_combination(real_a,  real_b), real.linear_combination(imaginary_a, imaginary_b));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const std::vector<double> a, const Field_Complex<T>[] b)\r\n\r\n         \r\n\r\n        {\r\n\r\n        const int n = a.size();\r\n\r\n        const std::vector<T> real_b      = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        const std::vector<T> imaginary_b = Math_Arrays::build_array(get_parts_field(), n);\r\n\r\n        for (int i{}; i < a.size(); ++i)  \r\n\r\n        {\r\n\r\n            const Field_Complex<T> bi = b[i];\r\n\r\n            real_b[i]      = bi.real;\r\n\r\n            imaginary_b[i] = bi.imaginary;\r\n\r\n        }\r\n\r\n        return create_complex(real.linear_combination(a,  real_b), real.linear_combination(a, imaginary_b));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const Field_Complex<T> a1, const Field_Complex<T> b1, const Field_Complex<T> a2, const Field_Complex<T> b2) \r\n\r\n    {\r\n\r\n        return create_complex(real.linear_combination(a1.real, b1.real, a1.imaginary.negate(), b1.imaginary, a2.real, b2.real, a2.imaginary.negate(), b2.imaginary), real.linear_combination(a1.real, b1.imaginary, a1.imaginary, b1.real, a2.real, b2.imaginary, a2.imaginary, b2.real));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const double& a1, const Field_Complex<T> b1, const double& a2, const Field_Complex<T> b2) \r\n\r\n    {\r\n\r\n        return create_complex(real.linear_combination(a1, b1.real, a2, b2.real), real.linear_combination(a1, b1.imaginary, a2, b2.imaginary));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const Field_Complex<T> a1, const Field_Complex<T> b1, const Field_Complex<T> a2, const Field_Complex<T> b2, const Field_Complex<T> a3, const Field_Complex<T> b3) \r\n\r\n    {\r\n\r\n        Field_Complex<T>[] a = Math_Arrays::build_array(get_field(), 3);\r\n\r\n        a[0] = a1;\r\n\r\n        a[1] = a2;\r\n\r\n        a[2] = a3;\r\n\r\n        Field_Complex<T>[] b = Math_Arrays::build_array(get_field(), 3);\r\n\r\n        b[0] = b1;\r\n\r\n        b[1] = b2;\r\n\r\n        b[2] = b3;\r\n\r\n        return linear_combination(a, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const double& a1, const Field_Complex<T> b1, const double& a2, const Field_Complex<T> b2, const double& a3, const Field_Complex<T> b3) \r\n\r\n    {\r\n\r\n        Field_Complex<T>[] b = Math_Arrays::build_array(get_field(), 3);\r\n\r\n        b[0] = b1;\r\n\r\n        b[1] = b2;\r\n\r\n        b[2] = b3;\r\n\r\n        return linear_combination(std::vector<double>  { a1, a2, a3 }, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const Field_Complex<T> a1, const Field_Complex<T> b1, const Field_Complex<T> a2, const Field_Complex<T> b2, const Field_Complex<T> a3, const Field_Complex<T> b3, const Field_Complex<T> a4, const Field_Complex<T> b4) \r\n\r\n    {\r\n\r\n        Field_Complex<T>[] a = Math_Arrays::build_array(get_field(), 4);\r\n\r\n        a[0] = a1;\r\n\r\n        a[1] = a2;\r\n\r\n        a[2] = a3;\r\n\r\n        a[3] = a4;\r\n\r\n        Field_Complex<T>[] b = Math_Arrays::build_array(get_field(), 4);\r\n\r\n        b[0] = b1;\r\n\r\n        b[1] = b2;\r\n\r\n        b[2] = b3;\r\n\r\n        b[3] = b4;\r\n\r\n        return linear_combination(a, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> linear_combination(const double& a1, const Field_Complex<T> b1, const double& a2, const Field_Complex<T> b2, const double& a3, const Field_Complex<T> b3, const double& a4, const Field_Complex<T> b4) \r\n\r\n    {\r\n\r\n        Field_Complex<T>[] b = Math_Arrays::build_array(get_field(), 4);\r\n\r\n        b[0] = b1;\r\n\r\n        b[1] = b2;\r\n\r\n        b[2] = b3;\r\n\r\n        b[3] = b4;\r\n\r\n        return linear_combination(std::vector<double>  { a1, a2, a3, a4 }, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> ceil() \r\n\r\n    {\r\n\r\n        return create_complex(FastMath.ceil(get_real_part()), FastMath.ceil(get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> floor() \r\n\r\n    {\r\n\r\n        return create_complex(std::floor(get_real_part()), std::floor(get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> rint() \r\n\r\n    {\r\n\r\n        return create_complex(FastMath.rint(get_real_part()), FastMath.rint(get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * for complex numbers, the integer n corresponding to {@code this.subtract(remainder(a)).divide(a)}\r\n\r\n     * is a <a href="https://en.wikipedia.org/wiki/Gaussian_integer">Wikipedia - Gaussian integer</a>.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> remainder(const double& a) \r\n\r\n    {\r\n\r\n        return create_complex(std::remainder(get_real_part(), a), std::remainder(get_imaginary_part(), a));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * for complex numbers, the integer n corresponding to {@code this.subtract(remainder(a)).divide(a)}\r\n\r\n     * is a <a href="https://en.wikipedia.org/wiki/Gaussian_integer">Wikipedia - Gaussian integer</a>.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> remainder(const Field_Complex<T> a) \r\n\r\n    {\r\n\r\n        const Field_Complex<T> complex_quotient = divide(a);\r\n\r\n        const T  q_r_int           = FastMath.rint(complex_quotient.real);\r\n\r\n        const T  q_i_int           = FastMath.rint(complex_quotient.imaginary);\r\n\r\n        return create_complex(real.subtract(q_r_int.multiply(a.real)).add(q_i_int.multiply(a.imaginary)), imaginary.subtract(q_r_int.multiply(a.imaginary)).subtract(q_i_int.multiply(a.real)));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> sign() \r\n\r\n    {\r\n\r\n        if (is_nan() || is_zero()) \r\n\r\n        {\r\n\r\n            return this;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return this.divide(std::hypot(real, imaginary));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc}\r\n\r\n     * <p>\r\n\r\n     * The signs of real and imaginary parts are copied independently.\r\n\r\n     * </p>\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> copy_sign(const Field_Complex<T> z) \r\n\r\n    {\r\n\r\n        return create_complex(std::copysign(get_real_part(), z.get_real_part()), std::copysign(get_imaginary_part(), z.get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> copy_sign(double r) \r\n\r\n    {\r\n\r\n        return create_complex(std::copysign(get_real_part(), r), std::copysign(get_imaginary_part(), r));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> to_degrees() \r\n\r\n    {\r\n\r\n        return create_complex(FastMath.to_degrees(get_real_part()), FastMath.to_degrees(get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> to_radians() \r\n\r\n    {\r\n\r\n        return create_complex(FastMath.to_radians(get_real_part()), FastMath.to_radians(get_imaginary_part()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    Field_Complex<T> get_pi() \r\n\r\n    {\r\n\r\n        return get_pi(get_parts_field());\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n