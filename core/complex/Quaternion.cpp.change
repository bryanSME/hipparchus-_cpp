/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n#include <cmath>\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : <a href="http://mathworld.wolfram.com/Quaternion.html">\r\n\r\n * quaternions</a> (Hamilton's hypercomplex numbers).\r\n\r\n * <p>\r\n\r\n * Instance of this class are guaranteed to be immutable.\r\n\r\n */\r\n\r\npublic const class Quaternion  \r\n\r\n{\r\n\r\n    /** Identity quaternion. */\r\n\r\n    public static const Quaternion IDENTITY = Quaternion(1, 0, 0, 0);\r\n\r\n    /** Zero quaternion. */\r\n\r\n    public static const Quaternion ZERO = Quaternion(0, 0, 0, 0);\r\n\r\n    /** i */\r\n\r\n    public static const Quaternion I = Quaternion(0, 1, 0, 0);\r\n\r\n    /** j */\r\n\r\n    public static const Quaternion J = Quaternion(0, 0, 1, 0);\r\n\r\n    /** k */\r\n\r\n    public static const Quaternion K = Quaternion(0, 0, 0, 1);\r\n\r\n\r\n\r\n    /** Serializable version identifier. */\r\n\r\n    private static const long serial_version_uid = 20092012L;\r\n\r\n\r\n\r\n    /** First component (scalar part). */\r\n\r\n    private const double q0;\r\n\r\n    /** Second component (first vector part). */\r\n\r\n    private const double q1;\r\n\r\n    /** Third component (second vector part). */\r\n\r\n    private const double q2;\r\n\r\n    /** Fourth component (third vector part). */\r\n\r\n    private const double q3;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds a quaternion from its components.\r\n\r\n     *\r\n\r\n     * @param a Scalar component.\r\n\r\n     * @param b First vector component.\r\n\r\n     * @param c Second vector component.\r\n\r\n     * @param d Third vector component.\r\n\r\n     */\r\n\r\n    public Quaternion(const double& a, const double b, const cosnt double& c, const double d) \r\n\r\n    {\r\n\r\n        this.q0 = a;\r\n\r\n        this.q1 = b;\r\n\r\n        this.q2 = c;\r\n\r\n        this.q3 = d;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds a quaternion from scalar and vector parts.\r\n\r\n     *\r\n\r\n     * @param scalar Scalar part of the quaternion.\r\n\r\n     * @param v Components of the vector part of the quaternion.\r\n\r\n     *\r\n\r\n     * @ if the array length is not 3.\r\n\r\n     */\r\n\r\n    public Quaternion(const double scalar, const std::vector<double>& v)\r\n\r\n         \r\n\r\n        {\r\n\r\n        Math_Utils::check_dimension(v.size(), 3);\r\n\r\n        this.q0 = scalar;\r\n\r\n        this.q1 = v[0];\r\n\r\n        this.q2 = v[1];\r\n\r\n        this.q3 = v[2];\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Builds a pure quaternion from a vector (assuming that the scalar\r\n\r\n     * part is zero).\r\n\r\n     *\r\n\r\n     * @param v Components of the vector part of the pure quaternion.\r\n\r\n     */\r\n\r\n    public Quaternion(const std::vector<double>& v) \r\n\r\n    {\r\n\r\n        this(0, v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the conjugate quaternion of the instance.\r\n\r\n     *\r\n\r\n     * @return the conjugate quaternion\r\n\r\n     */\r\n\r\n    public Quaternion get_conjugate() \r\n\r\n    {\r\n\r\n        return Quaternion(q0, -q1, -q2, -q3);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the Hamilton product of two quaternions.\r\n\r\n     *\r\n\r\n     * @param q1 First quaternion.\r\n\r\n     * @param q2 Second quaternion.\r\n\r\n     * @return the product {@code q1} and {@code q2}, in that order.\r\n\r\n     */\r\n\r\n    public static Quaternion multiply(const Quaternion q1, const Quaternion q2) \r\n\r\n    {\r\n\r\n        // Components of the first quaternion.\r\n\r\n        const double q1a = q1.get_q0();\r\n\r\n        const double q1b = q1.get_q1();\r\n\r\n        const double q1c = q1.get_q2();\r\n\r\n        const double q1.0= q1.get_q3();\r\n\r\n\r\n\r\n        // Components of the second quaternion.\r\n\r\n        const double q2a = q2.get_q0();\r\n\r\n        const double q2b = q2.get_q1();\r\n\r\n        const double q2c = q2.get_q2();\r\n\r\n        const double q2d = q2.get_q3();\r\n\r\n\r\n\r\n        // Components of the product.\r\n\r\n        const double w = q1a * q2a - q1b * q2b - q1c * q2c - q1.0* q2d;\r\n\r\n        const double x = q1a * q2b + q1b * q2a + q1c * q2d - q1.0* q2c;\r\n\r\n        const double y = q1a * q2c - q1b * q2d + q1c * q2a + q1.0* q2b;\r\n\r\n        const double z = q1a * q2d + q1b * q2c - q1c * q2b + q1.0* q2a;\r\n\r\n\r\n\r\n        return Quaternion(w, x, y, z);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the Hamilton product of the instance by a quaternion.\r\n\r\n     *\r\n\r\n     * @param q Quaternion.\r\n\r\n     * @return the product of this instance with {@code q}, in that order.\r\n\r\n     */\r\n\r\n    public Quaternion multiply(const Quaternion q) \r\n\r\n    {\r\n\r\n        return multiply(this, q);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the sum of two quaternions.\r\n\r\n     *\r\n\r\n     * @param q1 Quaternion.\r\n\r\n     * @param q2 Quaternion.\r\n\r\n     * @return the sum of {@code q1} and {@code q2}.\r\n\r\n     */\r\n\r\n    public static Quaternion add(const Quaternion q1, const Quaternion q2) \r\n\r\n    {\r\n\r\n        return Quaternion(q1.get_q0() + q2.get_q0(), q1.get_q1() + q2.get_q1(), q1.get_q2() + q2.get_q2(), q1.get_q3() + q2.get_q3());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the sum of the instance and another quaternion.\r\n\r\n     *\r\n\r\n     * @param q Quaternion.\r\n\r\n     * @return the sum of this instance and {@code q}\r\n\r\n     */\r\n\r\n    public Quaternion add(const Quaternion q) \r\n\r\n    {\r\n\r\n        return add(this, q);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtracts two quaternions.\r\n\r\n     *\r\n\r\n     * @param q1 First Quaternion.\r\n\r\n     * @param q2 Second quaternion.\r\n\r\n     * @return the difference between {@code q1} and {@code q2}.\r\n\r\n     */\r\n\r\n    public static Quaternion subtract(const Quaternion q1, const Quaternion q2) \r\n\r\n    {\r\n\r\n        return Quaternion(q1.get_q0() - q2.get_q0(), q1.get_q1() - q2.get_q1(), q1.get_q2() - q2.get_q2(), q1.get_q3() - q2.get_q3());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Subtracts a quaternion from the instance.\r\n\r\n     *\r\n\r\n     * @param q Quaternion.\r\n\r\n     * @return the difference between this instance and {@code q}.\r\n\r\n     */\r\n\r\n    public Quaternion subtract(const Quaternion q) \r\n\r\n    {\r\n\r\n        return subtract(this, q);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the dot-product of two quaternions.\r\n\r\n     *\r\n\r\n     * @param q1 Quaternion.\r\n\r\n     * @param q2 Quaternion.\r\n\r\n     * @return the dot product of {@code q1} and {@code q2}.\r\n\r\n     */\r\n\r\n    public static double dot_product(const Quaternion q1, const Quaternion q2) \r\n\r\n    {\r\n\r\n        return q1.get_q0() * q2.get_q0() +\r\n\r\n            q1.get_q1() * q2.get_q1() +\r\n\r\n            q1.get_q2() * q2.get_q2() +\r\n\r\n            q1.get_q3() * q2.get_q3();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the dot-product of the instance by a quaternion.\r\n\r\n     *\r\n\r\n     * @param q Quaternion.\r\n\r\n     * @return the dot product of this instance and {@code q}.\r\n\r\n     */\r\n\r\n    public double dot_product(const Quaternion q) \r\n\r\n    {\r\n\r\n        return dot_product(this, q);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the norm of the quaternion.\r\n\r\n     *\r\n\r\n     * @return the norm.\r\n\r\n     */\r\n\r\n    public double get_norm() \r\n\r\n    {\r\n\r\n        return std::sqrt(q0 * q0 +\r\n\r\n                             q1 * q1 +\r\n\r\n                             q2 * q2 +\r\n\r\n                             q3 * q3);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Computes the normalized quaternion (the versor of the instance).\r\n\r\n     * The norm of the quaternion must not be zero.\r\n\r\n     *\r\n\r\n     * @return a normalized quaternion.\r\n\r\n     * @ if the norm of the quaternion is zero.\r\n\r\n     */\r\n\r\n    public Quaternion normalize() \r\n\r\n    {\r\n\r\n        const double norm = get_norm();\r\n\r\n\r\n\r\n        if (norm < Precision.SAFE_MIN) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NORM, norm);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Quaternion(q0 / norm, q1 / norm, q2 / norm, q3 / norm);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public bool equals(Object other) \r\n\r\n    {\r\n\r\n        if (this == other) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        if (other instanceof Quaternion) \r\n\r\n        {\r\n\r\n            const Quaternion q = (Quaternion) other;\r\n\r\n            return q0 == q.get_q0() &&\r\n\r\n                q1 == q.get_q1() &&\r\n\r\n                q2 == q.get_q2() &&\r\n\r\n                q3 == q.get_q3();\r\n\r\n        }\r\n\r\n\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public int hash_code() \r\n\r\n    {\r\n\r\n        // "Effective Java" (second edition, p. 47).\r\n\r\n        int result = 17;\r\n\r\n        for (double comp : std::vector<double> { q0, q1, q2, q3 }) \r\n\r\n        {\r\n\r\n            const int c = Math_Utils::hash(comp);\r\n\r\n            result = 31 * result + c;\r\n\r\n        }\r\n\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether this instance is equal to another quaternion\r\n\r\n     * within a given tolerance.\r\n\r\n     *\r\n\r\n     * @param q Quaternion with which to compare the current quaternion.\r\n\r\n     * @param eps Tolerance.\r\n\r\n     * @return {@code true} if the each of the components are equal\r\n\r\n     * within the allowed absolute error.\r\n\r\n     */\r\n\r\n    public bool equals(const Quaternion q, const double eps) \r\n\r\n    {\r\n\r\n        return Precision.equals(q0, q.get_q0(), eps) &&\r\n\r\n            Precision.equals(q1, q.get_q1(), eps) &&\r\n\r\n            Precision.equals(q2, q.get_q2(), eps) &&\r\n\r\n            Precision.equals(q3, q.get_q3(), eps);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether the instance is a unit quaternion within a given\r\n\r\n     * tolerance.\r\n\r\n     *\r\n\r\n     * @param eps Tolerance (absolute error).\r\n\r\n     * @return {@code true} if the norm is 1 within the given tolerance, * {@code false} otherwise\r\n\r\n     */\r\n\r\n    public bool is_unit_quaternion(double eps) \r\n\r\n    {\r\n\r\n        return Precision.equals(get_norm(), 1d, eps);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Checks whether the instance is a pure quaternion within a given\r\n\r\n     * tolerance.\r\n\r\n     *\r\n\r\n     * @param eps Tolerance (absolute error).\r\n\r\n     * @return {@code true} if the scalar part of the quaternion is zero.\r\n\r\n     */\r\n\r\n    public bool is_pure_quaternion(double eps) \r\n\r\n    {\r\n\r\n        return std::abs(get_q0()) <= eps;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the polar form of the quaternion.\r\n\r\n     *\r\n\r\n     * @return the unit quaternion with positive scalar part.\r\n\r\n     */\r\n\r\n    public Quaternion get_positive_polar_form() \r\n\r\n    {\r\n\r\n        if (get_q0() < 0) \r\n\r\n        {\r\n\r\n            const Quaternion unit_q = normalize();\r\n\r\n            // The quaternion of rotation (normalized quaternion) q and -q\r\n\r\n            // are equivalent (i.e. represent the same rotation).\r\n\r\n            return Quaternion(-unit_q.get_q0(), -unit_q.get_q1(), -unit_q.get_q2(), -unit_q.get_q3());\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return this.normalize();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns the inverse of this instance.\r\n\r\n     * The norm of the quaternion must not be zero.\r\n\r\n     *\r\n\r\n     * @return the inverse.\r\n\r\n     * @ if the norm (squared) of the quaternion is zero.\r\n\r\n     */\r\n\r\n    public Quaternion get_inverse() \r\n\r\n    {\r\n\r\n        const double square_norm = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3;\r\n\r\n        if (square_norm < Precision.SAFE_MIN) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.NORM, square_norm);\r\n\r\n        }\r\n\r\n\r\n\r\n        return Quaternion(q0 / square_norm, -q1 / square_norm, -q2 / square_norm, -q3 / square_norm);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the first component of the quaternion (scalar part).\r\n\r\n     *\r\n\r\n     * @return the scalar part.\r\n\r\n     */\r\n\r\n    public double get_q0() \r\n\r\n    {\r\n\r\n        return q0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the second component of the quaternion (first component\r\n\r\n     * of the vector part).\r\n\r\n     *\r\n\r\n     * @return the first component of the vector part.\r\n\r\n     */\r\n\r\n    public double get_q1() \r\n\r\n    {\r\n\r\n        return q1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the third component of the quaternion (second component\r\n\r\n     * of the vector part).\r\n\r\n     *\r\n\r\n     * @return the second component of the vector part.\r\n\r\n     */\r\n\r\n    public double get_q2() \r\n\r\n    {\r\n\r\n        return q2;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the fourth component of the quaternion (third component\r\n\r\n     * of the vector part).\r\n\r\n     *\r\n\r\n     * @return the third component of the vector part.\r\n\r\n     */\r\n\r\n    public double get_q3() \r\n\r\n    {\r\n\r\n        return q3;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the scalar part of the quaternion.\r\n\r\n     *\r\n\r\n     * @return the scalar part.\r\n\r\n     * @see #get_q0()\r\n\r\n     */\r\n\r\n    public double get_scalar_part() \r\n\r\n    {\r\n\r\n        return get_q0();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Gets the three components of the vector part of the quaternion.\r\n\r\n     *\r\n\r\n     * @return the vector part.\r\n\r\n     * @see #get_q1()\r\n\r\n     * @see #get_q2()\r\n\r\n     * @see #get_q3()\r\n\r\n     */\r\n\r\n    public std::vector<double> get_vector_part() \r\n\r\n    {\r\n\r\n        return std::vector<double> { get_q1(), get_q2(), get_q3() };\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Multiplies the instance by a scalar.\r\n\r\n     *\r\n\r\n     * @param alpha Scalar factor.\r\n\r\n     * @return a scaled quaternion.\r\n\r\n     */\r\n\r\n    public Quaternion multiply(const double& alpha) \r\n\r\n    {\r\n\r\n        return Quaternion(alpha * q0, alpha * q1, alpha * q2, alpha * q3);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * {@inherit_doc}\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    public std::string to_string() const \r\n\r\n    {\r\n\r\n        const std::string sp = " ";\r\n\r\n        const std::stringBuilder s = std::stringstream();\r\n\r\n        s.append('[')\r\n\r\n            .append(q0).append(sp)\r\n\r\n            .append(q1).append(sp)\r\n\r\n            .append(q2).append(sp)\r\n\r\n            .append(q3)\r\n\r\n            .append(']');\r\n\r\n\r\n\r\n        return s.to_string();\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n