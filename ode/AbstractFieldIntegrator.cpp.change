/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.Collection;\r\n\r\n//import java.util.Collections;\r\n\r\n//import java.util.Comparator;\r\n\r\n//import java.util.List;\r\n\r\n//import java.util.Priority_Queue;\r\n\r\n//import java.util.Queue;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.analysis.solvers.Bracketed_Real_Field_Univariate_Solver;\r\n\r\n//import org.hipparchus.analysis.solvers.FieldBracketing_Nth_Order_Brent_Solver;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.ode.events.Action;\r\n\r\n//import org.hipparchus.ode.events.Field_Event_Handler_Configuration;\r\n\r\n//import org.hipparchus.ode.events.Field_Event_State;\r\n\r\n//import org.hipparchus.ode.events.Field_Event_State.Event_Occurrence;\r\n\r\n//import org.hipparchus.ode.events.FieldODE_Event_Handler;\r\n\r\n//import org.hipparchus.ode.sampling.AbstractFieldODE_StateInterpolator;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_Step_Handler;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Incrementor;\r\n\r\n\r\n\r\n/**\r\n\r\n * Base class managing common boilerplate for all integrators.\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class Abstract_Field_Integrator : FieldODE_Integrator<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Default relative accuracy. */\r\n\r\n    private static const double DEFAULT_RELATIVE_ACCURACY = 0;\r\n\r\n\r\n\r\n    /** Default function value accuracy. */\r\n\r\n    private static const double DEFAULT_FUNCTION_VALUE_ACCURACY = 0;\r\n\r\n\r\n\r\n    /** Step handler. */\r\n\r\n    private Collection<FieldODE_Step_Handler<T>> step_handlers;\r\n\r\n\r\n\r\n    /** Current step start. */\r\n\r\n    private Field_ODE_State_And_Derivative<T> step_start;\r\n\r\n\r\n\r\n    /** Current stepsize. */\r\n\r\n    private T step_size;\r\n\r\n\r\n\r\n    /** Indicator for last step. */\r\n\r\n    private bool is_last_step;\r\n\r\n\r\n\r\n    /** Indicator that a state or derivative reset was triggered by some event. */\r\n\r\n    private bool reset_occurred;\r\n\r\n\r\n\r\n    /** Field to which the time and state vector elements belong. */\r\n\r\n    private const Field<T> field;\r\n\r\n\r\n\r\n    /** Events states. */\r\n\r\n    private Collection<Field_Event_State<T>> events_states;\r\n\r\n\r\n\r\n    /** Initialization indicator of events states. */\r\n\r\n    private bool states_initialized;\r\n\r\n\r\n\r\n    /** Name of the method. */\r\n\r\n    private const std::string name;\r\n\r\n\r\n\r\n    /** Counter for number of evaluations. */\r\n\r\n    private Incrementor evaluations;\r\n\r\n\r\n\r\n    /** Differential equations to integrate. */\r\n\r\n    private transient FieldExpandable_ODE<T> equations;\r\n\r\n\r\n\r\n    /** Build an instance.\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param name name of the method\r\n\r\n     */\r\n\r\n    protected Abstract_Field_Integrator(const Field<T> field, const std::string name) \r\n\r\n    {\r\n\r\n        this.field        = field;\r\n\r\n        this.name         = name;\r\n\r\n        step_handlers      = Array_list<>();\r\n\r\n        step_start         = null;\r\n\r\n        step_size          = null;\r\n\r\n        events_states      = Array_list<>();\r\n\r\n        states_initialized = false;\r\n\r\n        evaluations       = Incrementor();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the field to which state vector elements belong.\r\n\r\n     * @return field to which state vector elements belong\r\n\r\n     */\r\n\r\n    public Field<T> get_field() \r\n\r\n    {\r\n\r\n        return field;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::string get_name() \r\n\r\n    {\r\n\r\n        return name;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void add_step_handler(const FieldODE_Step_Handler<T> handler) \r\n\r\n    {\r\n\r\n        step_handlers.add(handler);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Collection<FieldODE_Step_Handler<T>> get_step_handlers() \r\n\r\n    {\r\n\r\n        return Collections.unmodifiable_collection(step_handlers);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void clear_step_handlers() \r\n\r\n    {\r\n\r\n        step_handlers.clear();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void add_event_handler(const FieldODE_Event_Handler<T> handler, const double max_check_interval, const double convergence, const int max_iteration_count) \r\n\r\n    {\r\n\r\n        add_event_handler(handler, max_check_interval, convergence, max_iteration_count, FieldBracketing_Nth_Order_Brent_Solver<T>(field.get_zero().add(DEFAULT_RELATIVE_ACCURACY), field.get_zero().add(convergence), field.get_zero().add(DEFAULT_FUNCTION_VALUE_ACCURACY), 5));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void add_event_handler(const FieldODE_Event_Handler<T> handler, const double max_check_interval, const double convergence, const int max_iteration_count, const Bracketed_Real_Field_Univariate_Solver<T> solver) \r\n\r\n    {\r\n\r\n        events_states.add(new Field_Event_State<T>(handler, max_check_interval, field.get_zero().new_instance(convergence), max_iteration_count, solver));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Collection<FieldODE_Event_Handler<T>> get_event_handlers() \r\n\r\n    {\r\n\r\n        const List<FieldODE_Event_Handler<T>> list = Array_list<>(events_states.size());\r\n\r\n        for (Field_Event_State<T> state : events_states) \r\n\r\n        {\r\n\r\n            list.add(state.get_event_handler());\r\n\r\n        }\r\n\r\n        return Collections.unmodifiable_collection(list);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Collection<Field_Event_Handler_Configuration<T>> get_event_handlers_configurations() \r\n\r\n    {\r\n\r\n        return Collections.unmodifiable_collection(events_states);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void clear_event_handlers() \r\n\r\n    {\r\n\r\n        events_states.clear();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public T get_current_signed_stepsize() \r\n\r\n    {\r\n\r\n        return step_size;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void set_max_evaluations(const int& max_evaluations) \r\n\r\n    {\r\n\r\n        evaluations = evaluations.with_maximal_count((max_evaluations < 0) ? Integer.MAX_VALUE : max_evaluations);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_max_evaluations() \r\n\r\n    {\r\n\r\n        return evaluations.get_maximal_count();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_evaluations() \r\n\r\n    {\r\n\r\n        return evaluations.get_count();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Prepare the start of an integration.\r\n\r\n     * @param eqn equations to integrate\r\n\r\n     * @param s0 initial state vector\r\n\r\n     * @param t target time for the integration\r\n\r\n     * @return initial state with derivatives added\r\n\r\n     */\r\n\r\n    protected Field_ODE_State_And_Derivative<T> init_integration(const FieldExpandable_ODE<T> eqn, const FieldODE_State<T> s0, const T t) \r\n\r\n    {\r\n\r\n\r\n\r\n        this.equations = eqn;\r\n\r\n        evaluations    = evaluations.with_count(0);\r\n\r\n\r\n\r\n        // initialize ODE\r\n\r\n        eqn.init(s0, t);\r\n\r\n\r\n\r\n        // set up derivatives of initial state (including primary and secondary components)\r\n\r\n        const T   t0    = s0.get_time();\r\n\r\n        const std::vector<T> y0    = s0.get_complete_state();\r\n\r\n        const std::vector<T> y0_dot = compute_derivatives(t0, y0);\r\n\r\n\r\n\r\n        // built the state\r\n\r\n        const Field_ODE_State_And_Derivative<T> s0_with_derivatives =\r\n\r\n                        eqn.get_mapper().map_state_and_derivative(t0, y0, y0_dot);\r\n\r\n\r\n\r\n        // initialize event handlers\r\n\r\n        for (const Field_Event_State<T> state : events_states) \r\n\r\n        {\r\n\r\n            state.get_event_handler().init(s0_with_derivatives, t);\r\n\r\n        }\r\n\r\n\r\n\r\n        // initialize step handlers\r\n\r\n        for (FieldODE_Step_Handler<T> handler : step_handlers) \r\n\r\n        {\r\n\r\n            handler.init(s0_with_derivatives, t);\r\n\r\n        }\r\n\r\n\r\n\r\n        set_state_initialized(false);\r\n\r\n\r\n\r\n        return s0_with_derivatives;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the differential equations to integrate.\r\n\r\n     * @return differential equations to integrate\r\n\r\n     */\r\n\r\n    protected FieldExpandable_ODE<T> get_equations() \r\n\r\n    {\r\n\r\n        return equations;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the evaluations counter.\r\n\r\n     * @return evaluations counter\r\n\r\n     */\r\n\r\n    protected Incrementor get_evaluations_counter() \r\n\r\n    {\r\n\r\n        return evaluations;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the derivatives and check the number of evaluations.\r\n\r\n     * @param t current value of the independent <I>time</I> variable\r\n\r\n     * @param y array containing the current value of the state vector\r\n\r\n     * @return state completed with derivatives\r\n\r\n     * @exception  if arrays dimensions do not match equations settings\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * @exception Null_Pointer_Exception if the ODE equations have not been set (i.e. if this method\r\n\r\n     * is called outside of a call to {@link #integrate(FieldExpandable_ODE, FieldODE_State, * Calculus_Field_Element) integrate}\r\n\r\n     */\r\n\r\n    public std::vector<T> compute_derivatives(const T t, const std::vector<T> y)\r\n\r\n        , Math_Illegal_State_Exception, Null_Pointer_Exception \r\n\r\n        {\r\n\r\n        evaluations.increment();\r\n\r\n        return equations.compute_derivatives(t, y);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the state_initialized flag.\r\n\r\n     * <p>This method must be called by integrators with the value\r\n\r\n     * {@code false} before they start integration, so a proper lazy\r\n\r\n     * initialization is done automatically on the first step.</p>\r\n\r\n     * @param state_initialized value for the flag\r\n\r\n     */\r\n\r\n    protected void set_state_initialized(const bool state_initialized) \r\n\r\n    {\r\n\r\n        this.states_initialized = state_initialized;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Accept a step, triggering events and step handlers.\r\n\r\n     *\r\n\r\n     * @param interpolator step interpolator\r\n\r\n     * @param t_end         const integration time\r\n\r\n     * @return state at end of step\r\n\r\n     * @Math_Illegal_State_Exception    if the interpolator one because the\r\n\r\n     *                                      number of functions evaluations is exceeded\r\n\r\n     * @ if the location of an event cannot be\r\n\r\n     *                                      bracketed\r\n\r\n     * @ if arrays dimensions do not match equations\r\n\r\n     *                                      settings\r\n\r\n     */\r\n\r\n    protected Field_ODE_State_And_Derivative<T> accept_step(const AbstractFieldODE_StateInterpolator<T> interpolator, const T t_end)\r\n\r\n            , Math_Illegal_State_Exception \r\n\r\n            {\r\n\r\n\r\n\r\n        Field_ODE_State_And_Derivative<T> previous_state = interpolator.get_global_previous_state();\r\n\r\n        const Field_ODE_State_And_Derivative<T> current_state = interpolator.get_global_current_state();\r\n\r\n        AbstractFieldODE_StateInterpolator<T> restricted = interpolator;\r\n\r\n\r\n\r\n        // initialize the events states if needed\r\n\r\n        if (!states_initialized) \r\n\r\n        {\r\n\r\n            for (Field_Event_State<T> state : events_states) \r\n\r\n            {\r\n\r\n                state.reinitialize_begin(interpolator);\r\n\r\n            }\r\n\r\n            states_initialized = true;\r\n\r\n        }\r\n\r\n\r\n\r\n        // search for next events that may occur during the step\r\n\r\n        const int ordering_sign = interpolator.is_forward() ? +1 : -1;\r\n\r\n        const Queue<Field_Event_State<T>> occurring_events = Priority_Queue<>(new Comparator<Field_Event_State<T>>() \r\n\r\n        {\r\n\r\n            /** {@inherit_doc} */\r\n\r\n            //override\r\n\r\n            public int compare(Field_Event_State<T> es0, Field_Event_State<T> es1) \r\n\r\n            {\r\n\r\n                return ordering_sign * Double.compare(es0.get_event_time().get_real(), es1.get_event_time().get_real());\r\n\r\n            }\r\n\r\n        });\r\n\r\n\r\n\r\n        reset_occurred = false;\r\n\r\n        bool done_with_step = false;\r\n\r\n        reset_events:\r\n\r\n        do \r\n\r\n        {\r\n\r\n\r\n\r\n            // Evaluate all event detectors for events\r\n\r\n            occurring_events.clear();\r\n\r\n            for (const Field_Event_State<T> state : events_states) \r\n\r\n            {\r\n\r\n                if (state.evaluate_step(restricted)) \r\n\r\n                {\r\n\r\n                    // the event occurs during the current step\r\n\r\n                    occurring_events.add(state);\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            do \r\n\r\n            {\r\n\r\n\r\n\r\n                event_loop:\r\n\r\n                while (!occurring_events.is_empty()) \r\n\r\n                {\r\n\r\n\r\n\r\n                    // handle the chronologically first event\r\n\r\n                    const Field_Event_State<T> current_event = occurring_events.poll();\r\n\r\n\r\n\r\n                    // get state at event time\r\n\r\n                    Field_ODE_State_And_Derivative<T> event_state =\r\n\r\n                            restricted.get_interpolated_state(current_event.get_event_time());\r\n\r\n\r\n\r\n                    // restrict the interpolator to the first part of the step, up to the event\r\n\r\n                    restricted = restricted.restrict_step(previous_state, event_state);\r\n\r\n\r\n\r\n                    // try to advance all event states to current time\r\n\r\n                    for (const Field_Event_State<T> state : events_states) \r\n\r\n                    {\r\n\r\n                        if (state != current_event && state.try_advance(event_state, interpolator)) \r\n\r\n                        {\r\n\r\n                            // we need to handle another event first\r\n\r\n                            // remove event we just updated to prevent heap corruption\r\n\r\n                            occurring_events.remove(state);\r\n\r\n                            // add it back to update its position in the heap\r\n\r\n                            occurring_events.add(state);\r\n\r\n                            // re-queue the event we were processing\r\n\r\n                            occurring_events.add(current_event);\r\n\r\n                            continue event_loop;\r\n\r\n                        }\r\n\r\n                    }\r\n\r\n                    // all event detectors agree we can advance to the current event time\r\n\r\n\r\n\r\n                    // handle the first part of the step, up to the event\r\n\r\n                    for (const FieldODE_Step_Handler<T> handler : step_handlers) \r\n\r\n                    {\r\n\r\n                        handler.handle_step(restricted);\r\n\r\n                    }\r\n\r\n\r\n\r\n                    // acknowledge event occurrence\r\n\r\n                    const Event_Occurrence<T> occurrence = current_event.do_event(event_state);\r\n\r\n                    const Action action = occurrence.get_action();\r\n\r\n                    is_last_step = action == Action.STOP;\r\n\r\n\r\n\r\n                    if (is_last_step) \r\n\r\n                    {\r\n\r\n\r\n\r\n                        // ensure the event is after the root if it is returned STOP\r\n\r\n                        // this lets the user integrate to a STOP event and then restart\r\n\r\n                        // integration from the same time.\r\n\r\n                        const Field_ODE_State_And_Derivative<T> saved_state = event_state;\r\n\r\n                        event_state = interpolator.get_interpolated_state(occurrence.get_stop_time());\r\n\r\n                        restricted = interpolator.restrict_step(saved_state, event_state);\r\n\r\n\r\n\r\n                        // handle the almost zero size last part of the const step, at event time\r\n\r\n                        for (const FieldODE_Step_Handler<T> handler : step_handlers) \r\n\r\n                        {\r\n\r\n                            handler.handle_step(restricted);\r\n\r\n                            handler.finish(restricted.get_current_state());\r\n\r\n                        }\r\n\r\n\r\n\r\n                    }\r\n\r\n\r\n\r\n                    if (is_last_step) \r\n\r\n                    {\r\n\r\n                        // the event asked to stop integration\r\n\r\n                        return event_state;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    if (action == Action.RESET_DERIVATIVES || action == Action.RESET_STATE) \r\n\r\n                    {\r\n\r\n                        // some event handler has triggered changes that\r\n\r\n                        // invalidate the derivatives, we need to recompute them\r\n\r\n                        const FieldODE_State<T> new_state = occurrence.get_new_state();\r\n\r\n                        const std::vector<T> y = new_state.get_complete_state();\r\n\r\n                        const std::vector<T> y_dot = compute_derivatives(new_state.get_time(), y);\r\n\r\n                        reset_occurred = true;\r\n\r\n                        return equations.get_mapper().map_state_and_derivative(new_state.get_time(), y, y_dot);\r\n\r\n                    }\r\n\r\n                    // at this point action == Action.CONTINUE or Action.RESET_EVENTS\r\n\r\n\r\n\r\n                    // prepare handling of the remaining part of the step\r\n\r\n                    previous_state = event_state;\r\n\r\n                    restricted = restricted.restrict_step(event_state, current_state);\r\n\r\n\r\n\r\n                    if (action == Action.RESET_EVENTS) \r\n\r\n                    {\r\n\r\n                        continue reset_events;\r\n\r\n                    }\r\n\r\n\r\n\r\n                    // at this point action == Action.CONTINUE\r\n\r\n                    // check if the same event occurs again in the remaining part of the step\r\n\r\n                    if (current_event.evaluate_step(restricted)) \r\n\r\n                    {\r\n\r\n                        // the event occurs during the current step\r\n\r\n                        occurring_events.add(current_event);\r\n\r\n                    }\r\n\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n                // last part of the step, after the last event\r\n\r\n                // may be a event here if the last event modified the g function of\r\n\r\n                // another event detector.\r\n\r\n                for (const Field_Event_State<T> state : events_states) \r\n\r\n                {\r\n\r\n                    if (state.try_advance(current_state, interpolator)) \r\n\r\n                    {\r\n\r\n                        occurring_events.add(state);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n            } while (!occurring_events.is_empty());\r\n\r\n\r\n\r\n            done_with_step = true;\r\n\r\n        } while (!done_with_step);\r\n\r\n\r\n\r\n\r\n\r\n        is_last_step = is_last_step || current_state.get_time().subtract(t_end).norm() <= FastMath.ulp(t_end.get_real());\r\n\r\n\r\n\r\n        // handle the remaining part of the step, after all events if any\r\n\r\n        for (FieldODE_Step_Handler<T> handler : step_handlers) \r\n\r\n        {\r\n\r\n            handler.handle_step(restricted);\r\n\r\n            if (is_last_step) \r\n\r\n            {\r\n\r\n                handler.finish(restricted.get_current_state());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return current_state;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check the integration span.\r\n\r\n     * @param initial_state initial state\r\n\r\n     * @param t target time for the integration\r\n\r\n     * @exception  if integration span is too small\r\n\r\n     * @exception  if adaptive step size integrators\r\n\r\n     * tolerance arrays dimensions are not compatible with equations settings\r\n\r\n     */\r\n\r\n    protected void sanity_checks(const FieldODE_State<T> initial_state, const T t)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        const double threshold = 1000 * FastMath.ulp(std::max(std::abs(initial_state.get_time().get_real()), std::abs(t.get_real())));\r\n\r\n        const double dt = initial_state.get_time().subtract(t).norm();\r\n\r\n        if (dt <= threshold) \r\n\r\n        {\r\n\r\n            throw (Localized_ODE_Formats.TOO_SMALL_INTEGRATION_INTERVAL, dt, threshold, false);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check if a reset occurred while last step was accepted.\r\n\r\n     * @return true if a reset occurred while last step was accepted\r\n\r\n     */\r\n\r\n    protected bool reset_occurred() \r\n\r\n    {\r\n\r\n        return reset_occurred;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the current step size.\r\n\r\n     * @param step_size step size to set\r\n\r\n     */\r\n\r\n    protected void set_step_size(const T step_size) \r\n\r\n    {\r\n\r\n        this.step_size = step_size;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the current step size.\r\n\r\n     * @return current step size\r\n\r\n     */\r\n\r\n    protected T get_step_size() \r\n\r\n    {\r\n\r\n        return step_size;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set current step start.\r\n\r\n     * @param step_start step start\r\n\r\n     */\r\n\r\n    protected void set_step_start(const Field_ODE_State_And_Derivative<T> step_start) \r\n\r\n    {\r\n\r\n        this.step_start = step_start;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**  {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_step_start() \r\n\r\n    {\r\n\r\n        return step_start;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the last state flag.\r\n\r\n     * @param is_last_step if true, this step is the last one\r\n\r\n     */\r\n\r\n    protected void set_is_last_step(const bool is_last_step) \r\n\r\n    {\r\n\r\n        this.is_last_step = is_last_step;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check if this step is the last one.\r\n\r\n     * @return true if this step is the last one\r\n\r\n     */\r\n\r\n    protected bool is_last_step() \r\n\r\n    {\r\n\r\n        return is_last_step;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n