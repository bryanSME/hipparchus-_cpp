/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_Step_Handler;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_StateInterpolator;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class stores all information provided by an ODE integrator\r\n\r\n * during the integration process and build a continuous model of the\r\n\r\n * solution from this.\r\n\r\n *\r\n\r\n * <p>This class act as a step handler from the integrator point of\r\n\r\n * view. It is called iteratively during the integration process and\r\n\r\n * stores a copy of all steps information in a sorted collection for\r\n\r\n * later use. Once the integration process is over, the user can use\r\n\r\n * the {@link #get_interpolated_state(Calculus_Field_Element) get_interpolated_state}\r\n\r\n * method to retrieve this information at any time. It is important to wait\r\n\r\n * for the integration to be over before attempting to call {@link\r\n\r\n * #get_interpolated_state(Calculus_Field_Element)} because some internal\r\n\r\n * variables are set only once the last step has been handled.</p>\r\n\r\n *\r\n\r\n * <p>This is useful for example if the main loop of the user\r\n\r\n * application should remain independent from the integration process\r\n\r\n * or if one needs to mimic the behaviour of an analytical model\r\n\r\n * despite a numerical model is used (i.e. one needs the ability to\r\n\r\n * get the model value at any time or to navigate through the\r\n\r\n * data).</p>\r\n\r\n *\r\n\r\n * <p>If problem modeling is done with several separate\r\n\r\n * integration phases for contiguous intervals, the same\r\n\r\n * FieldDense_Output_Model can be used as step handler for all\r\n\r\n * integration phases as long as they are performed in order and in\r\n\r\n * the same direction. As an example, one can extrapolate the\r\n\r\n * trajectory of a satellite with one model (i.e. one set of\r\n\r\n * differential equations) up to the beginning of a maneuver, use\r\n\r\n * another more complex model including thrusters modeling and\r\n\r\n * accurate attitude control during the maneuver, and revert to the\r\n\r\n * first model after the end of the maneuver. If the same continuous\r\n\r\n * output model handles the steps of all integration phases, the user\r\n\r\n * do not need to bother when the maneuver begins or ends, he has all\r\n\r\n * the data available in a transparent manner.</p>\r\n\r\n *\r\n\r\n * <p>One should be aware that the amount of data stored in a\r\n\r\n * FieldDense_Output_Model instance can be important if the state vector\r\n\r\n * is large, if the integration interval is long or if the steps are\r\n\r\n * small (which can result from small tolerance settings in {@link\r\n\r\n * org.hipparchus.ode.nonstiff.Adaptive_Stepsize_Field_Integrator adaptive\r\n\r\n * step size integrators}).</p>\r\n\r\n *\r\n\r\n * @see FieldODE_Step_Handler\r\n\r\n * @see FieldODE_StateInterpolator\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldDense_Output_Model\r\n\r\n    : FieldODE_Step_Handler<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Initial integration time. */\r\n\r\n    private T initial_time;\r\n\r\n\r\n\r\n    /** Final integration time. */\r\n\r\n    private T const_time;\r\n\r\n\r\n\r\n    /** Integration direction indicator. */\r\n\r\n    private bool forward;\r\n\r\n\r\n\r\n    /** Current interpolator index. */\r\n\r\n    private int index;\r\n\r\n\r\n\r\n    /** Steps table. */\r\n\r\n    private List<FieldODE_StateInterpolator<T>> steps;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build an empty continuous output model.\r\n\r\n     */\r\n\r\n    public FieldDense_Output_Model() \r\n\r\n    {\r\n\r\n        steps       = Array_list<>();\r\n\r\n        initial_time = null;\r\n\r\n        const_time   = null;\r\n\r\n        forward     = true;\r\n\r\n        index       = 0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Append another model at the end of the instance.\r\n\r\n     * @param model model to add at the end of the instance\r\n\r\n     * @exception  if the model to append is not\r\n\r\n     * compatible with the instance (dimension of the state vector, * propagation direction, hole between the dates)\r\n\r\n     * @exception  if the dimensions of the states or\r\n\r\n     * the number of secondary states do not match\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * during step constization\r\n\r\n     */\r\n\r\n    public void append(const FieldDense_Output_Model<T> model)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        if (model.steps.is_empty()) \r\n\r\n        {\r\n\r\n            return;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (steps.is_empty()) \r\n\r\n        {\r\n\r\n            initial_time = model.initial_time;\r\n\r\n            forward     = model.forward;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            // safety checks\r\n\r\n            const Field_ODE_State_And_Derivative<T> s1 = steps.get(0).get_previous_state();\r\n\r\n            const Field_ODE_State_And_Derivative<T> s2 = model.steps.get(0).get_previous_state();\r\n\r\n            check_dimensions_equality(s1.get_primary_state_dimension(), s2.get_primary_state_dimension());\r\n\r\n            check_dimensions_equality(s1.get_number_of_secondary_states(), s2.get_number_of_secondary_states());\r\n\r\n            for (int i{}; i < s1.get_number_of_secondary_states(); ++i) \r\n\r\n            {\r\n\r\n                check_dimensions_equality(s1.get_secondary_state_dimension(i), s2.get_secondary_state_dimension(i));\r\n\r\n            }\r\n\r\n\r\n\r\n            if (forward ^ model.forward) \r\n\r\n            {\r\n\r\n                throw (Localized_ODE_Formats.PROPAGATION_DIRECTION_MISMATCH);\r\n\r\n            }\r\n\r\n\r\n\r\n            const FieldODE_StateInterpolator<T> last_interpolator = steps.get(index);\r\n\r\n            const T current  = last_interpolator.get_current_state().get_time();\r\n\r\n            const T previous = last_interpolator.get_previous_state().get_time();\r\n\r\n            const T step = current.subtract(previous);\r\n\r\n            const T gap = model.get_initial_time().subtract(current);\r\n\r\n            if (gap.abs().subtract(step.abs().multiply(1.0e-3)).get_real() > 0) \r\n\r\n            {\r\n\r\n                throw (Localized_ODE_Formats.HOLE_BETWEEN_MODELS_TIME_RANGES, gap.norm());\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        for (FieldODE_StateInterpolator<T> interpolator : model.steps) \r\n\r\n        {\r\n\r\n            steps.add(interpolator);\r\n\r\n        }\r\n\r\n\r\n\r\n        index = steps.size() - 1;\r\n\r\n        const_time = (steps.get(index)).get_current_state().get_time();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check dimensions equality.\r\n\r\n     * @param d1 first dimension\r\n\r\n     * @param d2 second dimansion\r\n\r\n     * @exception  if dimensions do not match\r\n\r\n     */\r\n\r\n    private void check_dimensions_equality(const int d1, const int d2)\r\n\r\n         \r\n\r\n        {\r\n\r\n        if (d1 != d2) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, d2, d1);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void init(const Field_ODE_State_And_Derivative<T> initial_state, const T t) \r\n\r\n    {\r\n\r\n        initial_time = initial_state.get_time();\r\n\r\n        const_time   = t;\r\n\r\n        forward     = true;\r\n\r\n        index       = 0;\r\n\r\n        steps.clear();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void handle_step(const FieldODE_StateInterpolator<T> interpolator) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (steps.is_empty()) \r\n\r\n        {\r\n\r\n            initial_time = interpolator.get_previous_state().get_time();\r\n\r\n            forward     = interpolator.is_forward();\r\n\r\n        }\r\n\r\n\r\n\r\n        steps.add(interpolator);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void finish(Field_ODE_State_And_Derivative<T> const_state) \r\n\r\n    {\r\n\r\n        const_time = const_state.get_time();\r\n\r\n        index     = steps.size() - 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the initial integration time.\r\n\r\n     * @return initial integration time\r\n\r\n     */\r\n\r\n    public T get_initial_time() \r\n\r\n    {\r\n\r\n        return initial_time;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the const integration time.\r\n\r\n     * @return const integration time\r\n\r\n     */\r\n\r\n    public T get_final_time() \r\n\r\n    {\r\n\r\n        return const_time;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the state at interpolated time.\r\n\r\n     * @param time time of the interpolated point\r\n\r\n     * @return state at interpolated time\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_interpolated_state(const T time) \r\n\r\n    {\r\n\r\n\r\n\r\n        // initialize the search with the complete steps table\r\n\r\n        int i_min = 0;\r\n\r\n        const FieldODE_StateInterpolator<T> s_min = steps.get(i_min);\r\n\r\n        T t_min = s_min.get_previous_state().get_time().add(s_min.get_current_state().get_time()).multiply(0.5);\r\n\r\n\r\n\r\n        int i_max = steps.size() - 1;\r\n\r\n        const FieldODE_StateInterpolator<T> s_max = steps.get(i_max);\r\n\r\n        T t_max = s_max.get_previous_state().get_time().add(s_max.get_current_state().get_time()).multiply(0.5);\r\n\r\n\r\n\r\n        // handle points outside of the integration interval\r\n\r\n        // or in the first and last step\r\n\r\n        if (locate_point(time, s_min) <= 0) \r\n\r\n        {\r\n\r\n            index = i_min;\r\n\r\n            return s_min.get_interpolated_state(time);\r\n\r\n        }\r\n\r\n        if (locate_point(time, s_max) >= 0) \r\n\r\n        {\r\n\r\n            index = i_max;\r\n\r\n            return s_max.get_interpolated_state(time);\r\n\r\n        }\r\n\r\n\r\n\r\n        // reduction of the table slice size\r\n\r\n        while (i_max - i_min > 5) \r\n\r\n        {\r\n\r\n\r\n\r\n            // use the last estimated index as the splitting index\r\n\r\n            const FieldODE_StateInterpolator<T> si = steps.get(index);\r\n\r\n            const int location = locate_point(time, si);\r\n\r\n            if (location < 0) \r\n\r\n            {\r\n\r\n                i_max = index;\r\n\r\n                t_max = si.get_previous_state().get_time().add(si.get_current_state().get_time()).multiply(0.5);\r\n\r\n            }\r\n\r\nelse if (location > 0) \r\n\r\n            {\r\n\r\n                i_min = index;\r\n\r\n                t_min = si.get_previous_state().get_time().add(si.get_current_state().get_time()).multiply(0.5);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // we have found the target step, no need to continue searching\r\n\r\n                return si.get_interpolated_state(time);\r\n\r\n            }\r\n\r\n\r\n\r\n            // compute a estimate of the index in the reduced table slice\r\n\r\n            const int i_med = (i_min + i_max) / 2;\r\n\r\n            const FieldODE_StateInterpolator<T> s_med = steps.get(i_med);\r\n\r\n            const T t_med = s_med.get_previous_state().get_time().add(s_med.get_current_state().get_time()).multiply(0.5);\r\n\r\n\r\n\r\n            if (t_med.subtract(t_min).abs().subtract(1.0e-6).get_real() < 0 ||\r\n\r\n                t_max.subtract(t_med).abs().subtract(1.0e-6).get_real() < 0) \r\n\r\n                {\r\n\r\n                // too close to the bounds, we estimate using a simple dichotomy\r\n\r\n                index = i_med;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // estimate the index using a reverse quadratic polynomial\r\n\r\n                // (reverse means we have i = P(t), thus allowing to simply\r\n\r\n                // compute index = P(time) rather than solving a quadratic equation)\r\n\r\n                const T d12 = t_max.subtract(t_med);\r\n\r\n                const T d23 = t_med.subtract(t_min);\r\n\r\n                const T d13 = t_max.subtract(t_min);\r\n\r\n                const T dt1 = time.subtract(t_max);\r\n\r\n                const T dt2 = time.subtract(t_med);\r\n\r\n                const T dt3 = time.subtract(t_min);\r\n\r\n                const T i_lagrange =           dt2.multiply(dt3).multiply(d23).multiply(i_max).\r\n\r\n                                     subtract(dt1.multiply(dt3).multiply(d13).multiply(i_med)).\r\n\r\n                                     add(     dt1.multiply(dt2).multiply(d12).multiply(i_min)).\r\n\r\n                                     divide(d12.multiply(d23).multiply(d13));\r\n\r\n                index = static_cast<int>( FastMath.rint(i_lagrange.get_real());\r\n\r\n            }\r\n\r\n\r\n\r\n            // force the next size reduction to be at least one tenth\r\n\r\n            const int low  = std::max(i_min + 1, (9 * i_min + i_max) / 10);\r\n\r\n            const int high = std::min(i_max - 1, (i_min + 9 * i_max) / 10);\r\n\r\n            if (index < low) \r\n\r\n            {\r\n\r\n                index = low;\r\n\r\n            }\r\n\r\nelse if (index > high) \r\n\r\n            {\r\n\r\n                index = high;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // now the table slice is very small, we perform an iterative search\r\n\r\n        index = i_min;\r\n\r\n        while (index <= i_max && locate_point(time, steps.get(index)) > 0) \r\n\r\n        {\r\n\r\n            ++index;\r\n\r\n        }\r\n\r\n\r\n\r\n        return steps.get(index).get_interpolated_state(time);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compare a step interval and a double.\r\n\r\n     * @param time point to locate\r\n\r\n     * @param interval step interval\r\n\r\n     * @return -1 if the double is before the interval, 0 if it is in\r\n\r\n     * the interval, and +1 if it is after the interval, according to\r\n\r\n     * the interval direction\r\n\r\n     */\r\n\r\n    private int locate_point(const T time, const FieldODE_StateInterpolator<T> interval) \r\n\r\n    {\r\n\r\n        if (forward) \r\n\r\n        {\r\n\r\n            if (time.subtract(interval.get_previous_state().get_time()).get_real() < 0) \r\n\r\n            {\r\n\r\n                return -1;\r\n\r\n            }\r\n\r\nelse if (time.subtract(interval.get_current_state().get_time()).get_real() > 0) \r\n\r\n            {\r\n\r\n                return +1;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return 0;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        if (time.subtract(interval.get_previous_state().get_time()).get_real() > 0) \r\n\r\n        {\r\n\r\n            return -1;\r\n\r\n        }\r\n\r\nelse if (time.subtract(interval.get_current_state().get_time()).get_real() < 0) \r\n\r\n        {\r\n\r\n            return +1;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n