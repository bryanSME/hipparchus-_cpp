/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.sampling;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n\r\n\r\n/** This interface represents an interpolator over the last step\r\n\r\n * during an ODE integration.\r\n\r\n *\r\n\r\n * <p>The various ODE integrators provide objects implementing this\r\n\r\n * interface to the step handlers. These objects are often custom\r\n\r\n * objects tightly bound to the integrator internal algorithms. The\r\n\r\n * handlers can use these objects to retrieve the state vector at\r\n\r\n * intermediate times between the previous and the current grid points\r\n\r\n * (this feature is often called dense output).</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @see org.hipparchus.ode.FieldODE_Integrator\r\n\r\n * @see FieldODE_Step_Handler\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldODE_StateInterpolator \r\n\r\n{\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the state at previous grid point time.\r\n\r\n     * @return state at previous grid point time\r\n\r\n     */\r\n\r\n    Field_ODE_State_And_Derivative<T> get_previous_state();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Determines if the {@link #get_previous_state() previous state} is computed directly\r\n\r\n     * by the integrator, or if it is calculated using {@link #get_interpolated_state(Calculus_Field_Element)\r\n\r\n     * interpolation}.\r\n\r\n     *\r\n\r\n     * <p> Typically the previous state is directly computed by the integrator, but when\r\n\r\n     * events are detected the steps are shortened so that events occur on step boundaries\r\n\r\n     * which means the previous state may be computed by the interpolator.\r\n\r\n     *\r\n\r\n     * @return {@code true} if the previous state was calculated by the interpolator and\r\n\r\n     * false if it was computed directly by the integrator.\r\n\r\n     */\r\n\r\n    bool is_previous_state_interpolated();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the state at current grid point time.\r\n\r\n     * @return state at current grid point time\r\n\r\n     */\r\n\r\n    Field_ODE_State_And_Derivative<T> get_current_state();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Determines if the {@link #get_current_state() current state} is computed directly by\r\n\r\n     * the integrator, or if it is calculated using {@link #get_interpolated_state(Calculus_Field_Element)\r\n\r\n     * interpolation}.\r\n\r\n     *\r\n\r\n     * <p> Typically the current state is directly computed by the integrator, but when\r\n\r\n     * events are detected the steps are shortened so that events occur on step boundaries\r\n\r\n     * which means the current state may be computed by the interpolator.\r\n\r\n     *\r\n\r\n     * @return {@code true} if the current state was calculated by the interpolator and\r\n\r\n     * false if it was computed directly by the integrator.\r\n\r\n     */\r\n\r\n    bool is_current_state_interpolated();\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the state at interpolated time.\r\n\r\n     * <p>Setting the time outside of the current step is allowed, but\r\n\r\n     * should be used with care since the accuracy of the interpolator will\r\n\r\n     * probably be very poor far from this step. This allowance has been\r\n\r\n     * added to simplify implementation of search algorithms near the\r\n\r\n     * step endpoints.</p>\r\n\r\n     * @param time time of the interpolated point\r\n\r\n     * @return state at interpolated time\r\n\r\n     */\r\n\r\n    Field_ODE_State_And_Derivative<T> get_interpolated_state(T time);\r\n\r\n\r\n\r\n    /** Check if the natural integration direction is forward.\r\n\r\n     * <p>This method provides the integration direction as specified by\r\n\r\n     * the integrator itself, it avoid some nasty problems in\r\n\r\n     * degenerated cases like null steps due to cancellation at step\r\n\r\n     * initialization, step control or discrete events\r\n\r\n     * triggering.</p>\r\n\r\n     * @return true if the integration variable (time) increases during\r\n\r\n     * integration\r\n\r\n     */\r\n\r\n    bool is_forward();\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n