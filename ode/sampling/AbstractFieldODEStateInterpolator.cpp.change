/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.sampling;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/** This virtual class represents an interpolator over the last step\r\n\r\n * during an ODE integration.\r\n\r\n *\r\n\r\n * <p>The various ODE integrators provide objects extending this class\r\n\r\n * to the step handlers. The handlers can use these objects to\r\n\r\n * retrieve the state vector at intermediate times between the\r\n\r\n * previous and the current grid points (dense output).</p>\r\n\r\n *\r\n\r\n * @see org.hipparchus.ode.FieldODE_Integrator\r\n\r\n * @see FieldODE_Step_Handler\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class AbstractFieldODE_StateInterpolator\r\n\r\n    : FieldODE_StateInterpolator<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Global previous state. */\r\n\r\n    private const Field_ODE_State_And_Derivative<T> global_previous_state;\r\n\r\n\r\n\r\n    /** Global current state. */\r\n\r\n    private const Field_ODE_State_And_Derivative<T> global_current_state;\r\n\r\n\r\n\r\n    /** Soft previous state. */\r\n\r\n    private const Field_ODE_State_And_Derivative<T> soft_previous_state;\r\n\r\n\r\n\r\n    /** Soft current state. */\r\n\r\n    private const Field_ODE_State_And_Derivative<T> soft_current_state;\r\n\r\n\r\n\r\n    /** integration direction. */\r\n\r\n    private const bool forward;\r\n\r\n\r\n\r\n    /** Mapper for ODE equations primary and secondary components. */\r\n\r\n    private FieldEquations_mapper<T> mapper;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param is_forward integration direction indicator\r\n\r\n     * @param global_previous_state start of the global step\r\n\r\n     * @param global_current_state end of the global step\r\n\r\n     * @param soft_previous_state start of the restricted step\r\n\r\n     * @param soft_current_state end of the restricted step\r\n\r\n     * @param equations_mapper mapper for ODE equations primary and secondary components\r\n\r\n     */\r\n\r\n    protected AbstractFieldODE_StateInterpolator(const bool is_forward, const Field_ODE_State_And_Derivative<T> global_previous_state, const Field_ODE_State_And_Derivative<T> global_current_state, const Field_ODE_State_And_Derivative<T> soft_previous_state, const Field_ODE_State_And_Derivative<T> soft_current_state, const FieldEquations_mapper<T> equations_mapper) \r\n\r\n    {\r\n\r\n        this.forward             = is_forward;\r\n\r\n        this.global_previous_state = global_previous_state;\r\n\r\n        this.global_current_state  = global_current_state;\r\n\r\n        this.soft_previous_state   = soft_previous_state;\r\n\r\n        this.soft_current_state    = soft_current_state;\r\n\r\n        this.mapper              = equations_mapper;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create a restricted version of the instance.\r\n\r\n     * <p>\r\n\r\n     * The instance is not changed at all.\r\n\r\n     * </p>\r\n\r\n     * @param previous_state start of the restricted step\r\n\r\n     * @param current_state end of the restricted step\r\n\r\n     * @return restricted version of the instance\r\n\r\n     * @see #get_previous_state()\r\n\r\n     * @see #get_current_state()\r\n\r\n     */\r\n\r\n    public AbstractFieldODE_StateInterpolator<T> restrict_step(const Field_ODE_State_And_Derivative<T> previous_state, const Field_ODE_State_And_Derivative<T> current_state) \r\n\r\n    {\r\n\r\n        return create(forward, global_previous_state, global_current_state, previous_state, current_state, mapper);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create a instance.\r\n\r\n     * @param new_forward integration direction indicator\r\n\r\n     * @param new_global_previous_state start of the global step\r\n\r\n     * @param new_global_current_state end of the global step\r\n\r\n     * @param new_soft_previous_state start of the restricted step\r\n\r\n     * @param new_soft_current_state end of the restricted step\r\n\r\n     * @param new_mapper equations mapper for the all equations\r\n\r\n     * @return a instance\r\n\r\n     */\r\n\r\n    protected virtual AbstractFieldODE_StateInterpolator<T> create(bool new_forward, Field_ODE_State_And_Derivative<T> new_global_previous_state, Field_ODE_State_And_Derivative<T> new_global_current_state, Field_ODE_State_And_Derivative<T> new_soft_previous_state, Field_ODE_State_And_Derivative<T> new_soft_current_state, FieldEquations_mapper<T> new_mapper);\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the previous global grid point state.\r\n\r\n     * @return previous global grid point state\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_global_previous_state() \r\n\r\n    {\r\n\r\n        return global_previous_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the current global grid point state.\r\n\r\n     * @return current global grid point state\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_global_current_state() \r\n\r\n    {\r\n\r\n        return global_current_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_previous_state() \r\n\r\n    {\r\n\r\n        return soft_previous_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public bool is_previous_state_interpolated() \r\n\r\n    {\r\n\r\n        return soft_previous_state != global_previous_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_current_state() \r\n\r\n    {\r\n\r\n        return soft_current_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public bool is_current_state_interpolated() \r\n\r\n    {\r\n\r\n        return soft_current_state != global_current_state;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Field_ODE_State_And_Derivative<T> get_interpolated_state(const T time) \r\n\r\n    {\r\n\r\n        if (std::abs(global_current_state.get_time().subtract(global_previous_state.get_time()).get_real()) <=\r\n\r\n            FastMath.ulp(global_current_state.get_time().get_real())) \r\n\r\n            {\r\n\r\n            return global_current_state;\r\n\r\n        }\r\n\r\n        const T theta_h         = time.subtract(global_previous_state.get_time());\r\n\r\n        const T one_minus_theta_h = global_current_state.get_time().subtract(time);\r\n\r\n        const T theta          = theta_h.divide(global_current_state.get_time().subtract(global_previous_state.get_time()));\r\n\r\n        return compute_interpolated_state_and_derivatives(mapper, time, theta, theta_h, one_minus_theta_h);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public bool is_forward() \r\n\r\n    {\r\n\r\n        return forward;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the mapper for ODE equations primary and secondary components.\r\n\r\n     * @return mapper for ODE equations primary and secondary components\r\n\r\n     */\r\n\r\n    protected FieldEquations_mapper<T> get_mapper() \r\n\r\n    {\r\n\r\n        return mapper;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the state and derivatives at the interpolated time.\r\n\r\n     * This is the main processing method that should be implemented by\r\n\r\n     * the derived classes to perform the interpolation.\r\n\r\n     * @param equations_mapper mapper for ODE equations primary and secondary components\r\n\r\n     * @param time interpolation time\r\n\r\n     * @param theta normalized interpolation abscissa within the step\r\n\r\n     * (theta is zero at the previous time step and one at the current time step)\r\n\r\n     * @param theta_h time gap between the previous time and the interpolated time\r\n\r\n     * @param one_minus_theta_h time gap between the interpolated time and\r\n\r\n     * the current time\r\n\r\n     * @return interpolated state and derivatives\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     */\r\n\r\n    protected virtual Field_ODE_State_And_Derivative<T> compute_interpolated_state_and_derivatives(FieldEquations_mapper<T> equations_mapper, T time, T theta, T theta_h, T one_minus_theta_h)\r\n\r\n        Math_Illegal_State_Exception;\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n