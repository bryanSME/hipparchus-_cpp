/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/** Container for time, main and secondary state vectors.\r\n\r\n\r\n\r\n * @see FieldOrdinary_Differential_Equation\r\n\r\n * @see FieldSecondary_ODE\r\n\r\n * @see FieldODE_Integrator\r\n\r\n * @see Field_ODE_State_And_Derivative\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldODE_State \r\n\r\n{\r\n\r\n\r\n\r\n    /** Time. */\r\n\r\n    private const T time;\r\n\r\n\r\n\r\n    /** Primary state at time. */\r\n\r\n    private const std::vector<T> primary_state;\r\n\r\n\r\n\r\n    /** Secondary state at time. */\r\n\r\n    private const std::vector<std::vector<T>> secondary_state;\r\n\r\n\r\n\r\n    /** Complete dimension. */\r\n\r\n    private const int complete_dimension;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * <p>Calling this constructor is equivalent to call {@link\r\n\r\n     * #FieldODE_State(Calculus_Field_Element, Calculus_Field_Element[], Calculus_Field_Element[][])\r\n\r\n     * FieldODE_State(time, state, null)}.</p>\r\n\r\n     * @param time time\r\n\r\n     * @param primary_state primary state at time\r\n\r\n     */\r\n\r\n    public FieldODE_State(T time, std::vector<T> primary_state) \r\n\r\n    {\r\n\r\n        this(time, primary_state, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param time time\r\n\r\n     * @param primary_state primary state at time\r\n\r\n     * @param secondary_state secondary state at time (may be null)\r\n\r\n     */\r\n\r\n    public FieldODE_State(T time, std::vector<T> primary_state, std::vector<std::vector<T>> secondary_state) \r\n\r\n    {\r\n\r\n\r\n\r\n        this.time           = time;\r\n\r\n        this.primary_state   = primary_state.clone();\r\n\r\n        this.secondary_state = copy(secondary_state);\r\n\r\n\r\n\r\n        // compute once and for all the complete dimension\r\n\r\n        int dimension = primary_state.size();\r\n\r\n        if (secondary_state != null) \r\n\r\n        {\r\n\r\n            for (const std::vector<T> secondary : secondary_state) \r\n\r\n            {\r\n\r\n                dimension += secondary.size();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.complete_dimension = dimension;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Copy a two-dimensions array.\r\n\r\n     * @param original original array (may be null)\r\n\r\n     * @return copied array or null if original array was null\r\n\r\n     */\r\n\r\n    protected std::vector<std::vector<T>> copy(const std::vector<std::vector<T>> original) \r\n\r\n    {\r\n\r\n\r\n\r\n        // special handling of null arrays\r\n\r\n        if (original == null) \r\n\r\n        {\r\n\r\n            return null;\r\n\r\n        }\r\n\r\n\r\n\r\n        // allocate the array\r\n\r\n        const std::vector<std::vector<T>> copied = Math_Arrays::build_array(time.get_field(), original.size(), -1);\r\n\r\n\r\n\r\n        // copy content\r\n\r\n        for (int i{}; i < original.size(); ++i) \r\n\r\n        {\r\n\r\n            copied[i] = original[i].clone();\r\n\r\n        }\r\n\r\n\r\n\r\n        return copied;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get time.\r\n\r\n     * @return time\r\n\r\n     */\r\n\r\n    public T get_time() \r\n\r\n    {\r\n\r\n        return time;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get primary state dimension.\r\n\r\n     * @return primary state dimension\r\n\r\n     * @see #get_secondary_state_dimensionstatic_cast<int>(\r\n\r\n     * @see #get_complete_state_dimension()\r\n\r\n     */\r\n\r\n    public int get_primary_state_dimension() \r\n\r\n    {\r\n\r\n        return primary_state.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get primary state at time.\r\n\r\n     * @return primary state at time\r\n\r\n     * @see #get_secondary_statestatic_cast<int>(\r\n\r\n     * @see #get_complete_state()\r\n\r\n     */\r\n\r\n    public std::vector<T> get_primary_state() \r\n\r\n    {\r\n\r\n        return primary_state.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the number of secondary states.\r\n\r\n     * @return number of secondary states.\r\n\r\n     */\r\n\r\n    public int get_number_of_secondary_states() \r\n\r\n    {\r\n\r\n        return secondary_state == null ? 0 : secondary_state.size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get secondary state dimension.\r\n\r\n     * @param index index of the secondary set as returned\r\n\r\n     * by {@link FieldExpandable_ODE#add_secondary_equations(FieldSecondary_ODE)}\r\n\r\n     * (beware index 0 corresponds to primary state, secondary states start at 1)\r\n\r\n     * @return secondary state dimension\r\n\r\n     */\r\n\r\n    public int get_secondary_state_dimension(const int index) \r\n\r\n    {\r\n\r\n        return index == 0 ? primary_state.size() : secondary_state[index - 1].size();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get secondary state at time.\r\n\r\n     * @param index index of the secondary set as returned\r\n\r\n     * by {@link FieldExpandable_ODE#add_secondary_equations(FieldSecondary_ODE)}\r\n\r\n     * (beware index 0 corresponds to primary state, secondary states start at 1)\r\n\r\n     * @return secondary state at time\r\n\r\n     */\r\n\r\n    public std::vector<T> get_secondary_state(const int index) \r\n\r\n    {\r\n\r\n        return index == 0 ? primary_state.clone() : secondary_state[index - 1].clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Return the dimension of the complete set of equations.\r\n\r\n     * <p>\r\n\r\n     * The complete set of equations correspond to the primary set plus all secondary sets.\r\n\r\n     * </p>\r\n\r\n     * @return dimension of the complete set of equations\r\n\r\n     */\r\n\r\n    public int get_complete_state_dimension() \r\n\r\n    {\r\n\r\n        return complete_dimension;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get complete state at time.\r\n\r\n     * @return complete state at time, starting with\r\n\r\n     * {@link #get_primary_state() primary state}, followed\r\n\r\n     * by all {@link #get_secondary_statestatic_cast<int>( secondary states} in\r\n\r\n     * increasing index order\r\n\r\n     * @see #get_primary_state()\r\n\r\n     * @see #get_secondary_statestatic_cast<int>(\r\n\r\n     */\r\n\r\n    public std::vector<T> get_complete_state() \r\n\r\n    {\r\n\r\n        const std::vector<T> complete_state = Math_Arrays::build_array(time.get_field(), get_complete_state_dimension());\r\n\r\n        System.arraycopy(primary_state, 0, complete_state, 0, primary_state.size());\r\n\r\n        int offset = primary_state.size();\r\n\r\n        if (secondary_state != null) \r\n\r\n        {\r\n\r\n            for (int index = 0; index < secondary_state.size(); ++index) \r\n\r\n            {\r\n\r\n                System.arraycopy(secondary_state[index], 0, complete_state, offset, secondary_state[index].size());\r\n\r\n                offset += secondary_state[index].size();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return complete_state;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n