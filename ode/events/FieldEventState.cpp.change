/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.events;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.Calculus_Field_Univariate_Function;\r\n\r\n//import org.hipparchus.analysis.solvers.Bracketed_Real_Field_Univariate_Solver;\r\n\r\n//import org.hipparchus.analysis.solvers.Bracketed_Real_Field_Univariate_Solver.Interval;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.ode.FieldODE_State;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_StateInterpolator;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/** This class handles the state for one {@link FieldODE_Event_Handler\r\n\r\n * event handler} during integration steps.\r\n\r\n *\r\n\r\n * <p>Each time the integrator proposes a step, the event handler\r\n\r\n * switching function should be checked. This class handles the state\r\n\r\n * of one handler during one integration step, with references to the\r\n\r\n * state at the end of the preceding step. This information is used to\r\n\r\n * decide if the handler should trigger an event or not during the\r\n\r\n * proposed step.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Event_State : Field_Event_Handler_Configuration<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Event handler. */\r\n\r\n    private const FieldODE_Event_Handler<T> handler;\r\n\r\n\r\n\r\n    /** Maximal time interval between events handler checks. */\r\n\r\n    private const double max_check_interval;\r\n\r\n\r\n\r\n    /** Convergence threshold for event localization. */\r\n\r\n    private const T convergence;\r\n\r\n\r\n\r\n    /** Upper limit in the iteration count for event localization. */\r\n\r\n    private const int max_iteration_count;\r\n\r\n\r\n\r\n    /** Time at the beginning of the step. */\r\n\r\n    private T t0;\r\n\r\n\r\n\r\n    /** Value of the events handler at the beginning of the step. */\r\n\r\n    private T g0;\r\n\r\n\r\n\r\n    /** Sign of g0. */\r\n\r\n    private bool g0_positive;\r\n\r\n\r\n\r\n    /** Indicator of event expected during the step. */\r\n\r\n    private bool pending_event;\r\n\r\n\r\n\r\n    /** Occurrence time of the pending event. */\r\n\r\n    private T pending_event_time;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Time to stop propagation if the event is a stop event. Used to enable stopping at\r\n\r\n     * an event and then restarting after that event.\r\n\r\n     */\r\n\r\n    private T stop_time;\r\n\r\n\r\n\r\n    /** Time after the current event. */\r\n\r\n    private T after_event;\r\n\r\n\r\n\r\n    /** Value of the g function after the current event. */\r\n\r\n    private T after_g;\r\n\r\n\r\n\r\n    /** The earliest time considered for events. */\r\n\r\n    private T earliest_time_considered;\r\n\r\n\r\n\r\n    /** Integration direction. */\r\n\r\n    private bool forward;\r\n\r\n\r\n\r\n    /** Variation direction around pending event.\r\n\r\n     *  (this is considered with respect to the integration direction)\r\n\r\n     */\r\n\r\n    private bool increasing;\r\n\r\n\r\n\r\n    /** Root-finding algorithm to use to detect state events. */\r\n\r\n    private const Bracketed_Real_Field_Univariate_Solver<T> solver;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param handler event handler\r\n\r\n     * @param max_check_interval maximal time interval between switching\r\n\r\n     * function checks (this interval prevents missing sign changes in\r\n\r\n     * case the integration steps becomes very large)\r\n\r\n     * @param convergence convergence threshold in the event time search\r\n\r\n     * @param max_iteration_count upper limit of the iteration count in\r\n\r\n     * the event time search\r\n\r\n     * @param solver Root-finding algorithm to use to detect state events\r\n\r\n     */\r\n\r\n    public Field_Event_State(const FieldODE_Event_Handler<T> handler, const double max_check_interval, const T convergence, const int max_iteration_count, const Bracketed_Real_Field_Univariate_Solver<T> solver) \r\n\r\n    {\r\n\r\n        this.handler           = handler;\r\n\r\n        this.max_check_interval  = max_check_interval;\r\n\r\n        this.convergence       = convergence.abs();\r\n\r\n        this.max_iteration_count = max_iteration_count;\r\n\r\n        this.solver            = solver;\r\n\r\n\r\n\r\n        // some dummy values ...\r\n\r\n        t0                = null;\r\n\r\n        g0                = null;\r\n\r\n        g0_positive        = true;\r\n\r\n        pending_event      = false;\r\n\r\n        pending_event_time  = null;\r\n\r\n        increasing        = true;\r\n\r\n        earliest_time_considered = null;\r\n\r\n        after_event = null;\r\n\r\n        after_g = null;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public FieldODE_Event_Handler<T> get_event_handler() \r\n\r\n    {\r\n\r\n        return handler;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public double get_max_check_interval() \r\n\r\n    {\r\n\r\n        return max_check_interval;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public T get_convergence() \r\n\r\n    {\r\n\r\n        return convergence;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_max_iteration_count() \r\n\r\n    {\r\n\r\n        return max_iteration_count;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Bracketed_Real_Field_Univariate_Solver<T> get_solver() \r\n\r\n    {\r\n\r\n        return solver;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Reinitialize the beginning of the step.\r\n\r\n     * @param interpolator valid for the current step\r\n\r\n     * @exception Math_Illegal_State_Exception if the interpolator one because\r\n\r\n     * the number of functions evaluations is exceeded\r\n\r\n     */\r\n\r\n    public void reinitialize_begin(const FieldODE_StateInterpolator<T> interpolator)\r\n\r\n        Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        forward = interpolator.is_forward();\r\n\r\n        const Field_ODE_State_And_Derivative<T> s0 = interpolator.get_previous_state();\r\n\r\n        t0 = s0.get_time();\r\n\r\n        g0 = handler.g(s0);\r\n\r\n        while (g0.get_real() == 0) \r\n\r\n        {\r\n\r\n            // excerpt from MATH-421 issue:\r\n\r\n            // If an ODE solver is setup with a FieldODE_Event_Handler that return STOP\r\n\r\n            // when the even is triggered, the integrator stops (which is exactly\r\n\r\n            // the expected behavior). If however the user wants to restart the\r\n\r\n            // solver from the const state reached at the event with the same\r\n\r\n            // configuration (expecting the event to be triggered again at a\r\n\r\n            // later time), then the integrator may fail to start. It can get stuck\r\n\r\n            // at the previous event. The use case for the bug MATH-421 is fairly\r\n\r\n            // general, so events occurring exactly at start in the first step should\r\n\r\n            // be ignored.\r\n\r\n\r\n\r\n            // extremely rare case: there is a zero EXACTLY at interval start\r\n\r\n            // we will use the sign slightly after step beginning to force ignoring this zero\r\n\r\n            const T epsilon = max(solver.get_absolute_accuracy(), solver.get_relative_accuracy().multiply(t0).abs());\r\n\r\n            T t_start = t0.add(epsilon.multiply(forward ? 0.5 : -0.5));\r\n\r\n            if (t_start.equals(t0)) \r\n\r\n            {\r\n\r\n                t_start = next_after(t0);\r\n\r\n            }\r\n\r\n            t0 = t_start;\r\n\r\n            g0 = handler.g(interpolator.get_interpolated_state(t_start));\r\n\r\n        }\r\n\r\n        g0_positive = g0.get_real() > 0;\r\n\r\n        // "last" event was increasing\r\n\r\n        increasing = g0_positive;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the larger of two numbers.\r\n\r\n     *\r\n\r\n     * @param a first number.\r\n\r\n     * @param b second number.\r\n\r\n     * @return the larger of a and b.\r\n\r\n     */\r\n\r\n    private T max(T a, T b) \r\n\r\n    {\r\n\r\n        return a.get_real() > b.get_real() ? a : b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the smaller of two numbers.\r\n\r\n     *\r\n\r\n     * @param a first number.\r\n\r\n     * @param b second number.\r\n\r\n     * @return the smaller of a and b.\r\n\r\n     */\r\n\r\n    private T min(T a, T b) \r\n\r\n    {\r\n\r\n        return a.get_real() < b.get_real() ? a : b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Evaluate the impact of the proposed step on the event handler.\r\n\r\n     * @param interpolator step interpolator for the proposed step\r\n\r\n     * @return true if the event handler triggers an event before\r\n\r\n     * the end of the proposed step\r\n\r\n     * @exception Math_Illegal_State_Exception if the interpolator one because\r\n\r\n     * the number of functions evaluations is exceeded\r\n\r\n     * @exception  if the event cannot be bracketed\r\n\r\n     */\r\n\r\n    public bool evaluate_step(const FieldODE_StateInterpolator<T> interpolator)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        forward = interpolator.is_forward();\r\n\r\n        const Field_ODE_State_And_Derivative<T> s1 = interpolator.get_current_state();\r\n\r\n        const T t1 = s1.get_time();\r\n\r\n        const T dt = t1.subtract(t0);\r\n\r\n        if (dt.abs().subtract(convergence).get_real() < 0) \r\n\r\n        {\r\n\r\n            // we cannot do anything on such a small step, don't trigger any events\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n        const int n = std::max(1, static_cast<int>( FastMath.ceil(std::abs(dt.get_real()) / max_check_interval));\r\n\r\n        const T   h = dt.divide(n);\r\n\r\n\r\n\r\n        T ta = t0;\r\n\r\n        T ga = g0;\r\n\r\n        for (int i{}; i < n; ++i) \r\n\r\n        {\r\n\r\n\r\n\r\n            // evaluate handler value at the end of the substep\r\n\r\n            const T tb = (i == n - 1) ? t1 : t0.add(h.multiply(i + 1));\r\n\r\n            const T gb = handler.g(interpolator.get_interpolated_state(tb));\r\n\r\n\r\n\r\n            // check events occurrence\r\n\r\n            if (gb.get_real() == 0.0 || (g0_positive ^ (gb.get_real() > 0))) \r\n\r\n            {\r\n\r\n                // there is a sign change: an event is expected during this step\r\n\r\n                if (find_root(interpolator, ta, ga, tb, gb)) \r\n\r\n                {\r\n\r\n                    return true;\r\n\r\n                }\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // no sign change: there is no event for now\r\n\r\n                ta = tb;\r\n\r\n                ga = gb;\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // no event during the whole step\r\n\r\n        pending_event     = false;\r\n\r\n        pending_event_time = null;\r\n\r\n        return false;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Find a root in a bracketing interval.\r\n\r\n     *\r\n\r\n     * <p> When calling this method one of the following must be true. Either ga == 0, gb\r\n\r\n     * == 0, (ga < 0  and gb > 0), or (ga > 0 and gb < 0).\r\n\r\n     *\r\n\r\n     * @param interpolator that covers the interval.\r\n\r\n     * @param ta           earliest possible time for root.\r\n\r\n     * @param ga           g(ta).\r\n\r\n     * @param tb           latest possible time for root.\r\n\r\n     * @param gb           g(tb).\r\n\r\n     * @return if a zero crossing was found.\r\n\r\n     */\r\n\r\n    private bool find_root(const FieldODE_StateInterpolator<T> interpolator, const T ta, const T ga, const T tb, const T gb) \r\n\r\n    {\r\n\r\n        // check there appears to be a root in [ta, tb]\r\n\r\n        check(ga.get_real() == 0.0 || gb.get_real() == 0.0 ||\r\n\r\n                (ga.get_real() > 0.0 && gb.get_real() < 0.0) ||\r\n\r\n                (ga.get_real() < 0.0 && gb.get_real() > 0.0));\r\n\r\n\r\n\r\n        const Calculus_Field_Univariate_Function<T> f =\r\n\r\n                t -> handler.g(interpolator.get_interpolated_state(t));\r\n\r\n\r\n\r\n        // prepare loop below\r\n\r\n        T loop_t = ta;\r\n\r\n        T loop_g = ga;\r\n\r\n\r\n\r\n        // event time, just at or before the actual root.\r\n\r\n        T before_root_t = null;\r\n\r\n        T before_root_g = null;\r\n\r\n        // time on the other side of the root.\r\n\r\n        // Initialized the the loop below executes once.\r\n\r\n        T after_root_t = ta;\r\n\r\n        T after_root_g = ga.get_field().get_zero();\r\n\r\n\r\n\r\n        // check for some conditions that the root finders don't like\r\n\r\n        // these conditions cannot not happen in the loop below\r\n\r\n        // the ga == 0.0 case is handled by the loop below\r\n\r\n        if (ta.get_real() == tb.get_real()) \r\n\r\n        {\r\n\r\n            // both non-zero but times are the same. Probably due to reset state\r\n\r\n            before_root_t = ta;\r\n\r\n            before_root_g = ga;\r\n\r\n            after_root_t = shifted_by(before_root_t, convergence);\r\n\r\n            after_root_g = f.value(after_root_t);\r\n\r\n        }\r\n\r\nelse if (ga.get_real() != 0.0 && gb.get_real() == 0.0) \r\n\r\n        {\r\n\r\n            // hard: ga != 0.0 and gb == 0.0\r\n\r\n            // look past gb by up to convergence to find next sign\r\n\r\n            // throw an exception if g(t) = 0.0 in [tb, tb + convergence]\r\n\r\n            before_root_t = tb;\r\n\r\n            before_root_g = gb;\r\n\r\n            after_root_t = shifted_by(before_root_t, convergence);\r\n\r\n            after_root_g = f.value(after_root_t);\r\n\r\n        }\r\n\r\nelse if (ga.get_real() != 0.0) \r\n\r\n        {\r\n\r\n            const T new_ga = f.value(ta);\r\n\r\n            if (ga.get_real() > 0 != new_ga.get_real() > 0) \r\n\r\n            {\r\n\r\n                // both non-zero, step sign change at ta, possibly due to reset state\r\n\r\n                const T next_t = min_time(shifted_by(ta, convergence), tb);\r\n\r\n                const T next_g = f.value(next_t);\r\n\r\n                if (next_g.get_real() > 0.0 == g0_positive) \r\n\r\n                {\r\n\r\n                    // the sign change between ga and Ga just moved the root less than one convergence\r\n\r\n                    // threshold later, we are still in a regular search for another root before tb, // we just need to fix the bracketing interval\r\n\r\n                    // (see issue https://github.com/Hipparchus-Math/hipparchus/issues/184)\r\n\r\n                    loop_t = next_t;\r\n\r\n                    loop_g = next_g;\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    before_root_t = ta;\r\n\r\n                    before_root_g = new_ga;\r\n\r\n                    after_root_t  = next_t;\r\n\r\n                    after_root_g  = next_g;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // loop to skip through "fake" roots, i.e. where g(t) = g'(t) = 0.0\r\n\r\n        // executed once if we didn't hit a special case above\r\n\r\n        while ((after_root_g.get_real() == 0.0 || after_root_g.get_real() > 0.0 == g0_positive) &&\r\n\r\n               strictly_after(after_root_t, tb)) \r\n\r\n               {\r\n\r\n            if (loop_g.get_real() == 0.0) \r\n\r\n            {\r\n\r\n                // ga == 0.0 and gb may or may not be 0.0\r\n\r\n                // handle the root at ta first\r\n\r\n                before_root_t = loop_t;\r\n\r\n                before_root_g = loop_g;\r\n\r\n                after_root_t = min_time(shifted_by(before_root_t, convergence), tb);\r\n\r\n                after_root_g = f.value(after_root_t);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // both non-zero, the usual case, use a root finder.\r\n\r\n                if (forward) \r\n\r\n                {\r\n\r\n                    const Interval<T> interval =\r\n\r\n                            solver.solve_interval(max_iteration_count, f, loop_t, tb);\r\n\r\n                    before_root_t = interval.get_left_abscissa();\r\n\r\n                    before_root_g = interval.get_left_value();\r\n\r\n                    after_root_t = interval.get_right_abscissa();\r\n\r\n                    after_root_g = interval.get_right_value();\r\n\r\n                }\r\n\r\nelse \r\n\r\n                {\r\n\r\n                    const Interval<T> interval =\r\n\r\n                            solver.solve_interval(max_iteration_count, f, tb, loop_t);\r\n\r\n                    before_root_t = interval.get_right_abscissa();\r\n\r\n                    before_root_g = interval.get_right_value();\r\n\r\n                    after_root_t = interval.get_left_abscissa();\r\n\r\n                    after_root_g = interval.get_left_value();\r\n\r\n                }\r\n\r\n            }\r\n\r\n            // tolerance is set to less than 1 ulp\r\n\r\n            // assume tolerance is 1 ulp\r\n\r\n            if (before_root_t == after_root_t) \r\n\r\n            {\r\n\r\n                after_root_t = next_after(after_root_t);\r\n\r\n                after_root_g = f.value(after_root_t);\r\n\r\n            }\r\n\r\n            // check loop is making some progress\r\n\r\n            check((forward && after_root_t.get_real() > before_root_t.get_real()) ||\r\n\r\n                  (!forward && after_root_t.get_real() < before_root_t.get_real()));\r\n\r\n            // setup next iteration\r\n\r\n            loop_t = after_root_t;\r\n\r\n            loop_g = after_root_g;\r\n\r\n        }\r\n\r\n\r\n\r\n        // figure out the result of root finding, and return accordingly\r\n\r\n        if (after_root_g.get_real() == 0.0 || after_root_g.get_real() > 0.0 == g0_positive) \r\n\r\n        {\r\n\r\n            // loop gave up and didn't find any crossing within this step\r\n\r\n            return false;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // real crossing\r\n\r\n            check(before_root_t != null && before_root_g != null);\r\n\r\n            // variation direction, with respect to the integration direction\r\n\r\n            increasing = !g0_positive;\r\n\r\n            pending_event_time = before_root_t;\r\n\r\n            stop_time = before_root_g.get_real() == 0.0 ? before_root_t : after_root_t;\r\n\r\n            pending_event = true;\r\n\r\n            after_event = after_root_t;\r\n\r\n            after_g = after_root_g;\r\n\r\n\r\n\r\n            // check increasing set correctly\r\n\r\n            check(after_g.get_real() > 0 == increasing);\r\n\r\n            check(increasing == gb.get_real() >= ga.get_real());\r\n\r\n\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Try to accept the current history up to the given time.\r\n\r\n     *\r\n\r\n     * <p> It is not necessary to call this method before calling {@link\r\n\r\n     * #do_event(Field_ODE_State_And_Derivative)} with the same state. It is necessary to call this\r\n\r\n     * method before you call {@link #do_event(Field_ODE_State_And_Derivative)} on some other event\r\n\r\n     * detector.\r\n\r\n     *\r\n\r\n     * @param state        to try to accept.\r\n\r\n     * @param interpolator to use to find the root, if any.\r\n\r\n     * @return if the event detector has an event it has not detected before that is on or\r\n\r\n     * before the same time as {@code state}. In other words {@code false} means continue\r\n\r\n     * on while {@code true} means stop and handle my event first.\r\n\r\n     */\r\n\r\n    public bool try_advance(const Field_ODE_State_And_Derivative<T> state, const FieldODE_StateInterpolator<T> interpolator) \r\n\r\n    {\r\n\r\n        const T t = state.get_time();\r\n\r\n        // check this is only called before a pending event.\r\n\r\n        check(!pending_event || !strictly_after(pending_event_time, t));\r\n\r\n\r\n\r\n        const bool me_first;\r\n\r\n\r\n\r\n        // just found an event and we know the next time we want to search again\r\n\r\n        if (earliest_time_considered != null && strictly_after(t, earliest_time_considered)) \r\n\r\n        {\r\n\r\n            me_first = false;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            // check g function to see if there is a event\r\n\r\n            const T g = handler.g(state);\r\n\r\n            const bool positive = g.get_real() > 0;\r\n\r\n\r\n\r\n            if (positive == g0_positive) \r\n\r\n            {\r\n\r\n                // g function has expected sign\r\n\r\n                g0 = g; // g0_positive is the same\r\n\r\n                me_first = false;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // found a root we didn't expect -> find precise location\r\n\r\n                const T old_pending_event_time = pending_event_time;\r\n\r\n                const bool found_root = find_root(interpolator, t0, g0, t, g);\r\n\r\n                // make sure the root is not the same as the old root, if one exists\r\n\r\n                me_first = found_root && !pending_event_time.equals(old_pending_event_time);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        if (!me_first) \r\n\r\n        {\r\n\r\n            // advance t0 to the current time so we can't find events that occur before t\r\n\r\n            t0 = t;\r\n\r\n        }\r\n\r\n\r\n\r\n        return me_first;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Notify the user's listener of the event. The event occurs wholly within this method\r\n\r\n     * call including a call to {@link FieldODE_Event_Handler#reset_state(Field_ODE_State_And_Derivative)}\r\n\r\n     * if necessary.\r\n\r\n     *\r\n\r\n     * @param state the state at the time of the event. This must be at the same time as\r\n\r\n     *              the current value of {@link #get_event_time()}.\r\n\r\n     * @return the user's requested action and the state if the action is {@link\r\n\r\n     * Action#RESET_STATE}. Otherwise the state is {@code state}. The stop time\r\n\r\n     * indicates what time propagation should stop if the action is {@link Action#STOP}.\r\n\r\n     * This guarantees the integration will stop on or after the root, so that integration\r\n\r\n     * may be restarted safely.\r\n\r\n     */\r\n\r\n    public Event_Occurrence<T> do_event(const Field_ODE_State_And_Derivative<T> state) \r\n\r\n    {\r\n\r\n        // check event is pending and is at the same time\r\n\r\n        check(pending_event);\r\n\r\n        check(state.get_time() == this.pending_event_time);\r\n\r\n\r\n\r\n        const Action action = handler.event_occurred(state, increasing == forward);\r\n\r\n        const FieldODE_State<T> new_state;\r\n\r\n        if (action == Action.RESET_STATE) \r\n\r\n        {\r\n\r\n            new_state = handler.reset_state(state);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            new_state = state;\r\n\r\n        }\r\n\r\n        // clear pending event\r\n\r\n        pending_event = false;\r\n\r\n        pending_event_time = null;\r\n\r\n        // setup for next search\r\n\r\n        earliest_time_considered = after_event;\r\n\r\n        t0 = after_event;\r\n\r\n        g0 = after_g;\r\n\r\n        g0_positive = increasing;\r\n\r\n        // check g0_positive set correctly\r\n\r\n        check(g0.get_real() == 0.0 || g0_positive == (g0.get_real() > 0));\r\n\r\n        return Event_Occurrence<>(action, new_state, stop_time);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Check the ordering of two times.\r\n\r\n     *\r\n\r\n     * @param t1 the first time.\r\n\r\n     * @param t2 the second time.\r\n\r\n     * @return true if {@code t2} is strictly after {@code t1} in the propagation\r\n\r\n     * direction.\r\n\r\n     */\r\n\r\n    private bool strictly_after(const T t1, const T t2) \r\n\r\n    {\r\n\r\n        return forward ? t1.get_real() < t2.get_real() : t2.get_real() < t1.get_real();\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the next number after the given number in the current propagation direction.\r\n\r\n     *\r\n\r\n     * <p> Assumes T has the same precision as a double.\r\n\r\n     *\r\n\r\n     * @param t input time\r\n\r\n     * @return t +/- 1 ulp depending on the direction.\r\n\r\n     */\r\n\r\n    private T next_after(const T t) \r\n\r\n    {\r\n\r\n        // direction\r\n\r\n        const int sign = forward ? 1 : -1;\r\n\r\n        const double ulp = FastMath.ulp(t.get_real());\r\n\r\n        return t.add(sign * ulp);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Same as keyword assert, but throw a {@link Math_Runtime_Exception}.\r\n\r\n     *\r\n\r\n     * @param condition to check\r\n\r\n     * @Math_Runtime_Exception if {@code condition} is false.\r\n\r\n     */\r\n\r\n    private void check(const bool condition) Math_Runtime_Exception \r\n\r\n    {\r\n\r\n        if (!condition) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception.create_internal_error();\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the time that happens first along the current propagation direction: {@link\r\n\r\n     * #forward}.\r\n\r\n     *\r\n\r\n     * @param a first time\r\n\r\n     * @param b second time\r\n\r\n     * @return min(a, b) if forward, else max (a, b)\r\n\r\n     */\r\n\r\n    private T min_time(const T& a, const T& b) \r\n\r\n    {\r\n\r\n        return forward ? min(a, b) : max(a, b);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Shift a time value along the current integration direction: {@link #forward}.\r\n\r\n     *\r\n\r\n     * @param t     the time to shift.\r\n\r\n     * @param delta the amount to shift.\r\n\r\n     * @return t + delta if forward, else t - delta. If the result has to be rounded it\r\n\r\n     * will be rounded to be before the true value of t + delta.\r\n\r\n     */\r\n\r\n    private T shifted_by(const T t, const T delta) \r\n\r\n    {\r\n\r\n        if (forward) \r\n\r\n        {\r\n\r\n            const T ret = t.add(delta);\r\n\r\n            if (ret.subtract(t).get_real() > delta.get_real()) \r\n\r\n            {\r\n\r\n                // next_down(ret)\r\n\r\n                return ret.subtract(FastMath.ulp(ret.get_real()));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return ret;\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const T ret = t.subtract(delta);\r\n\r\n            if (t.subtract(ret).get_real() > delta.get_real()) \r\n\r\n            {\r\n\r\n                // next_up(ret)\r\n\r\n                return ret.add(FastMath.ulp(ret.get_real()));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                return ret;\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the occurrence time of the event triggered in the current step.\r\n\r\n     * @return occurrence time of the event triggered in the current\r\n\r\n     * step or infinity if no events are triggered\r\n\r\n     */\r\n\r\n    public T get_event_time() \r\n\r\n    {\r\n\r\n        return pending_event ?\r\n\r\n               pending_event_time :\r\n\r\n               t0.get_field().get_zero().add(forward ? INFINITY : -INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Class to hold the data related to an event occurrence that is needed to decide how\r\n\r\n     * to modify integration.\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public static class Event_Occurrence \r\n\r\n    {\r\n\r\n\r\n\r\n        /** User requested action. */\r\n\r\n        private const Action action;\r\n\r\n        /** New state for a reset action. */\r\n\r\n        private const FieldODE_State<T> new_state;\r\n\r\n        /** The time to stop propagation if the action is a stop event. */\r\n\r\n        private const T stop_time;\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Create a occurrence of an event.\r\n\r\n         *\r\n\r\n         * @param action   the user requested action.\r\n\r\n         * @param new_state for a reset event. Should be the current state unless the\r\n\r\n         *                 action is {@link Action#RESET_STATE}.\r\n\r\n         * @param stop_time to stop propagation if the action is {@link Action#STOP}. Used\r\n\r\n         *                 to move the stop time to just after the root.\r\n\r\n         */\r\n\r\n        Event_Occurrence(const Action action, const FieldODE_State<T> new_state, const T stop_time) \r\n\r\n        {\r\n\r\n            this.action = action;\r\n\r\n            this.new_state = new_state;\r\n\r\n            this.stop_time = stop_time;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the user requested action.\r\n\r\n         *\r\n\r\n         * @return the action.\r\n\r\n         */\r\n\r\n        public Action get_action() \r\n\r\n        {\r\n\r\n            return action;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the state for a reset action.\r\n\r\n         *\r\n\r\n         * @return the state.\r\n\r\n         */\r\n\r\n        public FieldODE_State<T> get_new_state() \r\n\r\n        {\r\n\r\n            return new_state;\r\n\r\n        }\r\n\r\n\r\n\r\n        /**\r\n\r\n         * Get the time for a stop action.\r\n\r\n         *\r\n\r\n         * @return when to stop propagation.\r\n\r\n         */\r\n\r\n        public T get_stop_time() \r\n\r\n        {\r\n\r\n            return stop_time;\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n