/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.events;\r\n\r\n\r\n\r\n//import java.util.Arrays;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.ode.FieldODE_State;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/** Wrapper used to detect only increasing or decreasing events.\r\n\r\n *\r\n\r\n * <p>General {@link FieldODE_Event_Handler events} are defined implicitly\r\n\r\n * by a {@link FieldODE_Event_Handler#g(Field_ODE_State_And_Derivative) g function} crossing\r\n\r\n * zero. This function needs to be continuous in the event neighborhood, * and its sign must remain consistent between events. This implies that\r\n\r\n * during an ODE integration, events triggered are alternately events\r\n\r\n * for which the function increases from negative to positive values, * and events for which the function decreases from positive to\r\n\r\n * negative values.\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * <p>Sometimes, users are only interested in one type of event (say\r\n\r\n * increasing events for example) and not in the other type. In these\r\n\r\n * cases, looking precisely for all events location and triggering\r\n\r\n * events that will later be ignored is a waste of computing time.</p>\r\n\r\n *\r\n\r\n * <p>Users can wrap a regular {@link FieldODE_Event_Handler event handler} in\r\n\r\n * an instance of this class and provide this wrapping instance to\r\n\r\n * the {@link org.hipparchus.ode.FieldODE_Integrator ODE solver}\r\n\r\n * in order to avoid wasting time looking for uninteresting events.\r\n\r\n * The wrapper will intercept the calls to the {@link\r\n\r\n * FieldODE_Event_Handler#g(Field_ODE_State_And_Derivative) g function} and to the {@link\r\n\r\n * FieldODE_Event_Handler#event_occurred(Field_ODE_State_And_Derivative, bool)\r\n\r\n * event_occurred} method in order to ignore uninteresting events. The\r\n\r\n * wrapped regular {@link FieldODE_Event_Handler event handler} will the see only\r\n\r\n * the interesting events, i.e. either only {@code increasing} events or\r\n\r\n * {@code decreasing} events. the number of calls to the {@link\r\n\r\n * FieldODE_Event_Handler#g(Field_ODE_State_And_Derivative) g function} will also be reduced.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldEvent_Filter : FieldODE_Event_Handler<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Number of past transformers updates stored. */\r\n\r\n    private static const int HISTORY_SIZE = 100;\r\n\r\n\r\n\r\n    /** Wrapped event handler. */\r\n\r\n    private const FieldODE_Event_Handler<T> raw_handler;\r\n\r\n\r\n\r\n    /** Filter to use. */\r\n\r\n    private const Filter_Type filter;\r\n\r\n\r\n\r\n    /** Transformers of the g function. */\r\n\r\n    private const Transformer[] transformers;\r\n\r\n\r\n\r\n    /** Update time of the transformers. */\r\n\r\n    private const std::vector<T> updates;\r\n\r\n\r\n\r\n    /** Indicator for forward integration. */\r\n\r\n    private bool forward;\r\n\r\n\r\n\r\n    /** Extreme time encountered so far. */\r\n\r\n    private T extreme_t;\r\n\r\n\r\n\r\n    /** Wrap an {@link ODE_Event_Handler event handler}.\r\n\r\n     * @param field field to which array elements belong\r\n\r\n     * @param raw_handler event handler to wrap\r\n\r\n     * @param filter filter to use\r\n\r\n     */\r\n\r\n    public FieldEvent_Filter(const Field<T> field, const FieldODE_Event_Handler<T> raw_handler, const Filter_Type filter) \r\n\r\n    {\r\n\r\n        this.raw_handler   = raw_handler;\r\n\r\n        this.filter       = filter;\r\n\r\n        this.transformers = Transformer[HISTORY_SIZE];\r\n\r\n        this.updates      = Math_Arrays::build_array(field, HISTORY_SIZE);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**  {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public void init(const Field_ODE_State_And_Derivative<T> initial_state, T const_time) \r\n\r\n    {\r\n\r\n\r\n\r\n        // delegate to raw handler\r\n\r\n        raw_handler.init(initial_state, const_time);\r\n\r\n\r\n\r\n        // initialize events triggering logic\r\n\r\n        forward  = const_time.get_real() >= initial_state.get_time().get_real();\r\n\r\n        extreme_t = const_time.get_field().get_zero().add(forward ? -INFINITY : INFINITY);\r\n\r\n        Arrays.fill(transformers, Transformer.UNINITIALIZED);\r\n\r\n        Arrays.fill(updates, extreme_t);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**  {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public T g(const Field_ODE_State_And_Derivative<T> state) \r\n\r\n    {\r\n\r\n\r\n\r\n        const T raw_g = raw_handler.g(state);\r\n\r\n\r\n\r\n        // search which transformer should be applied to g\r\n\r\n        if (forward) \r\n\r\n        {\r\n\r\n            const int last = transformers.size() - 1;\r\n\r\n            if (extreme_t.subtract(state.get_time()).get_real() < 0) \r\n\r\n            {\r\n\r\n                // we are at the forward end of the history\r\n\r\n\r\n\r\n                // check if a rough root has been crossed\r\n\r\n                const Transformer previous = transformers[last];\r\n\r\n                const Transformer next     = filter.select_transformer(previous, raw_g.get_real(), forward);\r\n\r\n                if (next != previous) \r\n\r\n                {\r\n\r\n                    // there is a root somewhere between extreme_t and t.\r\n\r\n                    // the transformer is valid for t (this is how we have just computed\r\n\r\n                    // it above), but it is in fact valid on both sides of the root, so\r\n\r\n                    // it was already valid before t and even up to previous time. We store\r\n\r\n                    // the switch at extreme_t for safety, to ensure the previous transformer\r\n\r\n                    // is not applied too close of the root\r\n\r\n                    System.arraycopy(updates,      1, updates,      0, last);\r\n\r\n                    System.arraycopy(transformers, 1, transformers, 0, last);\r\n\r\n                    updates[last]      = extreme_t;\r\n\r\n                    transformers[last] = next;\r\n\r\n                }\r\n\r\n\r\n\r\n                extreme_t = state.get_time();\r\n\r\n\r\n\r\n                // apply the transform\r\n\r\n                return next.transformed(raw_g);\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // we are in the middle of the history\r\n\r\n\r\n\r\n                // select the transformer\r\n\r\n                for (int i = last; i > 0; --i) \r\n\r\n                {\r\n\r\n                    if (updates[i].subtract(state.get_time()).get_real() <= 0) \r\n\r\n                    {\r\n\r\n                        // apply the transform\r\n\r\n                        return transformers[i].transformed(raw_g);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                return transformers[0].transformed(raw_g);\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            if (state.get_time().subtract(extreme_t).get_real() < 0) \r\n\r\n            {\r\n\r\n                // we are at the backward end of the history\r\n\r\n\r\n\r\n                // check if a rough root has been crossed\r\n\r\n                const Transformer previous = transformers[0];\r\n\r\n                const Transformer next     = filter.select_transformer(previous, raw_g.get_real(), forward);\r\n\r\n                if (next != previous) \r\n\r\n                {\r\n\r\n                    // there is a root somewhere between extreme_t and t.\r\n\r\n                    // the transformer is valid for t (this is how we have just computed\r\n\r\n                    // it above), but it is in fact valid on both sides of the root, so\r\n\r\n                    // it was already valid before t and even up to previous time. We store\r\n\r\n                    // the switch at extreme_t for safety, to ensure the previous transformer\r\n\r\n                    // is not applied too close of the root\r\n\r\n                    System.arraycopy(updates,      0, updates,      1, updates.size() - 1);\r\n\r\n                    System.arraycopy(transformers, 0, transformers, 1, transformers.size() - 1);\r\n\r\n                    updates[0]      = extreme_t;\r\n\r\n                    transformers[0] = next;\r\n\r\n                }\r\n\r\n\r\n\r\n                extreme_t = state.get_time();\r\n\r\n\r\n\r\n                // apply the transform\r\n\r\n                return next.transformed(raw_g);\r\n\r\n\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                // we are in the middle of the history\r\n\r\n\r\n\r\n                // select the transformer\r\n\r\n                for (int i{}; i < updates.size() - 1; ++i) \r\n\r\n                {\r\n\r\n                    if (state.get_time().subtract(updates[i]).get_real() <= 0) \r\n\r\n                    {\r\n\r\n                        // apply the transform\r\n\r\n                        return transformers[i].transformed(raw_g);\r\n\r\n                    }\r\n\r\n                }\r\n\r\n\r\n\r\n                return transformers[updates.size() - 1].transformed(raw_g);\r\n\r\n\r\n\r\n            }\r\n\r\n       }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**  {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Action event_occurred(const Field_ODE_State_And_Derivative<T> state, const bool increasing) \r\n\r\n    {\r\n\r\n        // delegate to raw handler, fixing increasing status on the fly\r\n\r\n        return raw_handler.event_occurred(state, filter.is_triggered_on_increasing());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**  {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public FieldODE_State<T> reset_state(const Field_ODE_State_And_Derivative<T> state) \r\n\r\n    {\r\n\r\n        // delegate to raw handler\r\n\r\n        return raw_handler.reset_state(state);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n