/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import java.util.Array_list;\r\n\r\n//import java.util.List;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\n * This class represents a combined set of first order differential equations, * with at least a primary set of equations expandable by some sets of secondary\r\n\r\n * equations.\r\n\r\n * <p>\r\n\r\n * One typical use case is the computation of the Jacobian matrix for some ODE.\r\n\r\n * In this case, the primary set of equations corresponds to the raw ODE, and we\r\n\r\n * add to this set another bunch of secondary equations which represent the Jacobian\r\n\r\n * matrix of the primary set.\r\n\r\n * </p>\r\n\r\n * <p>\r\n\r\n * We want the integrator to use <em>only</em> the primary set to estimate the\r\n\r\n * errors and hence the step sizes. It should <em>not</em> use the secondary\r\n\r\n * equations in this computation. The {@link FieldODE_Integrator integrator} will\r\n\r\n * be able to know where the primary set ends and so where the secondary sets begin.\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * @see FieldOrdinary_Differential_Equation\r\n\r\n * @see FieldSecondary_ODE\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldExpandable_ODE \r\n\r\n{\r\n\r\n\r\n\r\n    /** Primary differential equation. */\r\n\r\n    private const FieldOrdinary_Differential_Equation<T> primary;\r\n\r\n\r\n\r\n    /** Components of the expandable ODE. */\r\n\r\n    private List<FieldSecondary_ODE<T>> components;\r\n\r\n\r\n\r\n    /** Mapper for all equations. */\r\n\r\n    private FieldEquations_mapper<T> mapper;\r\n\r\n\r\n\r\n    /** Build an expandable set from its primary ODE set.\r\n\r\n     * @param primary the primary set of differential equations to be integrated.\r\n\r\n     */\r\n\r\n    public FieldExpandable_ODE(const FieldOrdinary_Differential_Equation<T> primary) \r\n\r\n    {\r\n\r\n        this.primary    = primary;\r\n\r\n        this.components = Array_list<>();\r\n\r\n        this.mapper     = FieldEquations_mapper<>(null, primary.get_dimension());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the primary set of differential equations to be integrated.\r\n\r\n     * @return primary set of differential equations to be integrated\r\n\r\n     * @since 2.2\r\n\r\n     */\r\n\r\n    public FieldOrdinary_Differential_Equation<T> get_primary() \r\n\r\n    {\r\n\r\n        return primary;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the mapper for the set of equations.\r\n\r\n     * @return mapper for the set of equations\r\n\r\n     */\r\n\r\n    public FieldEquations_mapper<T> get_mapper() \r\n\r\n    {\r\n\r\n        return mapper;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a set of secondary equations to be integrated along with the primary set.\r\n\r\n     * @param secondary secondary equations set\r\n\r\n     * @return index of the secondary equation in the expanded state, to be used\r\n\r\n     * as the parameter to {@link FieldODE_State#get_secondary_statestatic_cast<int>(} and\r\n\r\n     * {@link Field_ODE_State_And_Derivative#get_secondary_derivativestatic_cast<int>(} (beware index\r\n\r\n     * 0 corresponds to primary state, secondary states start at 1)\r\n\r\n     */\r\n\r\n    public int add_secondary_equations(const FieldSecondary_ODE<T> secondary) \r\n\r\n    {\r\n\r\n\r\n\r\n        components.add(secondary);\r\n\r\n        mapper = FieldEquations_mapper<>(mapper, secondary.get_dimension());\r\n\r\n\r\n\r\n        return components.size();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Initialize equations at the start of an ODE integration.\r\n\r\n     * @param s0 state at integration start\r\n\r\n     * @param const_time target time for the integration\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * @exception  if arrays dimensions do not match equations settings\r\n\r\n     */\r\n\r\n    public void init(const FieldODE_State<T> s0, const T const_time) \r\n\r\n    {\r\n\r\n\r\n\r\n        const T t0 = s0.get_time();\r\n\r\n\r\n\r\n        // initialize primary equations\r\n\r\n        const std::vector<T> primary0 = s0.get_primary_state();\r\n\r\n        primary.init(t0, primary0, const_time);\r\n\r\n\r\n\r\n        // initialize secondary equations\r\n\r\n        for (const int& index = 1; index < mapper.get_number_of_equations(); ++index) \r\n\r\n        {\r\n\r\n            const std::vector<T> secondary0 = s0.get_secondary_state(index);\r\n\r\n            components.get(index - 1).init(t0, primary0, secondary0, const_time);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the current time derivative of the complete state vector.\r\n\r\n     * @param t current value of the independent <I>time</I> variable\r\n\r\n     * @param y array containing the current value of the complete state vector\r\n\r\n     * @return time derivative of the complete state vector\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * @exception  if arrays dimensions do not match equations settings\r\n\r\n     */\r\n\r\n    public std::vector<T> compute_derivatives(const T t, const std::vector<T> y)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        const std::vector<T> y_dot = Math_Arrays::build_array(t.get_field(), mapper.get_total_dimension());\r\n\r\n\r\n\r\n        // compute derivatives of the primary equations\r\n\r\n        const std::vector<T> primary_state    = mapper.extract_equation_data(0, y);\r\n\r\n        const std::vector<T> primary_state_dot = primary.compute_derivatives(t, primary_state);\r\n\r\n\r\n\r\n        // Add contribution for secondary equations\r\n\r\n        for (const int& index = 1; index < mapper.get_number_of_equations(); ++index) \r\n\r\n        {\r\n\r\n            const std::vector<T> component_state    = mapper.extract_equation_data(index, y);\r\n\r\n            const std::vector<T> component_state_dot = components.get(index - 1).compute_derivatives(t, primary_state, primary_state_dot, component_state);\r\n\r\n            mapper.insert_equation_data(index, component_state_dot, y_dot);\r\n\r\n        }\r\n\r\n\r\n\r\n        // we retrieve the primary_state_dot array after the secondary equations have\r\n\r\n        // been computed in case they change the main state derivatives; this happens\r\n\r\n        // for example in optimal control when the secondary equations handle co-state, // which changes control, and the control changes the primary state\r\n\r\n        mapper.insert_equation_data(0, primary_state_dot, y_dot);\r\n\r\n\r\n\r\n        return y_dot;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n