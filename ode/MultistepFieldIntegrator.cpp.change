/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.linear.Array2DRowField_Matrix;\r\n\r\n//import org.hipparchus.ode.nonstiff.Adaptive_Stepsize_Field_Integrator;\r\n\r\n//import org.hipparchus.ode.nonstiff.Dormand_Prince853_Field_Integrator;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_StateInterpolator;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_Step_Handler;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class is the base class for multistep integrators for Ordinary\r\n\r\n * Differential Equations.\r\n\r\n * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\r\n\r\n * <pre>\r\n\r\n * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\r\n\r\n * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\r\n\r\n * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\r\n\r\n * ...\r\n\r\n * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\r\n\r\n * </pre></p>\r\n\r\n * <p>Rather than storing several previous steps separately, this implementation uses\r\n\r\n * the Nordsieck vector with higher degrees scaled derivatives all taken at the same\r\n\r\n * step (y<sub>n</sub>, s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:\r\n\r\n * <pre>\r\n\r\n * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\r\n\r\n * </pre>\r\n\r\n * (we omit the k index in the notation for clarity)</p>\r\n\r\n * <p>\r\n\r\n * Multistep integrators with Nordsieck representation are highly sensitive to\r\n\r\n * large step changes because when the step is multiplied by factor a, the\r\n\r\n * k<sup>th</sup> component of the Nordsieck vector is multiplied by a<sup>k</sup>\r\n\r\n * and the last components are the least accurate ones. The default max growth\r\n\r\n * factor is therefore set to a quite low value: 2<sup>1/order</sup>.\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * @see org.hipparchus.ode.nonstiff.Adams_Bashforth_Field_Integrator\r\n\r\n * @see org.hipparchus.ode.nonstiff.Adams_moultonFieldIntegrator\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class Multistep_Field_Integrator\r\n\r\n    extends Adaptive_Stepsize_Field_Integrator<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** First scaled derivative (h y'). */\r\n\r\n    protected std::vector<T> scaled;\r\n\r\n\r\n\r\n    /** Nordsieck matrix of the higher scaled derivatives.\r\n\r\n     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y<sup>(k)</sup>)</p>\r\n\r\n     */\r\n\r\n    protected Array2DRowField_Matrix<T> nordsieck;\r\n\r\n\r\n\r\n    /** Starter integrator. */\r\n\r\n    private FieldODE_Integrator<T> starter;\r\n\r\n\r\n\r\n    /** Number of steps of the multistep method (excluding the one being computed). */\r\n\r\n    private const int& n_steps;\r\n\r\n\r\n\r\n    /** Stepsize control exponent. */\r\n\r\n    private double exp;\r\n\r\n\r\n\r\n    /** Safety factor for stepsize control. */\r\n\r\n    private double safety;\r\n\r\n\r\n\r\n    /** Minimal reduction factor for stepsize control. */\r\n\r\n    private double min_reduction;\r\n\r\n\r\n\r\n    /** Maximal growth factor for stepsize control. */\r\n\r\n    private double max_growth;\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a multistep integrator with the given stepsize bounds.\r\n\r\n     * <p>The default starter integrator is set to the {@link\r\n\r\n     * Dormand_Prince853_Field_Integrator Dormand-Prince 8(5,3)} integrator with\r\n\r\n     * some defaults settings.</p>\r\n\r\n     * <p>\r\n\r\n     * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.\r\n\r\n     * </p>\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param name name of the method\r\n\r\n     * @param n_steps number of steps of the multistep method\r\n\r\n     * (excluding the one being computed)\r\n\r\n     * @param order order of the method\r\n\r\n     * @param min_step minimal step (must be positive even for backward\r\n\r\n     * integration), the last step can be smaller than this\r\n\r\n     * @param max_step maximal step (must be positive even for backward\r\n\r\n     * integration)\r\n\r\n     * @param scal_absolute_tolerance allowed absolute error\r\n\r\n     * @param scal_relative_tolerance allowed relative error\r\n\r\n     * @exception  if number of steps is smaller than 2\r\n\r\n     */\r\n\r\n    protected Multistep_Field_Integrator(const Field<T> field, const std::string name, const int& n_steps, const int order, const double min_step, const double max_step, const double scal_absolute_tolerance, const double scal_relative_tolerance)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        super(field, name, min_step, max_step, scal_absolute_tolerance, scal_relative_tolerance);\r\n\r\n\r\n\r\n        if (n_steps < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_ODE_Formats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS, n_steps, 2, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        starter = Dormand_Prince853_Field_Integrator<>(field, min_step, max_step, scal_absolute_tolerance, scal_relative_tolerance);\r\n\r\n        this.n_steps = n_steps;\r\n\r\n\r\n\r\n        exp = -1.0 / order;\r\n\r\n\r\n\r\n        // set the default values of the algorithm control parameters\r\n\r\n        set_safety(0.9);\r\n\r\n        set_min_reduction(0.2);\r\n\r\n        set_max_growth(std::pow(2.0, -exp));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build a multistep integrator with the given stepsize bounds.\r\n\r\n     * <p>The default starter integrator is set to the {@link\r\n\r\n     * Dormand_Prince853_Field_Integrator Dormand-Prince 8(5,3)} integrator with\r\n\r\n     * some defaults settings.</p>\r\n\r\n     * <p>\r\n\r\n     * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.\r\n\r\n     * </p>\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param name name of the method\r\n\r\n     * @param n_steps number of steps of the multistep method\r\n\r\n     * (excluding the one being computed)\r\n\r\n     * @param order order of the method\r\n\r\n     * @param min_step minimal step (must be positive even for backward\r\n\r\n     * integration), the last step can be smaller than this\r\n\r\n     * @param max_step maximal step (must be positive even for backward\r\n\r\n     * integration)\r\n\r\n     * @param vec_absolute_tolerance allowed absolute error\r\n\r\n     * @param vec_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    protected Multistep_Field_Integrator(const Field<T> field, const std::string name, const int& n_steps, const int order, const double min_step, const double max_step, const std::vector<double>& vec_absolute_tolerance, const std::vector<double>& vec_relative_tolerance) \r\n\r\n    {\r\n\r\n        super(field, name, min_step, max_step, vec_absolute_tolerance, vec_relative_tolerance);\r\n\r\n\r\n\r\n        if (n_steps < 2) \r\n\r\n        {\r\n\r\n            throw (Localized_ODE_Formats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS, n_steps, 2, true);\r\n\r\n        }\r\n\r\n\r\n\r\n        starter = Dormand_Prince853_Field_Integrator<>(field, min_step, max_step, vec_absolute_tolerance, vec_relative_tolerance);\r\n\r\n        this.n_steps = n_steps;\r\n\r\n\r\n\r\n        exp = -1.0 / order;\r\n\r\n\r\n\r\n        // set the default values of the algorithm control parameters\r\n\r\n        set_safety(0.9);\r\n\r\n        set_min_reduction(0.2);\r\n\r\n        set_max_growth(std::pow(2.0, -exp));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get the starter integrator.\r\n\r\n     * @return starter integrator\r\n\r\n     */\r\n\r\n    public FieldODE_Integrator<T> get_starter_integrator() \r\n\r\n    {\r\n\r\n        return starter;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Set the starter integrator.\r\n\r\n     * <p>The various step and event handlers for this starter integrator\r\n\r\n     * will be managed automatically by the multi-step integrator. Any\r\n\r\n     * user configuration for these elements will be cleared before use.</p>\r\n\r\n     * @param starter_integrator starter integrator\r\n\r\n     */\r\n\r\n    public void set_starter_integrator(FieldODE_Integrator<T> starter_integrator) \r\n\r\n    {\r\n\r\n        this.starter = starter_integrator;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Start the integration.\r\n\r\n     * <p>This method computes one step using the underlying starter integrator, * and initializes the Nordsieck vector at step start. The starter integrator\r\n\r\n     * purpose is only to establish initial conditions, it does not really change\r\n\r\n     * time by itself. The top level multistep integrator remains in charge of\r\n\r\n     * handling time propagation and events handling as it will starts its own\r\n\r\n     * computation right from the beginning. In a sense, the starter integrator\r\n\r\n     * can be seen as a dummy one and so it will never trigger any user event nor\r\n\r\n     * call any user step handler.</p>\r\n\r\n     * @param equations complete set of differential equations to integrate\r\n\r\n     * @param initial_state initial state (time, primary and secondary state vectors)\r\n\r\n     * @param t target time for the integration\r\n\r\n     * (can be set to a value smaller than <code>t0</code> for backward integration)\r\n\r\n     * @exception  if arrays dimension do not match equations settings\r\n\r\n     * @exception  if integration step is too small\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * @exception  if the location of an event cannot be bracketed\r\n\r\n     */\r\n\r\n    protected void start(const FieldExpandable_ODE<T> equations, const FieldODE_State<T> initial_state, const T t)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        // make sure NO user events nor user step handlers are triggered, // this is the task of the top level integrator, not the task of the starter integrator\r\n\r\n        starter.clear_event_handlers();\r\n\r\n        starter.clear_step_handlers();\r\n\r\n\r\n\r\n        // set up one specific step handler to extract initial Nordsieck vector\r\n\r\n        starter.add_step_handler(new Field_Nordsieck_Initializer((n_steps + 3) / 2));\r\n\r\n\r\n\r\n        // start integration, expecting a Initialization_completedMarkerException\r\n\r\n        try \r\n\r\n        {\r\n\r\n\r\n\r\n            starter.integrate(equations, initial_state, t);\r\n\r\n\r\n\r\n            // we should not reach this step\r\n\r\n            throw Math_Illegal_State_Exception(Localized_ODE_Formats.MULTISTEP_STARTER_STOPPED_EARLY);\r\n\r\n\r\n\r\n        }\r\n\r\ncatch (Initialization_completedMarkerException icme) { // NOPMD\r\n\r\n            // this is the expected nominal interruption of the start integrator\r\n\r\n\r\n\r\n            // count the evaluations used by the starter\r\n\r\n            get_evaluations_counter().increment(starter.get_evaluations());\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // remove the specific step handler\r\n\r\n        starter.clear_step_handlers();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Initialize the high order scaled derivatives at step start.\r\n\r\n     * @param h step size to use for scaling\r\n\r\n     * @param t first steps times\r\n\r\n     * @param y first steps states\r\n\r\n     * @param y_dot first steps derivatives\r\n\r\n     * @return Nordieck vector at first step (h<sup>2</sup>/2 y''<sub>n</sub>, * h<sup>3</sup>/6 y'''<sub>n</sub> ... h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub>)\r\n\r\n     */\r\n\r\n    protected virtual Array2DRowField_Matrix<T> initialize_high_order_derivatives(T h, std::vector<T> t, std::vector<std::vector<T>> y, std::vector<std::vector<T>> y_dot);\r\n\r\n\r\n\r\n    /** Get the minimal reduction factor for stepsize control.\r\n\r\n     * @return minimal reduction factor\r\n\r\n     */\r\n\r\n    public double get_min_reduction() \r\n\r\n    {\r\n\r\n        return min_reduction;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the minimal reduction factor for stepsize control.\r\n\r\n     * @param min_reduction minimal reduction factor\r\n\r\n     */\r\n\r\n    public void set_min_reduction(const double min_reduction) \r\n\r\n    {\r\n\r\n        this.min_reduction = min_reduction;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the maximal growth factor for stepsize control.\r\n\r\n     * @return maximal growth factor\r\n\r\n     */\r\n\r\n    public double get_max_growth() \r\n\r\n    {\r\n\r\n        return max_growth;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the maximal growth factor for stepsize control.\r\n\r\n     * @param max_growth maximal growth factor\r\n\r\n     */\r\n\r\n    public void set_max_growth(const double max_growth) \r\n\r\n    {\r\n\r\n        this.max_growth = max_growth;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the safety factor for stepsize control.\r\n\r\n     * @return safety factor\r\n\r\n     */\r\n\r\n    public double get_safety() \r\n\r\n    {\r\n\r\n      return safety;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the safety factor for stepsize control.\r\n\r\n     * @param safety safety factor\r\n\r\n     */\r\n\r\n    public void set_safety(const double safety) \r\n\r\n    {\r\n\r\n      this.safety = safety;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the number of steps of the multistep method (excluding the one being computed).\r\n\r\n     * @return number of steps of the multistep method (excluding the one being computed)\r\n\r\n     */\r\n\r\n    public int get_n_steps() \r\n\r\n    {\r\n\r\n      return n_steps;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Rescale the instance.\r\n\r\n     * <p>sin_ce the scaled and Nordsieck arrays are shared with the caller, * this method has the side effect of rescaling this arrays in the caller too.</p>\r\n\r\n     * @param new_step_size step size to use in the scaled and Nordsieck arrays\r\n\r\n     */\r\n\r\n    protected void rescale(const T new_step_size) \r\n\r\n    {\r\n\r\n\r\n\r\n        const T ratio = new_step_size.divide(get_step_size());\r\n\r\n        for (int i{}; i < scaled.size(); ++i) \r\n\r\n        {\r\n\r\n            scaled[i] = scaled[i].multiply(ratio);\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<std::vector<T>> n_data = nordsieck.get_data_ref();\r\n\r\n        T power = ratio;\r\n\r\n        for (int i{}; i < n_data.size(); ++i) \r\n\r\n        {\r\n\r\n            power = power.multiply(ratio);\r\n\r\n            const std::vector<T> n_data_i = n_data[i];\r\n\r\n            for (int j{}; j < n_data_i.size(); ++j) \r\n\r\n            {\r\n\r\n                n_data_i[j] = n_data_i[j].multiply(power);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        set_step_size(new_step_size);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute step grow/shrink factor according to normalized error.\r\n\r\n     * @param error normalized error of the current step\r\n\r\n     * @return grow/shrink factor for next step\r\n\r\n     */\r\n\r\n    protected double compute_step_grow_shrink_factor(const double error) \r\n\r\n    {\r\n\r\n        return std::min(max_growth, std::max(min_reduction, safety * std::pow(error, exp)));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Specialized step handler storing the first step.\r\n\r\n     */\r\n\r\n    private class Field_Nordsieck_Initializer : FieldODE_Step_Handler<T> \r\n\r\n    {\r\n\r\n\r\n\r\n        /** Steps counter. */\r\n\r\n        private int count;\r\n\r\n\r\n\r\n        /** Saved start. */\r\n\r\n        private Field_ODE_State_And_Derivative<T> saved_start;\r\n\r\n\r\n\r\n        /** First steps times. */\r\n\r\n        private const std::vector<T> t;\r\n\r\n\r\n\r\n        /** First steps states. */\r\n\r\n        private const std::vector<std::vector<T>> y;\r\n\r\n\r\n\r\n        /** First steps derivatives. */\r\n\r\n        private const std::vector<std::vector<T>> y_dot;\r\n\r\n\r\n\r\n        /** Simple constructor.\r\n\r\n         * @param nb_start_points number of start points (including the initial point)\r\n\r\n         */\r\n\r\n        Field_Nordsieck_Initializer(const int& nb_start_points) \r\n\r\n        {\r\n\r\n            this.count  = 0;\r\n\r\n            this.t      = Math_Arrays::build_array(get_field(), nb_start_points);\r\n\r\n            this.y      = Math_Arrays::build_array(get_field(), nb_start_points, -1);\r\n\r\n            this.y_dot   = Math_Arrays::build_array(get_field(), nb_start_points, -1);\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void handle_step(FieldODE_StateInterpolator<T> interpolator) \r\n\r\n        {\r\n\r\n\r\n\r\n\r\n\r\n            if (count == 0) \r\n\r\n            {\r\n\r\n                // first step, we need to store also the point at the beginning of the step\r\n\r\n                const Field_ODE_State_And_Derivative<T> prev = interpolator.get_previous_state();\r\n\r\n                saved_start  = prev;\r\n\r\n                t[count]    = prev.get_time();\r\n\r\n                y[count]    = prev.get_complete_state();\r\n\r\n                y_dot[count] = prev.get_complete_derivative();\r\n\r\n            }\r\n\r\n\r\n\r\n            // store the point at the end of the step\r\n\r\n            ++count;\r\n\r\n            const Field_ODE_State_And_Derivative<T> curr = interpolator.get_current_state();\r\n\r\n            t[count]    = curr.get_time();\r\n\r\n            y[count]    = curr.get_complete_state();\r\n\r\n            y_dot[count] = curr.get_complete_derivative();\r\n\r\n\r\n\r\n            if (count == t.size() - 1) \r\n\r\n            {\r\n\r\n\r\n\r\n                // this was the last point we needed, we can compute the derivatives\r\n\r\n                set_step_start(saved_start);\r\n\r\n                const T raw_step = t[t.size() - 1].subtract(t[0]).divide(t.size() - 1);\r\n\r\n                set_step_size(get_step_size_helper().filter_step(raw_step, raw_step.get_real() >= 0, true));\r\n\r\n\r\n\r\n                // first scaled derivative\r\n\r\n                scaled = Math_Arrays::build_array(get_field(), y_dot[0].size());\r\n\r\n                for (int j{}; j < scaled.size(); ++j) \r\n\r\n                {\r\n\r\n                    scaled[j] = y_dot[0][j].multiply(get_step_size());\r\n\r\n                }\r\n\r\n\r\n\r\n                // higher order derivatives\r\n\r\n                nordsieck = initialize_high_order_derivatives(get_step_size(), t, y, y_dot);\r\n\r\n\r\n\r\n                // stop the integrator now that all needed steps have been handled\r\n\r\n                throw Initialization_completedMarkerException();\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        /** {@inherit_doc} */\r\n\r\n        //override\r\n\r\n        public void init(const Field_ODE_State_And_Derivative<T> initial_state, T const_time) \r\n\r\n        {\r\n\r\n            // nothing to do\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Marker exception used ONLY to stop the starter integrator after first step. */\r\n\r\n    private static class Initialization_completedMarkerException\r\n\r\n        extends Runtime_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        /** Serializable version identifier. */\r\n\r\n        private static const long serial_version_uid = -1914085471038046418L;\r\n\r\n\r\n\r\n        /** Simple constructor. */\r\n\r\n        Initialization_completedMarkerException() \r\n\r\n        {\r\n\r\n            super((Throwable) null);\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n