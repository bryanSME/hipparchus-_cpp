/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.ode.Abstract_Field_Integrator;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.FieldExpandable_ODE;\r\n\r\n//import org.hipparchus.ode.FieldODE_State;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.ode.FieldOrdinary_Differential_Equation;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the common part of all fixed step Runge-Kutta\r\n\r\n * integrators for Ordinary Differential Equations.\r\n\r\n *\r\n\r\n * <p>These methods are explicit Runge-Kutta methods, their Butcher\r\n\r\n * arrays are as follows :\r\n\r\n * <pre>\r\n\r\n *    0  |\r\n\r\n *   c2  | a21\r\n\r\n *   c3  | a31  a32\r\n\r\n *   ... |        ...\r\n\r\n *   cs  | as1  as2  ...  ass-1\r\n\r\n *       |--------------------------\r\n\r\n *       |  b1   b2  ...   bs-1  bs\r\n\r\n * </pre>\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * @see Euler_fieldIntegrator\r\n\r\n * @see ClassicalRunge_Kutta_Field_Integrator\r\n\r\n * @see Gill_Field_Integrator\r\n\r\n * @see Midpoint_Field_Integrator\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\npublic virtual class Runge_Kutta_Field_Integrator\r\n\r\n    extends Abstract_Field_Integrator<T>\r\n\r\n    : FieldButcher_Array_Provider<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Time steps from Butcher array (without the first zero). */\r\n\r\n    private const std::vector<T> c;\r\n\r\n\r\n\r\n    /** Internal weights from Butcher array (without the first empty row). */\r\n\r\n    private const std::vector<std::vector<T>> a;\r\n\r\n\r\n\r\n    /** External weights for the high order method from Butcher array. */\r\n\r\n    private const std::vector<T> b;\r\n\r\n\r\n\r\n    /** Integration step. */\r\n\r\n    private const T step;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a Runge-Kutta integrator with the given\r\n\r\n     * step. The default step handler does nothing.\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param name name of the method\r\n\r\n     * @param step integration step\r\n\r\n     */\r\n\r\n    protected Runge_Kutta_Field_Integrator(const Field<T> field, const std::string name, const T step) \r\n\r\n    {\r\n\r\n        super(field, name);\r\n\r\n        this.c    = get_c();\r\n\r\n        this.a    = get_a();\r\n\r\n        this.b    = get_b();\r\n\r\n        this.step = step.abs();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create a fraction.\r\n\r\n     * @param p numerator\r\n\r\n     * @param q denominator\r\n\r\n     * @return p/q computed in the instance field\r\n\r\n     */\r\n\r\n    protected T fraction(const int p, const int q) \r\n\r\n    {\r\n\r\n        return get_field().get_zero().add(p).divide(q);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create an interpolator.\r\n\r\n     * @param forward integration direction indicator\r\n\r\n     * @param y_dot_k slopes at the intermediate points\r\n\r\n     * @param global_previous_state start of the global step\r\n\r\n     * @param global_current_state end of the global step\r\n\r\n     * @param mapper equations mapper for the all equations\r\n\r\n     * @return external weights for the high order method from Butcher array\r\n\r\n     */\r\n\r\n    protected virtual Runge_Kutta_Field_State_Interpolator<T> create_interpolator(bool forward, std::vector<std::vector<T>> y_dot_k, Field_ODE_State_And_Derivative<T> global_previous_state, Field_ODE_State_And_Derivative<T> global_current_state, FieldEquations_mapper<T> mapper);\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public Field_ODE_State_And_Derivative<T> integrate(const FieldExpandable_ODE<T> equations, const FieldODE_State<T> initial_state, const T const_time)\r\n\r\n        , Math_Illegal_State_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        sanity_checks(initial_state, const_time);\r\n\r\n        set_step_start(init_integration(equations, initial_state, const_time));\r\n\r\n        const bool forward = const_time.subtract(initial_state.get_time()).get_real() > 0;\r\n\r\n\r\n\r\n        // create some internal working arrays\r\n\r\n        const int   stages = c.size() + 1;\r\n\r\n        const std::vector<std::vector<T>> y_dot_k  = Math_Arrays::build_array(get_field(), stages, -1);\r\n\r\n        const std::vector<T>   y_tmp   = Math_Arrays::build_array(get_field(), equations.get_mapper().get_total_dimension());\r\n\r\n\r\n\r\n        // set up integration control objects\r\n\r\n        if (forward) \r\n\r\n        {\r\n\r\n            if (get_step_start().get_time().add(step).subtract(const_time).get_real() >= 0) \r\n\r\n            {\r\n\r\n                set_step_size(const_time.subtract(get_step_start().get_time()));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                set_step_size(step);\r\n\r\n            }\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            if (get_step_start().get_time().subtract(step).subtract(const_time).get_real() <= 0) \r\n\r\n            {\r\n\r\n                set_step_size(const_time.subtract(get_step_start().get_time()));\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                set_step_size(step.negate());\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // main integration loop\r\n\r\n        set_is_last_step(false);\r\n\r\n        do \r\n\r\n        {\r\n\r\n\r\n\r\n            // first stage\r\n\r\n            const std::vector<T> y = get_step_start().get_complete_state();\r\n\r\n            y_dot_k[0]    = get_step_start().get_complete_derivative();\r\n\r\n\r\n\r\n            // next stages\r\n\r\n            for (int k{ 1 }; k < stages; ++k) \r\n\r\n            {\r\n\r\n\r\n\r\n                for (int j{}; j < y.size(); ++j) \r\n\r\n                {\r\n\r\n                    T sum = y_dot_k[0][j].multiply(a[k-1][0]);\r\n\r\n                    for (const int& l = 1; l < k; ++l) \r\n\r\n                    {\r\n\r\n                        sum = sum.add(y_dot_k[l][j].multiply(a[k-1][l]));\r\n\r\n                    }\r\n\r\n                    y_tmp[j] = y[j].add(get_step_size().multiply(sum));\r\n\r\n                }\r\n\r\n\r\n\r\n                y_dot_k[k] = compute_derivatives(get_step_start().get_time().add(get_step_size().multiply(c[k-1])), y_tmp);\r\n\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            // estimate the state at the end of the step\r\n\r\n            for (int j{}; j < y.size(); ++j) \r\n\r\n            {\r\n\r\n                T sum = y_dot_k[0][j].multiply(b[0]);\r\n\r\n                for (const int& l = 1; l < stages; ++l) \r\n\r\n                {\r\n\r\n                    sum = sum.add(y_dot_k[l][j].multiply(b[l]));\r\n\r\n                }\r\n\r\n                y_tmp[j] = y[j].add(get_step_size().multiply(sum));\r\n\r\n            }\r\n\r\n            const T step_end   = get_step_start().get_time().add(get_step_size());\r\n\r\n            const std::vector<T> y_dot_tmp = compute_derivatives(step_end, y_tmp);\r\n\r\n            const Field_ODE_State_And_Derivative<T> state_tmp = equations.get_mapper().map_state_and_derivative(step_end, y_tmp, y_dot_tmp);\r\n\r\n\r\n\r\n            // discrete events handling\r\n\r\n            set_step_start(accept_step(create_interpolator(forward, y_dot_k, get_step_start(), state_tmp, equations.get_mapper()), const_time));\r\n\r\n\r\n\r\n            if (!is_last_step()) \r\n\r\n            {\r\n\r\n\r\n\r\n                // stepsize control for next step\r\n\r\n                const T  next_t      = get_step_start().get_time().add(get_step_size());\r\n\r\n                const bool next_is_last = forward ?\r\n\r\n                                           (next_t.subtract(const_time).get_real() >= 0) :\r\n\r\n                                           (next_t.subtract(const_time).get_real() <= 0);\r\n\r\n                if (next_is_last) \r\n\r\n                {\r\n\r\n                    set_step_size(const_time.subtract(get_step_start().get_time()));\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n\r\n        } while (!is_last_step());\r\n\r\n\r\n\r\n        const Field_ODE_State_And_Derivative<T> const_state = get_step_start();\r\n\r\n        set_step_start(null);\r\n\r\n        set_step_size(null);\r\n\r\n        return const_state;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Fast computation of a single step of ODE integration.\r\n\r\n     * <p>This method is intended for the limited use case of\r\n\r\n     * very fast computation of only one step without using any of the\r\n\r\n     * rich features of general integrators that may take some time\r\n\r\n     * to set up (i.e. no step handlers, no events handlers, no additional\r\n\r\n     * states, no interpolators, no error control, no evaluations count, * no sanity checks ...). It handles the strict minimum of computation, * so it can be embedded in outer loops.</p>\r\n\r\n     * <p>\r\n\r\n     * This method is <em>not</em> used at all by the {@link #integrate(FieldExpandable_ODE, * FieldODE_State, Calculus_Field_Element)} method. It also completely ignores the step set at\r\n\r\n     * construction time, and uses only a single step to go from {@code t0} to {@code t}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * As this method does not use any of the state-dependent features of the integrator, * it should be reasonably thread-safe <em>if and only if</em> the provided differential\r\n\r\n     * equations are themselves thread-safe.\r\n\r\n     * </p>\r\n\r\n     * @param equations differential equations to integrate\r\n\r\n     * @param t0 initial time\r\n\r\n     * @param y0 initial value of the state vector at t0\r\n\r\n     * @param t target time for the integration\r\n\r\n     * (can be set to a value smaller than {@code t0} for backward integration)\r\n\r\n     * @return state vector at {@code t}\r\n\r\n     */\r\n\r\n    public std::vector<T> single_step(const FieldOrdinary_Differential_Equation<T> equations, const T t0, const std::vector<T> y0, const T t) \r\n\r\n    {\r\n\r\n\r\n\r\n        // create some internal working arrays\r\n\r\n        const std::vector<T> y       = y0.clone();\r\n\r\n        const int stages  = c.size() + 1;\r\n\r\n        const std::vector<std::vector<T>> y_dot_k = Math_Arrays::build_array(get_field(), stages, -1);\r\n\r\n        const std::vector<T> y_tmp    = y0.clone();\r\n\r\n\r\n\r\n        // first stage\r\n\r\n        const T h = t.subtract(t0);\r\n\r\n        y_dot_k[0] = equations.compute_derivatives(t0, y);\r\n\r\n\r\n\r\n        // next stages\r\n\r\n        for (int k{ 1 }; k < stages; ++k) \r\n\r\n        {\r\n\r\n\r\n\r\n            for (int j{}; j < y0.size(); ++j) \r\n\r\n            {\r\n\r\n                T sum = y_dot_k[0][j].multiply(a[k-1][0]);\r\n\r\n                for (const int& l = 1; l < k; ++l) \r\n\r\n                {\r\n\r\n                    sum = sum.add(y_dot_k[l][j].multiply(a[k-1][l]));\r\n\r\n                }\r\n\r\n                y_tmp[j] = y[j].add(h.multiply(sum));\r\n\r\n            }\r\n\r\n\r\n\r\n            y_dot_k[k] = equations.compute_derivatives(t0.add(h.multiply(c[k-1])), y_tmp);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        // estimate the state at the end of the step\r\n\r\n        for (int j{}; j < y0.size(); ++j) \r\n\r\n        {\r\n\r\n            T sum = y_dot_k[0][j].multiply(b[0]);\r\n\r\n            for (const int& l = 1; l < stages; ++l) \r\n\r\n            {\r\n\r\n                sum = sum.add(y_dot_k[l][j].multiply(b[l]));\r\n\r\n            }\r\n\r\n            y[j] = y[j].add(h.multiply(sum));\r\n\r\n        }\r\n\r\n\r\n\r\n        return y;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n