/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n\r\n\r\n/**\r\n\r\n * This class represents an interpolator over the last step during an\r\n\r\n * ODE integration for the 6th order Luther integrator.\r\n\r\n *\r\n\r\n * <p>This interpolator computes dense output inside the last\r\n\r\n * step computed. The interpolation equation is consistent with the\r\n\r\n * integration scheme.</p>\r\n\r\n *\r\n\r\n * @see Luther_fieldIntegrator\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Luther_fieldStateInterpolator\r\n\r\n    extends Runge_Kutta_Field_State_Interpolator<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** -49 - 49 q. */\r\n\r\n    private const T c5a;\r\n\r\n\r\n\r\n    /** 392 + 287 q. */\r\n\r\n    private const T c5b;\r\n\r\n\r\n\r\n    /** -637 - 357 q. */\r\n\r\n    private const T c5c;\r\n\r\n\r\n\r\n    /** 833 + 343 q. */\r\n\r\n    private const T c5d;\r\n\r\n\r\n\r\n    /** -49 + 49 q. */\r\n\r\n    private const T c6a;\r\n\r\n\r\n\r\n    /** -392 - 287 q. */\r\n\r\n    private const T c6b;\r\n\r\n\r\n\r\n    /** -637 + 357 q. */\r\n\r\n    private const T c6c;\r\n\r\n\r\n\r\n    /** 833 - 343 q. */\r\n\r\n    private const T c6d;\r\n\r\n\r\n\r\n    /** 49 + 49 q. */\r\n\r\n    private const T d5a;\r\n\r\n\r\n\r\n    /** -1372 - 847 q. */\r\n\r\n    private const T d5b;\r\n\r\n\r\n\r\n    /** 2254 + 1029 q */\r\n\r\n    private const T d5c;\r\n\r\n\r\n\r\n    /** 49 - 49 q. */\r\n\r\n    private const T d6a;\r\n\r\n\r\n\r\n    /** -1372 + 847 q. */\r\n\r\n    private const T d6b;\r\n\r\n\r\n\r\n    /** 2254 - 1029 q */\r\n\r\n    private const T d6c;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param forward integration direction indicator\r\n\r\n     * @param y_dot_k slopes at the intermediate points\r\n\r\n     * @param global_previous_state start of the global step\r\n\r\n     * @param global_current_state end of the global step\r\n\r\n     * @param soft_previous_state start of the restricted step\r\n\r\n     * @param soft_current_state end of the restricted step\r\n\r\n     * @param mapper equations mapper for the all equations\r\n\r\n     */\r\n\r\n    Luther_fieldStateInterpolator(const Field<T> field, const bool forward, const std::vector<std::vector<T>> y_dot_k, const Field_ODE_State_And_Derivative<T> global_previous_state, const Field_ODE_State_And_Derivative<T> global_current_state, const Field_ODE_State_And_Derivative<T> soft_previous_state, const Field_ODE_State_And_Derivative<T> soft_current_state, const FieldEquations_mapper<T> mapper) \r\n\r\n    {\r\n\r\n        super(field, forward, y_dot_k, global_previous_state, global_current_state, soft_previous_state, soft_current_state, mapper);\r\n\r\n        const T q = field.get_zero().add(21).sqrt();\r\n\r\n        c5a = q.multiply(  -49).add(  -49);\r\n\r\n        c5b = q.multiply(  287).add(  392);\r\n\r\n        c5c = q.multiply( -357).add( -637);\r\n\r\n        c5d = q.multiply(  343).add(  833);\r\n\r\n        c6a = q.multiply(   49).add(  -49);\r\n\r\n        c6b = q.multiply( -287).add(  392);\r\n\r\n        c6c = q.multiply(  357).add( -637);\r\n\r\n        c6d = q.multiply( -343).add(  833);\r\n\r\n        d5a = q.multiply(   49).add(   49);\r\n\r\n        d5b = q.multiply( -847).add(-1372);\r\n\r\n        d5c = q.multiply( 1029).add( 2254);\r\n\r\n        d6a = q.multiply(  -49).add(   49);\r\n\r\n        d6b = q.multiply(  847).add(-1372);\r\n\r\n        d6c = q.multiply(-1029).add( 2254);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Luther_fieldStateInterpolator<T> create(const Field<T> new_field, const bool new_forward, const std::vector<std::vector<T>> new_y_dot_k, const Field_ODE_State_And_Derivative<T> new_global_previous_state, const Field_ODE_State_And_Derivative<T> new_global_current_state, const Field_ODE_State_And_Derivative<T> new_soft_previous_state, const Field_ODE_State_And_Derivative<T> new_soft_current_state, const FieldEquations_mapper<T> new_mapper) \r\n\r\n    {\r\n\r\n        return Luther_fieldStateInterpolator<T>(new_field, new_forward, new_y_dot_k, new_global_previous_state, new_global_current_state, new_soft_previous_state, new_soft_current_state, new_mapper);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //@Suppress_Warnings("unchecked")\r\n\r\n    //override\r\n\r\n    protected Field_ODE_State_And_Derivative<T> compute_interpolated_state_and_derivatives(const FieldEquations_mapper<T> mapper, const T time, const T theta, const T theta_h, const T one_minus_theta_h) \r\n\r\n    {\r\n\r\n\r\n\r\n        // the coefficients below have been computed by solving the\r\n\r\n        // order conditions from a theorem from Butcher (1963), using\r\n\r\n        // the method explained in Folkmar Bornemann paper "Runge-Kutta\r\n\r\n        // Methods, Trees, and Maple", Center of Mathematical Sciences, Munich\r\n\r\n        // University of Technology, February 9, 2001\r\n\r\n        //<http://wwwzenger.informatik.tu-muenchen.de/selcuk/sjam012101.html>\r\n\r\n\r\n\r\n        // the method is implemented in the rkcheck tool\r\n\r\n        // <https://www.spaceroots.org/software/rkcheck/index.html>.\r\n\r\n        // Running it for order 5 gives the following order conditions\r\n\r\n        // for an interpolator:\r\n\r\n        // order 1 conditions\r\n\r\n        // \\sum_{i=1}^{i=s}\\left(b_{i} \r\n\r\night) =1\r\n\r\n        // order 2 conditions\r\n\r\n        // \\sum_{i=1}^{i=s}\\left(b_{i} c_{i}\r\n\r\night) = \x0crac{\theta}{2}\r\n\r\n        // order 3 conditions\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} \\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{2}}{6}\r\n\r\n        // \\sum_{i=1}^{i=s}\\left(b_{i} c_{i}^{2}\r\n\r\night) = \x0crac{\theta^{2}}{3}\r\n\r\n        // order 4 conditions\r\n\r\n        // \\sum_{i=3}^{i=s}\\left(b_{i} \\sum_{j=2}^{j=i-1}{\\left(a_{i,j} \\sum_{k=1}^{k=j-1}{\\left(a_{j,k} c_{k} \r\n\r\night)} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{3}}{24}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} \\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j}^{2} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{3}}{12}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} c_{i}\\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{3}}{8}\r\n\r\n        // \\sum_{i=1}^{i=s}\\left(b_{i} c_{i}^{3}\r\n\r\night) = \x0crac{\theta^{3}}{4}\r\n\r\n        // order 5 conditions\r\n\r\n        // \\sum_{i=4}^{i=s}\\left(b_{i} \\sum_{j=3}^{j=i-1}{\\left(a_{i,j} \\sum_{k=2}^{k=j-1}{\\left(a_{j,k} \\sum_{l=1}^{l=k-1}{\\left(a_{k,l} c_{l} \r\n\r\night)} \r\n\r\night)} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{120}\r\n\r\n        // \\sum_{i=3}^{i=s}\\left(b_{i} \\sum_{j=2}^{j=i-1}{\\left(a_{i,j} \\sum_{k=1}^{k=j-1}{\\left(a_{j,k} c_{k}^{2} \r\n\r\night)} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{60}\r\n\r\n        // \\sum_{i=3}^{i=s}\\left(b_{i} \\sum_{j=2}^{j=i-1}{\\left(a_{i,j} c_{j}\\sum_{k=1}^{k=j-1}{\\left(a_{j,k} c_{k} \r\n\r\night)} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{40}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} \\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j}^{3} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{20}\r\n\r\n        // \\sum_{i=3}^{i=s}\\left(b_{i} c_{i}\\sum_{j=2}^{j=i-1}{\\left(a_{i,j} \\sum_{k=1}^{k=j-1}{\\left(a_{j,k} c_{k} \r\n\r\night)} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{30}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} c_{i}\\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j}^{2} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{15}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} \\left(\\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j} \r\n\r\night)} \r\n\r\night)^{2}\r\n\r\night) = \x0crac{\theta^{4}}{20}\r\n\r\n        // \\sum_{i=2}^{i=s}\\left(b_{i} c_{i}^{2}\\sum_{j=1}^{j=i-1}{\\left(a_{i,j} c_{j} \r\n\r\night)}\r\n\r\night) = \x0crac{\theta^{4}}{10}\r\n\r\n        // \\sum_{i=1}^{i=s}\\left(b_{i} c_{i}^{4}\r\n\r\night) = \x0crac{\theta^{4}}{5}\r\n\r\n\r\n\r\n        // The a_{j,k} and c_{k} are given by the integrator Butcher arrays. What remains to solve\r\n\r\n        // are the b_i for the interpolator. They are found by solving the above equations.\r\n\r\n        // For a given interpolator, some equations are redundant, so in our case when we select\r\n\r\n        // all equations from order 1 to 4, we still don't have enough independent equations\r\n\r\n        // to solve from b_1 to b_7. We need to also select one equation from order 5. Here, // we selected the last equation. It appears this choice implied at least the last 3 equations\r\n\r\n        // are fulfilled, but some of the former ones are not, so the resulting interpolator is order 5.\r\n\r\n        // At the end, we get the b_i as polynomials in theta.\r\n\r\n\r\n\r\n        const T coeff_dot_1 =  theta.multiply(theta.multiply(theta.multiply(theta.multiply(   21        ).add( -47          )).add(   36         )).add( -54     /   5.0)).add(1);\r\n\r\n        const T coeff_dot_2 =  time.get_field().get_zero();\r\n\r\n        const T coeff_dot_3 =  theta.multiply(theta.multiply(theta.multiply(theta.multiply(  112        ).add(-608    /  3.0)).add(  320   / 3.0 )).add(-208    /  15.0));\r\n\r\n        const T coeff_dot_4 =  theta.multiply(theta.multiply(theta.multiply(theta.multiply( -567  /  5.0).add( 972    /  5.0)).add( -486   / 5.0 )).add( 324    /  25.0));\r\n\r\n        const T coeff_dot5 =  theta.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(5)).add(c5b.divide(15))).add(c5c.divide(30))).add(c5d.divide(150)));\r\n\r\n        const T coeff_dot6 =  theta.multiply(theta.multiply(theta.multiply(theta.multiply(c6a.divide(5)).add(c6b.divide(15))).add(c6c.divide(30))).add(c6d.divide(150)));\r\n\r\n        const T coeff_dot7 =  theta.multiply(theta.multiply(theta.multiply(                                             3.0 ).add(   -3         )).add(   3   /   5.0));\r\n\r\n        const std::vector<T> interpolated_state;\r\n\r\n        const std::vector<T> interpolated_derivatives;\r\n\r\n\r\n\r\n        if (get_global_previous_state() != null && theta.get_real() <= 0.5) \r\n\r\n        {\r\n\r\n\r\n\r\n            const T s         = theta_h;\r\n\r\n            const T coeff1    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(  21    /  5.0).add( -47    /  4.0)).add(   12         )).add( -27    /   5.0)).add(1));\r\n\r\n            const T coeff2    = time.get_field().get_zero();\r\n\r\n            const T coeff3    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply( 112    /  5.0).add(-152    /  3.0)).add(  320   / 9.0 )).add(-104    /  15.0)));\r\n\r\n            const T coeff4    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-567    / 25.0).add( 243    /  5.0)).add( -162   / 5.0 )).add( 162    /  25.0)));\r\n\r\n            const T coeff5    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(25)).add(c5b.divide(60))).add(c5c.divide(90))).add(c5d.divide(300))));\r\n\r\n            const T coeff6    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(c6a.divide(25)).add(c6b.divide(60))).add(c6c.divide(90))).add(c6d.divide(300))));\r\n\r\n            const T coeff7    = s.multiply(theta.multiply(theta.multiply(theta.multiply(                                      3    /  4.0 ).add(   -1         )).add(   3    /  10.0)));\r\n\r\n            interpolated_state       = previous_state_linear_combination(coeff1, coeff2, coeff3, coeff4, coeff5, coeff6, coeff7);\r\n\r\n            interpolated_derivatives = derivative_linear_combination(coeff_dot_1, coeff_dot_2, coeff_dot_3, coeff_dot_4, coeff_dot5, coeff_dot6, coeff_dot7);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n\r\n\r\n            const T s         = one_minus_theta_h;\r\n\r\n            const T coeff1    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply( -21   /   5.0).add(   151  /  20.0)).add( -89   /   20.0)).add(  19 /  20.0)).add(- 1 / 20.0));\r\n\r\n            const T coeff2    = time.get_field().get_zero();\r\n\r\n            const T coeff3    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-112   /   5.0).add(   424  /  15.0)).add( -328  /   45.0)).add( -16 /  45.0)).add(-16 /  45.0));\r\n\r\n            const T coeff4    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply( 567   /  25.0).add(  -648  /  25.0)).add(  162  /   25.0))));\r\n\r\n            const T coeff5    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(d5a.divide(25)).add(d5b.divide(300))).add(d5c.divide(900))).add( -49 / 180.0)).add(-49 / 180.0));\r\n\r\n            const T coeff6    = s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(d6a.divide(25)).add(d6b.divide(300))).add(d6c.divide(900))).add( -49 / 180.0)).add(-49 / 180.0));\r\n\r\n            const T coeff7    = s.multiply(               theta.multiply(theta.multiply(theta.multiply(                        -3  /   4.0 ).add(   1   /    4.0)).add(  -1 /  20.0)).add( -1 /  20.0));\r\n\r\n            interpolated_state       = current_state_linear_combination(coeff1, coeff2, coeff3, coeff4, coeff5, coeff6, coeff7);\r\n\r\n            interpolated_derivatives = derivative_linear_combination(coeff_dot_1, coeff_dot_2, coeff_dot_3, coeff_dot_4, coeff_dot5, coeff_dot6, coeff_dot7);\r\n\r\n        }\r\n\r\n\r\n\r\n        return mapper.map_state_and_derivative(time, interpolated_state, interpolated_derivatives);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n