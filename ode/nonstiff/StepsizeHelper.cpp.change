/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.ode.Localized_ODE_Formats;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n/** Helper for adaptive stepsize control.\r\n\r\n * @since 2.0\r\n\r\n */\r\n\r\n\r\n\r\nclass Stepsize_Helper \r\n\r\n{\r\n\r\n\r\n\r\n    /** Allowed absolute scalar error. */\r\n\r\n    private double scal_absolute_tolerance;\r\n\r\n\r\n\r\n    /** Allowed relative scalar error. */\r\n\r\n    private double scal_relative_tolerance;\r\n\r\n\r\n\r\n    /** Allowed absolute vectorial error. */\r\n\r\n    private std::vector<double> vec_absolute_tolerance;\r\n\r\n\r\n\r\n    /** Allowed relative vectorial error. */\r\n\r\n    private std::vector<double> vec_relative_tolerance;\r\n\r\n\r\n\r\n    /** Main set dimension. */\r\n\r\n    private int main_set_dimension;\r\n\r\n\r\n\r\n    /** User supplied initial step. */\r\n\r\n    private double initial_step;\r\n\r\n\r\n\r\n    /** Minimal step. */\r\n\r\n    private double min_step;\r\n\r\n\r\n\r\n    /** Maximal step. */\r\n\r\n    private double max_step;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param scal_absolute_tolerance allowed absolute error\r\n\r\n     * @param scal_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Stepsize_Helper(const double min_step, const double max_step, const double scal_absolute_tolerance, const double scal_relative_tolerance) \r\n\r\n    {\r\n\r\n        this.min_step     = std::abs(min_step);\r\n\r\n        this.max_step     = std::abs(max_step);\r\n\r\n        this.initial_step = -1;\r\n\r\n\r\n\r\n        this.scal_absolute_tolerance = scal_absolute_tolerance;\r\n\r\n        this.scal_relative_tolerance = scal_relative_tolerance;\r\n\r\n        this.vec_absolute_tolerance  = null;\r\n\r\n        this.vec_relative_tolerance  = null;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor..\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param vec_absolute_tolerance allowed absolute error\r\n\r\n     * @param vec_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Stepsize_Helper(const double min_step, const double max_step, const std::vector<double>& vec_absolute_tolerance, const std::vector<double>& vec_relative_tolerance) \r\n\r\n    {\r\n\r\n\r\n\r\n        this.min_step     = std::abs(min_step);\r\n\r\n        this.max_step     = std::abs(max_step);\r\n\r\n        this.initial_step = -1;\r\n\r\n\r\n\r\n       this.scal_absolute_tolerance = 0;\r\n\r\n       this.scal_relative_tolerance = 0;\r\n\r\n       this.vec_absolute_tolerance  = vec_absolute_tolerance.clone();\r\n\r\n       this.vec_relative_tolerance  = vec_relative_tolerance.clone();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set main set dimension.\r\n\r\n     * @param main_set_dimension dimension of the main set\r\n\r\n     * @exception  if adaptive step size integrators\r\n\r\n     * tolerance arrays dimensions are not compatible with equations settings\r\n\r\n     */\r\n\r\n    protected void set_main_set_dimension(const int main_set_dimension)  \r\n\r\n    {\r\n\r\n        this.main_set_dimension = main_set_dimension;\r\n\r\n\r\n\r\n        if (vec_absolute_tolerance != null && vec_absolute_tolerance.size() != main_set_dimension) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, main_set_dimension, vec_absolute_tolerance.size());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (vec_relative_tolerance != null && vec_relative_tolerance.size() != main_set_dimension) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, main_set_dimension, vec_relative_tolerance.size());\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the main set dimension.\r\n\r\n     * @return main set dimension\r\n\r\n     */\r\n\r\n    public int get_main_set_dimension() \r\n\r\n    {\r\n\r\n        return main_set_dimension;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the relative tolerance for one component.\r\n\r\n     * @param i component to select\r\n\r\n     * @return relative tolerance for selected component\r\n\r\n     */\r\n\r\n    public double get_relative_tolerance(const int& i) \r\n\r\n    {\r\n\r\n        return vec_absolute_tolerance == null ? scal_relative_tolerance : vec_relative_tolerance[i];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the tolerance for one component.\r\n\r\n     * @param i component to select\r\n\r\n     * @param scale scale factor for relative tolerance (i.e. y[i])\r\n\r\n     * @return tolerance for selected component\r\n\r\n     */\r\n\r\n    public double get_tolerance(const int i, const double scale) \r\n\r\n    {\r\n\r\n        return vec_absolute_tolerance == null ?\r\n\r\n               scal_absolute_tolerance   + scal_relative_tolerance   * scale :\r\n\r\n               vec_absolute_tolerance[i] + vec_relative_tolerance[i] * scale;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the tolerance for one component.\r\n\r\n     * @param i component to select\r\n\r\n     * @param scale scale factor for relative tolerance (i.e. y[i])\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return tolerance for selected component\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public  T get_tolerance(const int i, const T scale) \r\n\r\n    {\r\n\r\n        return vec_absolute_tolerance == null ?\r\n\r\n               scale.multiply(scal_relative_tolerance).add(scal_absolute_tolerance) :\r\n\r\n               scale.multiply(vec_relative_tolerance[i]).add(vec_absolute_tolerance[i]);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Filter the integration step.\r\n\r\n     * @param h signed step\r\n\r\n     * @param forward forward integration indicator\r\n\r\n     * @param accept_small if true, steps smaller than the minimal value\r\n\r\n     * are silently increased up to this value, if false such small\r\n\r\n     * steps generate an exception\r\n\r\n     * @return a bounded integration step (h if no bound is reach, or a bounded value)\r\n\r\n     * @exception  if the step is too small and accept_small is false\r\n\r\n     */\r\n\r\n    public double filter_step(const double h, const bool forward, const bool accept_small)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        double filtered_h = h;\r\n\r\n        if (std::abs(h) < min_step) \r\n\r\n        {\r\n\r\n            if (accept_small) \r\n\r\n            {\r\n\r\n                filtered_h = forward ? min_step : -min_step;\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                throw (Localized_ODE_Formats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, std::abs(h), min_step, true);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        if (filtered_h > max_step) \r\n\r\n        {\r\n\r\n            filtered_h = max_step;\r\n\r\n        }\r\n\r\nelse if (filtered_h < -max_step) \r\n\r\n        {\r\n\r\n            filtered_h = -max_step;\r\n\r\n        }\r\n\r\n\r\n\r\n        return filtered_h;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Filter the integration step.\r\n\r\n     * @param h signed step\r\n\r\n     * @param forward forward integration indicator\r\n\r\n     * @param accept_small if true, steps smaller than the minimal value\r\n\r\n     * are silently increased up to this value, if false such small\r\n\r\n     * steps generate an exception\r\n\r\n     * @param <T> type of the field elements\r\n\r\n     * @return a bounded integration step (h if no bound is reach, or a bounded value)\r\n\r\n     * @exception  if the step is too small and accept_small is false\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    public  T filter_step(const T h, const bool forward, const bool accept_small)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        T filtered_h = h;\r\n\r\n        if (h.abs().subtract(min_step).get_real() < 0) \r\n\r\n        {\r\n\r\n            if (accept_small) \r\n\r\n            {\r\n\r\n                filtered_h = h.get_field().get_zero().add(forward ? min_step : -min_step);\r\n\r\n            }\r\n\r\nelse \r\n\r\n            {\r\n\r\n                throw (Localized_ODE_Formats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, std::abs(h.get_real()), min_step, true);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        if (filtered_h.subtract(max_step).get_real() > 0) \r\n\r\n        {\r\n\r\n            filtered_h = h.get_field().get_zero().add(max_step);\r\n\r\n        }\r\n\r\nelse if (filtered_h.add(max_step).get_real() < 0) \r\n\r\n        {\r\n\r\n            filtered_h = h.get_field().get_zero().add(-max_step);\r\n\r\n        }\r\n\r\n\r\n\r\n        return filtered_h;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Set the initial step size.\r\n\r\n     * <p>This method allows the user to specify an initial positive\r\n\r\n     * step size instead of letting the integrator guess it by\r\n\r\n     * itself. If this method is not called before integration is\r\n\r\n     * started, the initial step size will be estimated by the\r\n\r\n     * integrator.</p>\r\n\r\n     * @param initial_step_size initial step size to use (must be positive even\r\n\r\n     * for backward integration ; providing a negative value or a value\r\n\r\n     * outside of the min/max step interval will lead the integrator to\r\n\r\n     * ignore the value and compute the initial step size by itself)\r\n\r\n     */\r\n\r\n    public void set_initial_step_size(const double initial_step_size) \r\n\r\n    {\r\n\r\n        if ((initial_step_size < min_step) || (initial_step_size > max_step)) \r\n\r\n        {\r\n\r\n            initial_step = -1.0;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            initial_step = initial_step_size;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the initial step.\r\n\r\n     * @return initial step\r\n\r\n     */\r\n\r\n    public double get_initial_step() \r\n\r\n    {\r\n\r\n        return initial_step;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the minimal step.\r\n\r\n     * @return minimal step\r\n\r\n     */\r\n\r\n    public double get_min_step() \r\n\r\n    {\r\n\r\n        return min_step;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the maximal step.\r\n\r\n     * @return maximal step\r\n\r\n     */\r\n\r\n    public double get_max_step() \r\n\r\n    {\r\n\r\n        return max_step;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a dummy step size.\r\n\r\n     * @return geometric mean of {@link #get_min_step()} and {@link #get_max_step()}\r\n\r\n     */\r\n\r\n    public double get_dummy_stepsize() \r\n\r\n    {\r\n\r\n        return std::sqrt(min_step * max_step);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n