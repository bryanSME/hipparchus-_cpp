/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the 5(4) Dormand-Prince integrator for Ordinary\r\n\r\n * Differential Equations.\r\n\r\n\r\n\r\n * <p>This integrator is an embedded Runge-Kutta integrator\r\n\r\n * of order 5(4) used in local extrapolation mode (i.e. the solution\r\n\r\n * is computed using the high order formula) with stepsize control\r\n\r\n * (and automatic step initialization) and continuous output. This\r\n\r\n * method uses 7 functions evaluations per step. However, since this\r\n\r\n * is an <i>fsal</i>, the last evaluation of one step is the same as\r\n\r\n * the first evaluation of the next step and hence can be avoided. So\r\n\r\n * the cost is really 6 functions evaluations per step.</p>\r\n\r\n *\r\n\r\n * <p>This method has been published (whithout the continuous output\r\n\r\n * that was added by Shampine in 1986) in the following article :\r\n\r\n * <pre>\r\n\r\n *  A family of embedded Runge-Kutta formulae\r\n\r\n *  J. R. Dormand and P. J. Prince\r\n\r\n *  Journal of Computational and Applied Mathematics\r\n\r\n *  volume 6, no 1, 1980, pp. 19-26\r\n\r\n * </pre></p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Dormand_Prince54_Field_Integrator\r\n\r\n    extends EmbeddedRunge_Kutta_Field_Integrator<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a fifth order Dormand-Prince integrator with the given step bounds\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param scal_absolute_tolerance allowed absolute error\r\n\r\n     * @param scal_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Dormand_Prince54_Field_Integrator(const Field<T> field, const double min_step, const double max_step, const double scal_absolute_tolerance, const double scal_relative_tolerance) \r\n\r\n    {\r\n\r\n        super(field, Dormand_Prince54_Integrator.METHOD_NAME, 6, min_step, max_step, scal_absolute_tolerance, scal_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a fifth order Dormand-Prince integrator with the given step bounds\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param vec_absolute_tolerance allowed absolute error\r\n\r\n     * @param vec_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Dormand_Prince54_Field_Integrator(const Field<T> field, const double min_step, const double max_step, const std::vector<double>& vec_absolute_tolerance, const std::vector<double>& vec_relative_tolerance) \r\n\r\n    {\r\n\r\n        super(field, Dormand_Prince54_Integrator.METHOD_NAME, 6, min_step, max_step, vec_absolute_tolerance, vec_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<T> get_c() \r\n\r\n    {\r\n\r\n        const std::vector<T> c = Math_Arrays::build_array(get_field(), 6);\r\n\r\n        c[0] = fraction(1,  5);\r\n\r\n        c[1] = fraction(3, 10);\r\n\r\n        c[2] = fraction(4,  5);\r\n\r\n        c[3] = fraction(8,  9);\r\n\r\n        c[4] = get_field().get_one();\r\n\r\n        c[5] = get_field().get_one();\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<std::vector<T>> get_a() \r\n\r\n    {\r\n\r\n        const std::vector<std::vector<T>> a = Math_Arrays::build_array(get_field(), 6, -1);\r\n\r\n        for (int i{}; i < a.size(); ++i) \r\n\r\n        {\r\n\r\n            a[i] = Math_Arrays::build_array(get_field(), i + 1);\r\n\r\n        }\r\n\r\n        a[0][0] = fraction(     1,     5);\r\n\r\n        a[1][0] = fraction(     3,    40);\r\n\r\n        a[1][1] = fraction(     9,    40);\r\n\r\n        a[2][0] = fraction(    44,    45);\r\n\r\n        a[2][1] = fraction(   -56,    15);\r\n\r\n        a[2][2] = fraction(    32,     9);\r\n\r\n        a[3][0] = fraction( 19372,  6561);\r\n\r\n        a[3][1] = fraction(-25360,  2187);\r\n\r\n        a[3][2] = fraction( 64448,  6561);\r\n\r\n        a[3][3] = fraction(  -212,   729);\r\n\r\n        a[4][0] = fraction(  9017,  3168);\r\n\r\n        a[4][1] = fraction(  -355,    33);\r\n\r\n        a[4][2] = fraction( 46732,  5247);\r\n\r\n        a[4][3] = fraction(    49,   176);\r\n\r\n        a[4][4] = fraction( -5103, 18656);\r\n\r\n        a[5][0] = fraction(    35,   384);\r\n\r\n        a[5][1] = get_field().get_zero();\r\n\r\n        a[5][2] = fraction(   500,  1113);\r\n\r\n        a[5][3] = fraction(   125,   192);\r\n\r\n        a[5][4] = fraction( -2187,  6784);\r\n\r\n        a[5][5] = fraction(    11,    84);\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<T> get_b() \r\n\r\n    {\r\n\r\n        const std::vector<T> b = Math_Arrays::build_array(get_field(), 7);\r\n\r\n        b[0] = fraction(   35,   384);\r\n\r\n        b[1] = get_field().get_zero();\r\n\r\n        b[2] = fraction(  500, 1113);\r\n\r\n        b[3] = fraction(  125,  192);\r\n\r\n        b[4] = fraction(-2187, 6784);\r\n\r\n        b[5] = fraction(   11,   84);\r\n\r\n        b[6] = get_field().get_zero();\r\n\r\n        return b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Dormand_Prince54_Field_State_Interpolator<T>\r\n\r\n        create_interpolator(const bool forward, std::vector<std::vector<T>> y_dot_k, const Field_ODE_State_And_Derivative<T> global_previous_state, const Field_ODE_State_And_Derivative<T> global_current_state, const FieldEquations_mapper<T> mapper) \r\n\r\n        {\r\n\r\n        return Dormand_Prince54_Field_State_Interpolator<T>(get_field(), forward, y_dot_k, global_previous_state, global_current_state, global_previous_state, global_current_state, mapper);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_order() \r\n\r\n    {\r\n\r\n        return 5;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected double estimate_error(const std::vector<std::vector<T>> y_dot_k, const std::vector<T> y0, const std::vector<T> y1, const T h) \r\n\r\n    {\r\n\r\n\r\n\r\n        const Stepsize_Helper helper = get_step_size_helper();\r\n\r\n        double error = 0;\r\n\r\n\r\n\r\n        for (int j{}; j < helper.get_main_set_dimension(); ++j) \r\n\r\n        {\r\n\r\n            const double err_sum = Dormand_Prince54_Integrator.E1 * y_dot_k[0][j].get_real() +  Dormand_Prince54_Integrator.E3 * y_dot_k[2][j].get_real() +\r\n\r\n                                  Dormand_Prince54_Integrator.E4 * y_dot_k[3][j].get_real() +  Dormand_Prince54_Integrator.E5 * y_dot_k[4][j].get_real() +\r\n\r\n                                  Dormand_Prince54_Integrator.E6 * y_dot_k[5][j].get_real() +  Dormand_Prince54_Integrator.E7 * y_dot_k[6][j].get_real();\r\n\r\n            const double tol = helper.get_tolerance(j, std::max(std::abs(y0[j].get_real()), std::abs(y1[j].get_real())));\r\n\r\n            const double ratio  = h.get_real() * err_sum / tol;\r\n\r\n            error += ratio * ratio;\r\n\r\n        }\r\n\r\n\r\n\r\n        return std::sqrt(error / helper.get_main_set_dimension());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n