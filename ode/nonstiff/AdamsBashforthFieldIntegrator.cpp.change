/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.linear.Array2DRowField_Matrix;\r\n\r\n//import org.hipparchus.linear.Field_Matrix;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : explicit Adams-Bashforth integrators for Ordinary\r\n\r\n * Differential Equations.\r\n\r\n *\r\n\r\n * <p>Adams-Bashforth methods (in fact due to Adams alone) are explicit\r\n\r\n * multistep ODE solvers. This implementation is a variation of the classical\r\n\r\n * one: it uses adaptive stepsize to implement error control, whereas\r\n\r\n * classical implementations are fixed step size. The value of state vector\r\n\r\n * at step n+1 is a simple combination of the value at step n and of the\r\n\r\n * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\r\n\r\n * steps one wants to use for computing the next value, different formulas\r\n\r\n * are available:</p>\r\n\r\n * <ul>\r\n\r\n *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n</sub></li>\r\n\r\n *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3y'<sub>n</sub>-y'<sub>n-1</sub>)/2</li>\r\n\r\n *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23y'<sub>n</sub>-16y'<sub>n-1</sub>+5y'<sub>n-2</sub>)/12</li>\r\n\r\n *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55y'<sub>n</sub>-59y'<sub>n-1</sub>+37y'<sub>n-2</sub>-9y'<sub>n-3</sub>)/24</li>\r\n\r\n *   <li>...</li>\r\n\r\n * </ul>\r\n\r\n *\r\n\r\n * <p>A k-steps Adams-Bashforth method is of order k.</p>\r\n\r\n *\r\n\r\n * <p> There must be sufficient time for the {@link #set_starter_integrator(org.hipparchus.ode.FieldODE_Integrator)\r\n\r\n * starter integrator} to take several steps between the the last reset event, and the end\r\n\r\n * of integration, otherwise an exception may be thrown during integration. The user can\r\n\r\n * adjust the end date of integration, or the step size of the starter integrator to\r\n\r\n * ensure a sufficient number of steps can be completed before the end of integration.\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * <h3>Implementation details</h3>\r\n\r\n *\r\n\r\n * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\r\n\r\n * <pre>\r\n\r\n * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\r\n\r\n * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\r\n\r\n * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\r\n\r\n * ...\r\n\r\n * s<sub>k</sub>(n) = h<sup>k</sup>/k! y<sup>(k)</sup><sub>n</sub> for k<sup>th</sup> derivative\r\n\r\n * </pre></p>\r\n\r\n *\r\n\r\n * <p>The definitions above use the classical representation with several previous first\r\n\r\n * derivatives. Lets define\r\n\r\n * <pre>\r\n\r\n *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\r\n\r\n * </pre>\r\n\r\n * (we omit the k index in the notation for clarity). With these definitions, * Adams-Bashforth methods can be written:\r\n\r\n * <ul>\r\n\r\n *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n)</li>\r\n\r\n *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 3/2 s<sub>1</sub>(n) + [ -1/2 ] q<sub>n</sub></li>\r\n\r\n *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 23/12 s<sub>1</sub>(n) + [ -16/12 5/12 ] q<sub>n</sub></li>\r\n\r\n *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 55/24 s<sub>1</sub>(n) + [ -59/24 37/24 -9/24 ] q<sub>n</sub></li>\r\n\r\n *   <li>...</li>\r\n\r\n * </ul></p>\r\n\r\n *\r\n\r\n * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>, * s<sub>1</sub>(n) and q<sub>n</sub>), our implementation uses the Nordsieck vector with\r\n\r\n * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)\r\n\r\n * and r<sub>n</sub>) where r<sub>n</sub> is defined as:\r\n\r\n * <pre>\r\n\r\n * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\r\n\r\n * </pre>\r\n\r\n * (here again we omit the k index in the notation for clarity)\r\n\r\n * </p>\r\n\r\n *\r\n\r\n * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\r\n\r\n * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\r\n\r\n * for degree k polynomials.\r\n\r\n * <pre>\r\n\r\n * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j&gt;0</sub> (j+1) (-i)<sup>j</sup> s<sub>j+1</sub>(n)\r\n\r\n * </pre>\r\n\r\n * The previous formula can be used with several values for i to compute the transform between\r\n\r\n * classical representation and Nordsieck vector. The transform between r<sub>n</sub>\r\n\r\n * and q<sub>n</sub> resulting from the Taylor series formulas above is:\r\n\r\n * <pre>\r\n\r\n * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\r\n\r\n * </pre>\r\n\r\n * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\r\n\r\n * with the (j+1) (-i)<sup>j</sup> terms with i being the row number starting from 1 and j being\r\n\r\n * the column number starting from 1:\r\n\r\n * <pre>\r\n\r\n *        [  -2   3   -4    5  ... ]\r\n\r\n *        [  -4  12  -32   80  ... ]\r\n\r\n *   P =  [  -6  27 -108  405  ... ]\r\n\r\n *        [  -8  48 -256 1280  ... ]\r\n\r\n *        [          ...           ]\r\n\r\n * </pre></p>\r\n\r\n *\r\n\r\n * <p>Using the Nordsieck vector has several advantages:\r\n\r\n * <ul>\r\n\r\n *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\r\n\r\n *   Taylor series formulas,</li>\r\n\r\n *   <li>it simplifies step changes that occur when discrete events that truncate\r\n\r\n *   the step are triggered,</li>\r\n\r\n *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\r\n\r\n * </ul></p>\r\n\r\n *\r\n\r\n * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\r\n\r\n * <ul>\r\n\r\n *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\r\n\r\n *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\r\n\r\n *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\r\n\r\n * </ul>\r\n\r\n * where A is a rows shifting matrix (the lower left part is an identity matrix):\r\n\r\n * <pre>\r\n\r\n *        [ 0 0   ...  0 0 | 0 ]\r\n\r\n *        [ ---------------+---]\r\n\r\n *        [ 1 0   ...  0 0 | 0 ]\r\n\r\n *    A = [ 0 1   ...  0 0 | 0 ]\r\n\r\n *        [       ...      | 0 ]\r\n\r\n *        [ 0 0   ...  1 0 | 0 ]\r\n\r\n *        [ 0 0   ...  0 1 | 0 ]\r\n\r\n * </pre></p>\r\n\r\n *\r\n\r\n * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state, * they only depend on k and therefore are precomputed once for all.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Adams_Bashforth_Field_Integrator extends Adams_Field_Integrator<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Integrator method name. */\r\n\r\n    private static const std::string METHOD_NAME = "Adams-Bashforth";\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build an Adams-Bashforth integrator with the given order and step control parameters.\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param n_steps number of steps of the method excluding the one being computed\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param scal_absolute_tolerance allowed absolute error\r\n\r\n     * @param scal_relative_tolerance allowed relative error\r\n\r\n     * @exception  if order is 1 or less\r\n\r\n     */\r\n\r\n    public Adams_Bashforth_Field_Integrator(const Field<T> field, const int& n_steps, const double min_step, const double max_step, const double scal_absolute_tolerance, const double scal_relative_tolerance)\r\n\r\n         \r\n\r\n        {\r\n\r\n        super(field, METHOD_NAME, n_steps, n_steps, min_step, max_step, scal_absolute_tolerance, scal_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Build an Adams-Bashforth integrator with the given order and step control parameters.\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param n_steps number of steps of the method excluding the one being computed\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param vec_absolute_tolerance allowed absolute error\r\n\r\n     * @param vec_relative_tolerance allowed relative error\r\n\r\n     * @exception Illegal_Argument_Exception if order is 1 or less\r\n\r\n     */\r\n\r\n    public Adams_Bashforth_Field_Integrator(const Field<T> field, const int& n_steps, const double min_step, const double max_step, const std::vector<double>& vec_absolute_tolerance, const std::vector<double>& vec_relative_tolerance)\r\n\r\n        Illegal_Argument_Exception \r\n\r\n        {\r\n\r\n        super(field, METHOD_NAME, n_steps, n_steps, min_step, max_step, vec_absolute_tolerance, vec_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected double error_estimation(const std::vector<T> previous_state, const T predicted_time, const std::vector<T> predicted_state, const std::vector<T> predicted_scaled, const Field_Matrix<T> predicted_nordsieck) \r\n\r\n    {\r\n\r\n\r\n\r\n        const Stepsize_Helper helper = get_step_size_helper();\r\n\r\n        double error = 0;\r\n\r\n        for (int i{}; i < helper.get_main_set_dimension(); ++i) \r\n\r\n        {\r\n\r\n            const double tol = helper.get_tolerance(i, std::abs(predicted_state[i].get_real()));\r\n\r\n\r\n\r\n            // apply Taylor formula from high order to low order, // for the sake of numerical accuracy\r\n\r\n            double variation = 0;\r\n\r\n            int sign = predicted_nordsieck.get_row_dimension() % 2 == 0 ? -1 : 1;\r\n\r\n            for (int k = predicted_nordsieck.get_row_dimension() - 1; k >= 0; --k) \r\n\r\n            {\r\n\r\n                variation += sign * predicted_nordsieck.get_entry(k, i).get_real();\r\n\r\n                sign       = -sign;\r\n\r\n            }\r\n\r\n            variation -= predicted_scaled[i].get_real();\r\n\r\n\r\n\r\n            const double ratio  = (predicted_state[i].get_real() - previous_state[i].get_real() + variation) / tol;\r\n\r\n            error              += ratio * ratio;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return std::sqrt(error / helper.get_main_set_dimension());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Adams_Field_State_Interpolator<T> constize_step(const T step_size, const std::vector<T> predicted_y, const std::vector<T> predicted_scaled, const Array2DRowField_Matrix<T> predicted_nordsieck, const bool is_forward, const Field_ODE_State_And_Derivative<T> global_previous_state, const Field_ODE_State_And_Derivative<T> global_current_state, const FieldEquations_mapper<T> equations_mapper) \r\n\r\n    {\r\n\r\n        return Adams_Field_State_Interpolator<>(get_step_size(), global_current_state, predicted_scaled, predicted_nordsieck, is_forward, get_step_start(), global_current_state, equations_mapper);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n