/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode.nonstiff;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.ode.FieldEquations_mapper;\r\n\r\n//import org.hipparchus.ode.Field_ODE_State_And_Derivative;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n\r\n * This class : the 5(4) Higham and Hall integrator for\r\n\r\n * Ordinary Differential Equations.\r\n\r\n *\r\n\r\n * <p>This integrator is an embedded Runge-Kutta integrator\r\n\r\n * of order 5(4) used in local extrapolation mode (i.e. the solution\r\n\r\n * is computed using the high order formula) with stepsize control\r\n\r\n * (and automatic step initialization) and continuous output. This\r\n\r\n * method uses 7 functions evaluations per step.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Higham_Hall54_Field_Integrator\r\n\r\n    extends EmbeddedRunge_Kutta_Field_Integrator<T> \r\n\r\n    {\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a fifth order Higham and Hall integrator with the given step bounds\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param scal_absolute_tolerance allowed absolute error\r\n\r\n     * @param scal_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Higham_Hall54_Field_Integrator(const Field<T> field, const double min_step, const double max_step, const double scal_absolute_tolerance, const double scal_relative_tolerance) \r\n\r\n    {\r\n\r\n        super(field, Higham_Hall54_Integrator.METHOD_NAME, -1, min_step, max_step, scal_absolute_tolerance, scal_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a fifth order Higham and Hall integrator with the given step bounds\r\n\r\n     * @param field field to which the time and state vector elements belong\r\n\r\n     * @param min_step minimal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param max_step maximal step (sign is irrelevant, regardless of\r\n\r\n     * integration direction, forward or backward), the last step can\r\n\r\n     * be smaller than this\r\n\r\n     * @param vec_absolute_tolerance allowed absolute error\r\n\r\n     * @param vec_relative_tolerance allowed relative error\r\n\r\n     */\r\n\r\n    public Higham_Hall54_Field_Integrator(const Field<T> field, const double min_step, const double max_step, const std::vector<double>& vec_absolute_tolerance, const std::vector<double>& vec_relative_tolerance) \r\n\r\n    {\r\n\r\n        super(field, Higham_Hall54_Integrator.METHOD_NAME, -1, min_step, max_step, vec_absolute_tolerance, vec_relative_tolerance);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<T> get_c() \r\n\r\n    {\r\n\r\n        const std::vector<T> c = Math_Arrays::build_array(get_field(), 6);\r\n\r\n        c[0] = fraction(2, 9);\r\n\r\n        c[1] = fraction(1, 3);\r\n\r\n        c[2] = fraction(1, 2);\r\n\r\n        c[3] = fraction(3, 5);\r\n\r\n        c[4] = get_field().get_one();\r\n\r\n        c[5] = get_field().get_one();\r\n\r\n        return c;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<std::vector<T>> get_a() \r\n\r\n    {\r\n\r\n        const std::vector<std::vector<T>> a = Math_Arrays::build_array(get_field(), 6, -1);\r\n\r\n        for (int i{}; i < a.size(); ++i) \r\n\r\n        {\r\n\r\n            a[i] = Math_Arrays::build_array(get_field(), i + 1);\r\n\r\n        }\r\n\r\n        a[0][0] = fraction(     2,     9);\r\n\r\n        a[1][0] = fraction(     1,    12);\r\n\r\n        a[1][1] = fraction(     1,     4);\r\n\r\n        a[2][0] = fraction(     1,     8);\r\n\r\n        a[2][1] = get_field().get_zero();\r\n\r\n        a[2][2] = fraction(     3,     8);\r\n\r\n        a[3][0] = fraction(    91,   500);\r\n\r\n        a[3][1] = fraction(   -27,   100);\r\n\r\n        a[3][2] = fraction(    78,   125);\r\n\r\n        a[3][3] = fraction(     8,   125);\r\n\r\n        a[4][0] = fraction(   -11,    20);\r\n\r\n        a[4][1] = fraction(    27,    20);\r\n\r\n        a[4][2] = fraction(    12,     5);\r\n\r\n        a[4][3] = fraction(   -36,     5);\r\n\r\n        a[4][4] = fraction(     5,     1);\r\n\r\n        a[5][0] = fraction(     1,    12);\r\n\r\n        a[5][1] = get_field().get_zero();\r\n\r\n        a[5][2] = fraction(    27,    32);\r\n\r\n        a[5][3] = fraction(    -4,     3);\r\n\r\n        a[5][4] = fraction(   125,    96);\r\n\r\n        a[5][5] = fraction(     5,    48);\r\n\r\n        return a;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public std::vector<T> get_b() \r\n\r\n    {\r\n\r\n        const std::vector<T> b = Math_Arrays::build_array(get_field(), 7);\r\n\r\n        b[0] = fraction(  1, 12);\r\n\r\n        b[1] = get_field().get_zero();\r\n\r\n        b[2] = fraction( 27, 32);\r\n\r\n        b[3] = fraction( -4,  3);\r\n\r\n        b[4] = fraction(125, 96);\r\n\r\n        b[5] = fraction(  5, 48);\r\n\r\n        b[6] = get_field().get_zero();\r\n\r\n        return b;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected Higham_Hall54_Field_State_Interpolator<T>\r\n\r\n        create_interpolator(const bool forward, std::vector<std::vector<T>> y_dot_k, const Field_ODE_State_And_Derivative<T> global_previous_state, const Field_ODE_State_And_Derivative<T> global_current_state, const FieldEquations_mapper<T> mapper) \r\n\r\n        {\r\n\r\n        return Higham_Hall54_Field_State_Interpolator<T>(get_field(), forward, y_dot_k, global_previous_state, global_current_state, global_previous_state, global_current_state, mapper);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    public int get_order() \r\n\r\n    {\r\n\r\n        return 5;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** {@inherit_doc} */\r\n\r\n    //override\r\n\r\n    protected double estimate_error(const std::vector<std::vector<T>> y_dot_k, const std::vector<T> y0, const std::vector<T> y1, const T h) \r\n\r\n    {\r\n\r\n\r\n\r\n        const Stepsize_Helper helper = get_step_size_helper();\r\n\r\n        double error = 0;\r\n\r\n\r\n\r\n        for (int j{}; j < helper.get_main_set_dimension(); ++j) \r\n\r\n        {\r\n\r\n            double err_sum = Higham_Hall54_Integrator.STATIC_E[0] * y_dot_k[0][j].get_real();\r\n\r\n            for (const int& l = 1; l < Higham_Hall54_Integrator.STATIC_E.size(); ++l) \r\n\r\n            {\r\n\r\n                err_sum += Higham_Hall54_Integrator.STATIC_E[l] * y_dot_k[l][j].get_real();\r\n\r\n            }\r\n\r\n            const double tol   = helper.get_tolerance(j, std::max(std::abs(y0[j].get_real()), std::abs(y1[j].get_real())));\r\n\r\n            const double ratio = h.get_real() * err_sum / tol;\r\n\r\n            error += ratio * ratio;\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        return std::sqrt(error / helper.get_main_set_dimension());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n