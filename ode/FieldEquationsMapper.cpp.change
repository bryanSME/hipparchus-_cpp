/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n//import org.hipparchus.util.Math_Utils;\r\n\r\n\r\n\r\n/**\r\n\r\n * Class mapping the part of a complete state or derivative that pertains\r\n\r\n * to a set of differential equations.\r\n\r\n * <p>\r\n\r\n * Instances of this class are guaranteed to be immutable.\r\n\r\n * </p>\r\n\r\n * @see FieldExpandable_ODE\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldEquations_mapper  \r\n\r\n{\r\n\r\n\r\n\r\n    /** Serializable UID. */\r\n\r\n    private static const long serial_version_uid = 20151114L;\r\n\r\n\r\n\r\n    /** Start indices of the components. */\r\n\r\n    private const std::vector<int> start;\r\n\r\n\r\n\r\n    /** Create a mapper by adding a equation to another mapper.\r\n\r\n     * <p>\r\n\r\n     * The equation will have index {@code mapper.}{@link #get_number_of_equations()}, * or 0 if {@code mapper} is null.\r\n\r\n     * </p>\r\n\r\n     * @param mapper former mapper, with one equation less (null for first equation)\r\n\r\n     * @param dimension dimension of the equation state vector\r\n\r\n     */\r\n\r\n    FieldEquations_mapper(const FieldEquations_mapper<T> mapper, const int& dimension) \r\n\r\n    {\r\n\r\n        const int index = (mapper == null) ? 0 : mapper.get_number_of_equations();\r\n\r\n        this.start = int[index + 2];\r\n\r\n        if (mapper == null) \r\n\r\n        {\r\n\r\n            start[0] = 0;\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            System.arraycopy(mapper.start, 0, start, 0, index + 1);\r\n\r\n        }\r\n\r\n        start[index + 1] = start[index] + dimension;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the number of equations mapped.\r\n\r\n     * @return number of equations mapped\r\n\r\n     */\r\n\r\n    public int get_number_of_equations() \r\n\r\n    {\r\n\r\n        return start.size() - 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Return the dimension of the complete set of equations.\r\n\r\n     * <p>\r\n\r\n     * The complete set of equations correspond to the primary set plus all secondary sets.\r\n\r\n     * </p>\r\n\r\n     * @return dimension of the complete set of equations\r\n\r\n     */\r\n\r\n    public int get_total_dimension() \r\n\r\n    {\r\n\r\n        return start[start.size() - 1];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Map flat arrays to a state and derivative.\r\n\r\n     * @param t time\r\n\r\n     * @param y state array to map, including primary and secondary components\r\n\r\n     * @param y_dot state derivative array to map, including primary and secondary components\r\n\r\n     * @return mapped state\r\n\r\n     * @exception  if an array does not match total dimension\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative<T> map_state_and_derivative(const T t, const std::vector<T> y, const std::vector<T> y_dot)\r\n\r\n         \r\n\r\n        {\r\n\r\n\r\n\r\n        if (y.size() != get_total_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, y.size(), get_total_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        if (y_dot.size() != get_total_dimension()) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, y_dot.size(), get_total_dimension());\r\n\r\n        }\r\n\r\n\r\n\r\n        const int n = get_number_of_equations();\r\n\r\n        const std::vector<T> state      = extract_equation_data(0, y);\r\n\r\n        const std::vector<T> derivative = extract_equation_data(0, y_dot);\r\n\r\n        if (n < 2) \r\n\r\n        {\r\n\r\n            return Field_ODE_State_And_Derivative<T>(t, state, derivative);\r\n\r\n        }\r\n\r\nelse \r\n\r\n        {\r\n\r\n            const std::vector<std::vector<T>> secondary_state      = Math_Arrays::build_array(t.get_field(), n - 1, -1);\r\n\r\n            const std::vector<std::vector<T>> secondary_derivative = Math_Arrays::build_array(t.get_field(), n - 1, -1);\r\n\r\n            for (const int& index = 1; index < get_number_of_equations(); ++index) \r\n\r\n            {\r\n\r\n                secondary_state[index - 1]      = extract_equation_data(index, y);\r\n\r\n                secondary_derivative[index - 1] = extract_equation_data(index, y_dot);\r\n\r\n            }\r\n\r\n            return Field_ODE_State_And_Derivative<T>(t, state, derivative, secondary_state, secondary_derivative);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Extract equation data from a complete state or derivative array.\r\n\r\n     * @param index index of the equation, must be between 0 included and\r\n\r\n     * {@link #get_number_of_equations()} (excluded)\r\n\r\n     * @param complete complete state or derivative array from which\r\n\r\n     * equation data should be retrieved\r\n\r\n     * @return equation data\r\n\r\n     * @exception  if index is out of range\r\n\r\n     * @exception  if complete state has not enough elements\r\n\r\n     */\r\n\r\n    public std::vector<T> extract_equation_data(const int index, const std::vector<T> complete)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_index(index);\r\n\r\n        const int begin     = start[index];\r\n\r\n        const int end       = start[index + 1];\r\n\r\n        if (complete.size() < end) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, complete.size(), end);\r\n\r\n        }\r\n\r\n        const int dimension = end - begin;\r\n\r\n        const std::vector<T> equation_data = Math_Arrays::build_array(complete[0].get_field(), dimension);\r\n\r\n        System.arraycopy(complete, begin, equation_data, 0, dimension);\r\n\r\n        return equation_data;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Insert equation data into a complete state or derivative array.\r\n\r\n     * @param index index of the equation, must be between 0 included and\r\n\r\n     * {@link #get_number_of_equations()} (excluded)\r\n\r\n     * @param equation_data equation data to be inserted into the complete array\r\n\r\n     * @param complete placeholder where to put equation data (only the\r\n\r\n     * part corresponding to the equation will be overwritten)\r\n\r\n     * @exception  if either array has not enough elements\r\n\r\n     */\r\n\r\n    public void insert_equation_data(const int index, std::vector<T> equation_data, std::vector<T> complete)\r\n\r\n         \r\n\r\n        {\r\n\r\n        check_index(index);\r\n\r\n        const int begin     = start[index];\r\n\r\n        const int end       = start[index + 1];\r\n\r\n        const int dimension = end - begin;\r\n\r\n        if (complete.size() < end) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, complete.size(), end);\r\n\r\n        }\r\n\r\n        if (equation_data.size() != dimension) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, equation_data.size(), dimension);\r\n\r\n        }\r\n\r\n        System.arraycopy(equation_data, 0, complete, begin, dimension);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check equation index.\r\n\r\n     * @param index index of the equation, must be between 0 included and\r\n\r\n     * {@link #get_number_of_equations()} (excluded)\r\n\r\n     * @exception  if index is out of range\r\n\r\n     */\r\n\r\n    private void check_index(const int index)  \r\n\r\n    {\r\n\r\n        Math_Utils::check_range_inclusive(index, 0, start.size() - 2);\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n