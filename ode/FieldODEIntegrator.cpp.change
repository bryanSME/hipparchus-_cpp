/*\r\n\r\n * Licensed to the Hipparchus project under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The Hipparchus project licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import java.util.Collection;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.analysis.solvers.Bracketed_Real_Field_Univariate_Solver;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.ode.events.Field_Event_Handler_Configuration;\r\n\r\n//import org.hipparchus.ode.events.FieldODE_Event_Handler;\r\n\r\n//import org.hipparchus.ode.sampling.FieldODE_Step_Handler;\r\n\r\n\r\n\r\n/** This interface represents a first order integrator for\r\n\r\n * differential equations.\r\n\r\n\r\n\r\n * <p>The classes which are devoted to solve first order differential\r\n\r\n * equations should implement this interface. The problems which can\r\n\r\n * be handled should implement the {@link\r\n\r\n * FieldOrdinary_Differential_Equation} interface.</p>\r\n\r\n *\r\n\r\n * @see FieldOrdinary_Differential_Equation\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass FieldODE_Integrator \r\n\r\n{\r\n\r\n\r\n\r\n    /** Get the name of the method.\r\n\r\n     * @return name of the method\r\n\r\n     */\r\n\r\n    std::string get_name();\r\n\r\n\r\n\r\n    /** Add a step handler to this integrator.\r\n\r\n     * <p>The handler will be called by the integrator for each accepted\r\n\r\n     * step.</p>\r\n\r\n     * @param handler handler for the accepted steps\r\n\r\n     * @see #get_step_handlers()\r\n\r\n     * @see #clear_step_handlers()\r\n\r\n     */\r\n\r\n    void add_step_handler(FieldODE_Step_Handler<T> handler);\r\n\r\n\r\n\r\n    /** Get all the step handlers that have been added to the integrator.\r\n\r\n     * @return an unmodifiable collection of the added events handlers\r\n\r\n     * @see #add_step_handler(FieldODE_Step_Handler)\r\n\r\n     * @see #clear_step_handlers()\r\n\r\n     */\r\n\r\n    Collection<FieldODE_Step_Handler<T>> get_step_handlers();\r\n\r\n\r\n\r\n    /** Remove all the step handlers that have been added to the integrator.\r\n\r\n     * @see #add_step_handler(FieldODE_Step_Handler)\r\n\r\n     * @see #get_step_handlers()\r\n\r\n     */\r\n\r\n    void clear_step_handlers();\r\n\r\n\r\n\r\n    /** Add an event handler to the integrator.\r\n\r\n     * <p>\r\n\r\n     * The default solver is a 5<sup>th</sup> order {@link\r\n\r\n     * org.hipparchus.analysis.solvers.FieldBracketing_Nth_Order_Brent_Solver}.\r\n\r\n     * </p>\r\n\r\n     * @param handler event handler\r\n\r\n     * @param max_check_interval maximal time interval between switching\r\n\r\n     * function checks (this interval prevents missing sign changes in\r\n\r\n     * case the integration steps becomes very large)\r\n\r\n     * @param convergence convergence threshold in the event time search\r\n\r\n     * @param max_iteration_count upper limit of the iteration count in\r\n\r\n     * the event time search events.\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int, Bracketed_Real_Field_Univariate_Solver)\r\n\r\n     * @see #get_event_handlers()\r\n\r\n     * @see #get_event_handlers_configurations()\r\n\r\n     * @see #clear_event_handlers()\r\n\r\n     */\r\n\r\n    void add_event_handler(FieldODE_Event_Handler<T>  handler, double max_check_interval, double convergence, int max_iteration_count);\r\n\r\n\r\n\r\n    /** Add an event handler to the integrator.\r\n\r\n     * @param handler event handler\r\n\r\n     * @param max_check_interval maximal time interval between switching\r\n\r\n     * function checks (this interval prevents missing sign changes in\r\n\r\n     * case the integration steps becomes very large)\r\n\r\n     * @param convergence convergence threshold in the event time search\r\n\r\n     * @param max_iteration_count upper limit of the iteration count in\r\n\r\n     * the event time search events.\r\n\r\n     * @param solver solver to use to locate the event\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int)\r\n\r\n     * @see #get_event_handlers()\r\n\r\n     * @see #get_event_handlers_configurations()\r\n\r\n     * @see #clear_event_handlers()\r\n\r\n     */\r\n\r\n    void add_event_handler(FieldODE_Event_Handler<T>  handler, double max_check_interval, double convergence, int max_iteration_count, Bracketed_Real_Field_Univariate_Solver<T> solver);\r\n\r\n\r\n\r\n    /** Get all the event handlers that have been added to the integrator.\r\n\r\n     * @return an unmodifiable collection of the added events handlers\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int)\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int, Bracketed_Real_Field_Univariate_Solver)\r\n\r\n     * @see #get_event_handlers_configurations()\r\n\r\n     * @see #clear_event_handlers()\r\n\r\n     */\r\n\r\n    Collection<FieldODE_Event_Handler<T> > get_event_handlers();\r\n\r\n\r\n\r\n    /** Get all the event handlers configurations that have been added to the integrator.\r\n\r\n     * @return an unmodifiable collection of the added events handlers configurations\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int)\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int, Bracketed_Real_Field_Univariate_Solver)\r\n\r\n     * @see #get_event_handlers()\r\n\r\n     * @see #clear_event_handlers()\r\n\r\n     * @since 2.0\r\n\r\n     */\r\n\r\n    Collection<Field_Event_Handler_Configuration<T>> get_event_handlers_configurations();\r\n\r\n\r\n\r\n    /** Remove all the event handlers that have been added to the integrator.\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int)\r\n\r\n     * @see #add_event_handler(FieldODE_Event_Handler, double, double, int, Bracketed_Real_Field_Univariate_Solver)\r\n\r\n     * @see #get_event_handlers()\r\n\r\n     * @see #get_event_handlers_configurations()\r\n\r\n     */\r\n\r\n    void clear_event_handlers();\r\n\r\n\r\n\r\n    /** Get the state at step start time t<sub>i</sub>.\r\n\r\n     * <p>This method can be called during integration (typically by\r\n\r\n     * the object implementing the {@link FieldOrdinary_Differential_Equation\r\n\r\n     * differential equations} problem) if the value of the current step that\r\n\r\n     * is attempted is needed.</p>\r\n\r\n     * <p>The result is undefined if the method is called outside of\r\n\r\n     * calls to <code>integrate</code>.</p>\r\n\r\n     * @return state at step start time t<sub>i</sub>\r\n\r\n     */\r\n\r\n    Field_ODE_State_And_Derivative<T> get_step_start();\r\n\r\n\r\n\r\n    /** Get the current signed value of the integration stepsize.\r\n\r\n     * <p>This method can be called during integration (typically by\r\n\r\n     * the object implementing the {@link FieldOrdinary_Differential_Equation\r\n\r\n     * differential equations} problem) if the signed value of the current stepsize\r\n\r\n     * that is tried is needed.</p>\r\n\r\n     * <p>The result is undefined if the method is called outside of\r\n\r\n     * calls to <code>integrate</code>.</p>\r\n\r\n     * @return current signed value of the stepsize\r\n\r\n     */\r\n\r\n    T get_current_signed_stepsize();\r\n\r\n\r\n\r\n    /** Set the maximal number of differential equations function evaluations.\r\n\r\n     * <p>The purpose of this method is to avoid infinite loops which can occur\r\n\r\n     * for example when stringent error constraints are set or when lots of\r\n\r\n     * discrete events are triggered, thus leading to many rejected steps.</p>\r\n\r\n     * @param max_evaluations maximal number of function evaluations (negative\r\n\r\n     * values are silently converted to maximal integer value, thus representing\r\n\r\n     * almost unlimited evaluations)\r\n\r\n     */\r\n\r\n    void set_max_evaluations(const int& max_evaluations);\r\n\r\n\r\n\r\n    /** Get the maximal number of functions evaluations.\r\n\r\n     * @return maximal number of functions evaluations\r\n\r\n     */\r\n\r\n    int get_max_evaluations();\r\n\r\n\r\n\r\n    /** Get the number of evaluations of the differential equations function.\r\n\r\n     * <p>\r\n\r\n     * The number of evaluations corresponds to the last call to the\r\n\r\n     * <code>integrate</code> method. It is 0 if the method has not been called yet.\r\n\r\n     * </p>\r\n\r\n     * @return number of evaluations of the differential equations function\r\n\r\n     */\r\n\r\n    int get_evaluations();\r\n\r\n\r\n\r\n    /** Integrate the differential equations up to the given time.\r\n\r\n     * <p>This method solves an Initial Value Problem (IVP).</p>\r\n\r\n     * <p>sin_ce this method stores some internal state variables made\r\n\r\n     * available in its class during integration ({@link\r\n\r\n     * #get_current_signed_stepsize()}), it is <em>not</em> thread-safe.</p>\r\n\r\n     * @param equations differential equations to integrate\r\n\r\n     * @param initial_state initial state (time, primary and secondary state vectors)\r\n\r\n     * @param const_time target time for the integration\r\n\r\n     * (can be set to a value smaller than {@code t0} for backward integration)\r\n\r\n     * @return const state, its time will be the same as {@code const_time} if\r\n\r\n     * integration reached its target, but may be different if some {@link\r\n\r\n     * org.hipparchus.ode.events.FieldODE_Event_Handler} stops it at some point.\r\n\r\n     * @exception  if integration step is too small\r\n\r\n     * @exception Math_Illegal_State_Exception if the number of functions evaluations is exceeded\r\n\r\n     * @exception  if the location of an event cannot be bracketed\r\n\r\n     */\r\n\r\n    Field_ODE_State_And_Derivative<T> integrate(FieldExpandable_ODE<T> equations, FieldODE_State<T> initial_state, T const_time)\r\n\r\n        , Math_Illegal_State_Exception;\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n