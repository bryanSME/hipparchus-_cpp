/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.ode;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n\r\n\r\n/** Container for time, main and secondary state vectors as well as their derivatives.\r\n\r\n\r\n\r\n * @see FieldOrdinary_Differential_Equation\r\n\r\n * @see FieldSecondary_ODE\r\n\r\n * @see FieldODE_Integrator\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_ODE_State_And_Derivative extends FieldODE_State<T> \r\n\r\n{\r\n\r\n\r\n\r\n    /** Derivative of the primary state at time. */\r\n\r\n    private const std::vector<T> primary_derivative;\r\n\r\n\r\n\r\n    /** Derivative of the secondary state at time. */\r\n\r\n    private const std::vector<std::vector<T>> secondary_derivative;\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * <p>Calling this constructor is equivalent to call {@link\r\n\r\n     * #Field_ODE_State_And_Derivative(Calculus_Field_Element, Calculus_Field_Element[], Calculus_Field_Element[], * Calculus_Field_Element[][], Calculus_Field_Element[][]) Field_ODE_State_And_Derivative(time, state, * derivative, null, null)}.</p>\r\n\r\n     * @param time time\r\n\r\n     * @param primary_state primary state at time\r\n\r\n     * @param primary_derivative derivative of the primary state at time\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative(T time, std::vector<T> primary_state, std::vector<T> primary_derivative) \r\n\r\n    {\r\n\r\n        this(time, primary_state, primary_derivative, null, null);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * @param time time\r\n\r\n     * @param primary_state primary state at time\r\n\r\n     * @param primary_derivative derivative of the primary state at time\r\n\r\n     * @param secondary_state state at time (may be null)\r\n\r\n     * @param secondary_derivative derivative of the state at time (may be null)\r\n\r\n     */\r\n\r\n    public Field_ODE_State_And_Derivative(T time, std::vector<T> primary_state, std::vector<T> primary_derivative, std::vector<std::vector<T>> secondary_state, std::vector<std::vector<T>> secondary_derivative) \r\n\r\n    {\r\n\r\n        super(time, primary_state, secondary_state);\r\n\r\n        this.primary_derivative   = primary_derivative.clone();\r\n\r\n        this.secondary_derivative = copy(secondary_derivative);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get derivative of the primary state at time.\r\n\r\n     * @return derivative of the primary state at time\r\n\r\n     * @see #get_secondary_derivativestatic_cast<int>(\r\n\r\n     * @see #get_complete_derivative()\r\n\r\n     */\r\n\r\n    public std::vector<T> get_primary_derivative() \r\n\r\n    {\r\n\r\n        return primary_derivative.clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get derivative of the secondary state at time.\r\n\r\n     * @param index index of the secondary set as returned\r\n\r\n     * by {@link FieldExpandable_ODE#add_secondary_equations(FieldSecondary_ODE)}\r\n\r\n     * (beware index 0 corresponds to primary state, secondary states start at 1)\r\n\r\n     * @return derivative of the secondary state at time\r\n\r\n     * @see #get_primary_derivative()\r\n\r\n     * @see #get_complete_derivative()\r\n\r\n     */\r\n\r\n    public std::vector<T> get_secondary_derivative(const int index) \r\n\r\n    {\r\n\r\n        return index == 0 ? primary_derivative.clone() : secondary_derivative[index - 1].clone();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get complete derivative at time.\r\n\r\n     * @return complete derivative at time, starting with\r\n\r\n     * {@link #get_primary_derivative() primary derivative}, followed\r\n\r\n     * by all {@link #get_secondary_derivativestatic_cast<int>( secondary derivatives} in\r\n\r\n     * increasing index order\r\n\r\n     * @see #get_primary_derivative()\r\n\r\n     * @see #get_secondary_derivativestatic_cast<int>(\r\n\r\n     */\r\n\r\n    public std::vector<T> get_complete_derivative() \r\n\r\n    {\r\n\r\n        const std::vector<T> complete_derivative = Math_Arrays::build_array(get_time().get_field(), get_complete_state_dimension());\r\n\r\n        System.arraycopy(primary_derivative, 0, complete_derivative, 0, primary_derivative.size());\r\n\r\n        int offset = primary_derivative.size();\r\n\r\n        if (secondary_derivative != null) \r\n\r\n        {\r\n\r\n            for (int index = 0; index < secondary_derivative.size(); ++index) \r\n\r\n            {\r\n\r\n                System.arraycopy(secondary_derivative[index], 0, complete_derivative, offset, secondary_derivative[index].size());\r\n\r\n                offset += secondary_derivative[index].size();\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return complete_derivative;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n