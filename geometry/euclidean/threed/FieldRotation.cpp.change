/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.geometry.euclidean.threed;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Illegal_State_Exception;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.geometry.Localized_Geometry_Formats;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n#include <vector>\r\n\r\n\r\n\r\n/**\r\n\r\n * This class is a re-implementation of {@link Rotation} using {@link Calculus_Field_Element}.\r\n\r\n * <p>Instance of this class are guaranteed to be immutable.</p>\r\n\r\n *\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @see Field_Vector_3D\r\n\r\n * @see Rotation_Order\r\n\r\n */\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Rotation  \r\n\r\n{\r\n\r\n\r\n\r\nprivate:\r\n\r\n\r\n\r\n    /** Scalar coordinate of the quaternion. */\r\n\r\n    const T my_q_0;\r\n\r\n\r\n\r\n    /** First coordinate of the vectorial part of the quaternion. */\r\n\r\n    const T my_q_1;\r\n\r\n\r\n\r\n    /** Second coordinate of the vectorial part of the quaternion. */\r\n\r\n    const T my_q_2;\r\n\r\n\r\n\r\n    /** Third coordinate of the vectorial part of the quaternion. */\r\n\r\n    const T my_q_3;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Build a rotation from the quaternion coordinates.\r\n\r\n     * <p>A rotation can be built from a <em>normalized</em> quaternion, * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\r\n\r\n     * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\r\n\r\n     * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized, * the constructor can normalize it in a preprocessing step.</p>\r\n\r\n     * <p>Note that some conventions put the scalar part of the quaternion\r\n\r\n     * as the 4<sup>th</sup> component and the vector part as the first three\r\n\r\n     * components. This is <em>not</em> our convention. We put the scalar part\r\n\r\n     * as the first component.</p>\r\n\r\n     * @param my_q_0 scalar part of the quaternion\r\n\r\n     * @param my_q_1 first coordinate of the vectorial part of the quaternion\r\n\r\n     * @param my_q_2 second coordinate of the vectorial part of the quaternion\r\n\r\n     * @param my_q_3 third coordinate of the vectorial part of the quaternion\r\n\r\n     * @param needs_normalization if true, the coordinates are considered\r\n\r\n     * not to be normalized, a normalization preprocessing step is performed\r\n\r\n     * before using them\r\n\r\n     */\r\n\r\n    Field_Rotation(const T& q_0, const T& q_1, const T& q_2, const T& q_3, const bool needs_normalization) \r\n\r\n    {\r\n\r\n\r\n\r\n        if (needs_normalization) \r\n\r\n        {\r\n\r\n            // normalization preprocessing\r\n\r\n            const T inv = q_0.multiply(q_0).add(q_1.multiply(q_1)).add(q_2.multiply(q_2)).add(q_3.multiply(q_3)).sqrt().reciprocal();\r\n\r\n            my_q_0 = inv.multiply(q_0);\r\n\r\n            my_q_1 = inv.multiply(q_1);\r\n\r\n            my_q_2 = inv.multiply(q_2);\r\n\r\n            my_q_3 = inv.multiply(q_3);\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            my_q_0 = q_0;\r\n\r\n            my_q_1 = q_1;\r\n\r\n            my_q_2 = q_2;\r\n\r\n            my_q_3 = q_3;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a rotation from an axis and an angle.\r\n\r\n     * <p>We use the convention that angles are oriented according to\r\n\r\n     * the effect of the rotation on vectors around the axis. That means\r\n\r\n     * that if (i, j, k) is a direct frame and if we first provide +k as\r\n\r\n     * the axis and &pi;/2 as the angle to this constructor, and then\r\n\r\n     * {@link #apply_to(Field_Vector_3D) apply} the instance to +i, we will get\r\n\r\n     * +j.</p>\r\n\r\n     * <p>Another way to represent our convention is to say that a rotation\r\n\r\n     * of angle &theta; about the unit vector (x, y, z) is the same as the\r\n\r\n     * rotation build from quaternion components { cos(-&theta;/2), * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\r\n\r\n     * Note the minus sign on the angle!</p>\r\n\r\n     * <p>On the one hand this convention is consistent with a vectorial\r\n\r\n     * perspective (moving vectors in fixed frames), on the other hand it\r\n\r\n     * is different from conventions with a frame perspective (fixed vectors\r\n\r\n     * viewed from different frames) like the ones used for example in spacecraft\r\n\r\n     * attitude community or in the graphics community.</p>\r\n\r\n     * @param axis axis around which to rotate\r\n\r\n     * @param angle rotation angle.\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @exception  if the axis norm is zero\r\n\r\n     */\r\n\r\n    Field_Rotation(const Field_Vector_3D<T>& axis, const T& angle, const Rotation_Convention& convention)\r\n\r\n    {\r\n\r\n        const T norm = axis.get_norm();\r\n\r\n        if (norm.get_real() == 0) \r\n\r\n        {\r\n\r\n            throw (Localized_Geometry_Formats.ZERO_NORM_FOR_ROTATION_AXIS);\r\n\r\n        }\r\n\r\n\r\n\r\n        const T half_angle = angle.multiply(convention == Rotation_Convention.VECTOR_OPERATOR ? -0.5 : 0.5);\r\n\r\n        const Field_Sin_Cos<T> sin_cos = Sin_Cos(half_angle);\r\n\r\n        const T coeff = sin_cos.sin().divide(norm);\r\n\r\n\r\n\r\n        my_q_0 = sin_cos.cos();\r\n\r\n        my_q_1 = coeff.multiply(axis.get_x());\r\n\r\n        my_q_2 = coeff.multiply(axis.get_y());\r\n\r\n        my_q_3 = coeff.multiply(axis.get_z());\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a {@link Field_Rotation} from a {@link Rotation}.\r\n\r\n     * @param field field for the components\r\n\r\n     * @param r rotation to convert\r\n\r\n     */\r\n\r\n    Field_Rotation(const Field<T>& field, const Rotation& r) \r\n\r\n    {\r\n\r\n        my_q_0 = field.get_zero().add(r.get_my_q_0());\r\n\r\n        my_q_1 = field.get_zero().add(r.get_my_q_1());\r\n\r\n        my_q_2 = field.get_zero().add(r.get_my_q_2());\r\n\r\n        my_q_3 = field.get_zero().add(r.get_my_q_3());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a rotation from a 3X3 matrix.\r\n\r\n\r\n\r\n     * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\r\n\r\n     * (which are matrices for which m.m<sup>T</sup> = I) with real\r\n\r\n     * coefficients. The module of the determinant of unit matrices is\r\n\r\n     * 1, among the orthogonal 3X3 matrices, only the ones having a\r\n\r\n     * positive determinant (+1) are rotation matrices.</p>\r\n\r\n\r\n\r\n     * <p>When a rotation is defined by a matrix with truncated values\r\n\r\n     * (typically when it is extracted from a technical sheet where only\r\n\r\n     * four to five significant digits are available), the matrix is not\r\n\r\n     * orthogonal anymore. This constructor handles this case\r\n\r\n     * transparently by using a copy of the given matrix and applying a\r\n\r\n     * correction to the copy in order to perfect its orthogonality. If\r\n\r\n     * the Frobenius norm of the correction needed is above the given\r\n\r\n     * threshold, then the matrix is considered to be too far from a\r\n\r\n     * true rotation matrix and an exception is thrown.<p>\r\n\r\n\r\n\r\n     * @param m rotation matrix\r\n\r\n     * @param threshold convergence threshold for the iterative\r\n\r\n     * orthogonality correction (convergence is reached when the\r\n\r\n     * difference between two steps of the Frobenius norm of the\r\n\r\n     * correction is below this threshold)\r\n\r\n\r\n\r\n     * @exception  if the matrix is not a 3X3\r\n\r\n     * matrix, or if it cannot be transformed into an orthogonal matrix\r\n\r\n     * with the given threshold, or if the determinant of the resulting\r\n\r\n     * orthogonal matrix is negative\r\n\r\n\r\n\r\n     */\r\n\r\n    Field_Rotation(const std::vector<std::vector<T>>& m, const double& threshold)\r\n\r\n    {\r\n\r\n        // dimension check\r\n\r\n        if ((m.size() != 3) || (m[0].size() != 3) || (m[1].size() != 3) || (m[2].size() != 3)) \r\n\r\n        {\r\n\r\n            throw (Localized_Geometry_Formats.ROTATION_MATRIX_DIMENSIONS, m.size(), m[0].size());\r\n\r\n        }\r\n\r\n\r\n\r\n        // compute a "close" orthogonal matrix\r\n\r\n        const std::vector<std::vector<T>> ort = orthogonalize_matrix(m, threshold);\r\n\r\n\r\n\r\n        // check the sign of the determinant\r\n\r\n        const T d0 = ort[1][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[1][2]));\r\n\r\n        const T d1 = ort[0][1].multiply(ort[2][2]).subtract(ort[2][1].multiply(ort[0][2]));\r\n\r\n        const T d2 = ort[0][1].multiply(ort[1][2]).subtract(ort[1][1].multiply(ort[0][2]));\r\n\r\n        const T det =\r\n\r\n                ort[0][0].multiply(d0).subtract(ort[1][0].multiply(d1)).add(ort[2][0].multiply(d2));\r\n\r\n        if (det.get_real() < 0.0) \r\n\r\n        {\r\n\r\n            throw (Localized_Geometry_Formats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT, det);\r\n\r\n        }\r\n\r\n\r\n\r\n        const std::vector<T> quat = mat2quat(ort);\r\n\r\n        my_q_0 = quat[0];\r\n\r\n        my_q_1 = quat[1];\r\n\r\n        my_q_2 = quat[2];\r\n\r\n        my_q_3 = quat[3];\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build the rotation that transforms a pair of vectors into another pair.\r\n\r\n\r\n\r\n     * <p>Except for possible scale factors, if the instance were applied to\r\n\r\n     * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\r\n\r\n     * (v<sub>1</sub>, v<sub>2</sub>).</p>\r\n\r\n\r\n\r\n     * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\r\n\r\n     * not the same as the angular separation between v<sub>1</sub> and\r\n\r\n     * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\r\n\r\n     * v<sub>2</sub>, the corrected vector will be in the (&pm;v<sub>1</sub>, * +v<sub>2</sub>) half-plane.</p>\r\n\r\n\r\n\r\n     * @param u1 first vector of the origin pair\r\n\r\n     * @param u2 second vector of the origin pair\r\n\r\n     * @param v1 desired image of u1 by the rotation\r\n\r\n     * @param v2 desired image of u2 by the rotation\r\n\r\n     * @exception Math_Runtime_Exception if the norm of one of the vectors is zero, * or if one of the pair is degenerated (i.e. the vectors of the pair are collinear)\r\n\r\n     */\r\n\r\n    Field_Rotation(Field_Vector_3D<T> u1, Field_Vector_3D<T> u2, Field_Vector_3D<T> v1, Field_Vector_3D<T> v2)\r\n\r\n    {\r\n\r\n        // build orthonormalized base from u1, u2\r\n\r\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\r\n\r\n        const Field_Vector_3D<T> u3 = Field_Vector_3D.cross_product(u1, u2).normalize();\r\n\r\n        u2 = Field_Vector_3D.cross_product(u3, u1).normalize();\r\n\r\n        u1 = u1.normalize();\r\n\r\n\r\n\r\n        // build an orthonormalized base from v1, v2\r\n\r\n        // this fails when vectors are null or collinear, which is forbidden to define a rotation\r\n\r\n        const Field_Vector_3D<T> v3 = Field_Vector_3D.cross_product(v1, v2).normalize();\r\n\r\n        v2 = Field_Vector_3D.cross_product(v3, v1).normalize();\r\n\r\n        v1 = v1.normalize();\r\n\r\n\r\n\r\n        // buid a matrix transforming the first base into the second one\r\n\r\n        const std::vector<std::vector<T>> array = Math_Arrays::build_array(u1.get_x().get_field(), 3, 3);\r\n\r\n        array[0][0] = u1.get_x().multiply(v1.get_x()).add(u2.get_x().multiply(v2.get_x())).add(u3.get_x().multiply(v3.get_x()));\r\n\r\n        array[0][1] = u1.get_y().multiply(v1.get_x()).add(u2.get_y().multiply(v2.get_x())).add(u3.get_y().multiply(v3.get_x()));\r\n\r\n        array[0][2] = u1.get_z().multiply(v1.get_x()).add(u2.get_z().multiply(v2.get_x())).add(u3.get_z().multiply(v3.get_x()));\r\n\r\n        array[1][0] = u1.get_x().multiply(v1.get_y()).add(u2.get_x().multiply(v2.get_y())).add(u3.get_x().multiply(v3.get_y()));\r\n\r\n        array[1][1] = u1.get_y().multiply(v1.get_y()).add(u2.get_y().multiply(v2.get_y())).add(u3.get_y().multiply(v3.get_y()));\r\n\r\n        array[1][2] = u1.get_z().multiply(v1.get_y()).add(u2.get_z().multiply(v2.get_y())).add(u3.get_z().multiply(v3.get_y()));\r\n\r\n        array[2][0] = u1.get_x().multiply(v1.get_z()).add(u2.get_x().multiply(v2.get_z())).add(u3.get_x().multiply(v3.get_z()));\r\n\r\n        array[2][1] = u1.get_y().multiply(v1.get_z()).add(u2.get_y().multiply(v2.get_z())).add(u3.get_y().multiply(v3.get_z()));\r\n\r\n        array[2][2] = u1.get_z().multiply(v1.get_z()).add(u2.get_z().multiply(v2.get_z())).add(u3.get_z().multiply(v3.get_z()));\r\n\r\n\r\n\r\n        std::vector<T> quat = mat2quat(array);\r\n\r\n        my_q_0 = quat[0];\r\n\r\n        my_q_1 = quat[1];\r\n\r\n        my_q_2 = quat[2];\r\n\r\n        my_q_3 = quat[3];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build one of the rotations that transform one vector into another one.\r\n\r\n\r\n\r\n     * <p>Except for a possible scale factor, if the instance were\r\n\r\n     * applied to the vector u it will produce the vector v. There is an\r\n\r\n     * infinite number of such rotations, this constructor choose the\r\n\r\n     * one with the smallest associated angle (i.e. the one whose axis\r\n\r\n     * is orthogonal to the (u, v) plane). If u and v are collinear, an\r\n\r\n     * arbitrary rotation axis is chosen.</p>\r\n\r\n\r\n\r\n     * @param u origin vector\r\n\r\n     * @param v desired image of u by the rotation\r\n\r\n     * @exception Math_Runtime_Exception if the norm of one of the vectors is zero\r\n\r\n     */\r\n\r\n    public Field_Rotation(const Field_Vector_3D<T>& u, const Field_Vector_3D<T>& v) \r\n\r\n    {\r\n\r\n        const T norm_product = u.get_norm().multiply(v.get_norm());\r\n\r\n        if (norm_product.get_real() == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Geometry_Formats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\r\n\r\n        }\r\n\r\n\r\n\r\n        const T dot = Field_Vector_3D.dot_product(u, v);\r\n\r\n\r\n\r\n        if (dot.get_real() < ((2.0e-15 - 1.0) * norm_product.get_real())) \r\n\r\n        {\r\n\r\n            // special case u = -v: we select a PI angle rotation around\r\n\r\n            // an arbitrary vector orthogonal to u\r\n\r\n            const Field_Vector_3D<T> w = u.orthogonal();\r\n\r\n            my_q_0 = norm_product.get_field().get_zero();\r\n\r\n            my_q_1 = w.get_x().negate();\r\n\r\n            my_q_2 = w.get_y().negate();\r\n\r\n            my_q_3 = w.get_z().negate();\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            // general case: (u, v) defines a plane, we select\r\n\r\n            // the shortest possible rotation: axis orthogonal to this plane\r\n\r\n            my_q_0 = dot.divide(norm_product).add(1.0).multiply(0.5).sqrt();\r\n\r\n            const T coeff = my_q_0.multiply(norm_product).multiply(2.0).reciprocal();\r\n\r\n            const Field_Vector_3D<T> q = Field_Vector_3D.cross_product(v, u);\r\n\r\n            my_q_1 = coeff.multiply(q.get_x());\r\n\r\n            my_q_2 = coeff.multiply(q.get_y());\r\n\r\n            my_q_3 = coeff.multiply(q.get_z());\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a rotation from three Cardan or Euler elementary rotations.\r\n\r\n\r\n\r\n     * <p>Cardan rotations are three successive rotations around the\r\n\r\n     * canonical axes X, Y and Z, each axis being used once. There are\r\n\r\n     * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\r\n\r\n     * rotations are three successive rotations around the canonical\r\n\r\n     * axes X, Y and Z, the first and last rotations being around the\r\n\r\n     * same axis. There are 6 such sets of rotations (XYX, XZX, YXY, * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\r\n\r\n     * <p>Beware that many people routinely use the term Euler angles even\r\n\r\n     * for what really are Cardan angles (this confusion is especially\r\n\r\n     * widespread in the aerospace business where Roll, Pitch and Yaw angles\r\n\r\n     * are often wrongly tagged as Euler angles).</p>\r\n\r\n\r\n\r\n     * @param order order of rotations to compose, from left to right\r\n\r\n     * (i.e. we will use {@code r1.compose(r2.compose(r3, convention), convention)})\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @param alpha1 angle of the first elementary rotation\r\n\r\n     * @param alpha2 angle of the second elementary rotation\r\n\r\n     * @param alpha3 angle of the third elementary rotation\r\n\r\n     */\r\n\r\n    Field_Rotation(const Rotation_Order& order, const Rotation_Convention& convention, const T& alpha1, const T& alpha2, const T& alpha3) \r\n\r\n    {\r\n\r\n        const Field<T> field = alpha1.get_field();\r\n\r\n        const Field_Rotation<T> r1 = Field_Rotation<>(new Field_Vector_3D<>(field, order.get_a1()), alpha1, convention);\r\n\r\n        const Field_Rotation<T> r2 = Field_Rotation<>(new Field_Vector_3D<>(field, order.get_a2()), alpha2, convention);\r\n\r\n        const Field_Rotation<T> r3 = Field_Rotation<>(new Field_Vector_3D<>(field, order.get_a3()), alpha3, convention);\r\n\r\n        const Field_Rotation<T> composed = r1.compose(r2.compose(r3, convention), convention);\r\n\r\n        my_q_0 = composed.my_q_0;\r\n\r\n        my_q_1 = composed.my_q_1;\r\n\r\n        my_q_2 = composed.my_q_2;\r\n\r\n        my_q_3 = composed.my_q_3;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get identity rotation.\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a rotation\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Rotation<T> get_identity(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Rotation<>(field, Rotation.IDENTITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the instance to another rotation.\r\n\r\n * <p>\r\n\r\n * Calling this method is equivalent to call\r\n\r\n * {@link #compose(Rotation, Rotation_Convention)\r\n\r\n * compose(r, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n * </p>\r\n\r\n * @param r rotation to apply the rotation to\r\n\r\n * @return a rotation which is the composition of r by the instance\r\n\r\n */\r\n\r\n    Field_Rotation<T> apply_to(const Rotation& r)\r\n\r\n    {\r\n\r\n        return compose(r, Rotation_Convention.VECTOR_OPERATOR);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the instance with another rotation.\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#VECTOR_OPERATOR vector operator} convention, * applying the instance to a rotation is computing the composition\r\n\r\n     * in an order compliant with the following rule : let {@code u} be any\r\n\r\n     * vector and {@code v} its image by {@code r1} (i.e.\r\n\r\n     * {@code r1.apply_to(u) = v}). Let {@code w} be the image of {@code v} by\r\n\r\n     * rotation {@code r2} (i.e. {@code r2.apply_to(v) = w}). Then\r\n\r\n     * {@code w = comp.apply_to(u)}, where\r\n\r\n     * {@code comp = r2.compose(r1, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#FRAME_TRANSFORM frame transform} convention, * the application order will be reversed. So keeping the exact same\r\n\r\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\r\n\r\n     * and  {@code comp} as above, {@code comp} could also be computed as\r\n\r\n     * {@code comp = r1.compose(r2, Rotation_Convention.FRAME_TRANSFORM)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return a rotation which is the composition of r by the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose(const Rotation& r, const Rotation_Convention& convention)\r\n\r\n    {\r\n\r\n        return convention == Rotation_Convention.VECTOR_OPERATOR\r\n\r\n            ? compose_internal(r)\r\n\r\n            : apply_to(r, this);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply a rotation to another rotation.\r\n\r\n * Applying a rotation to another rotation is computing the composition\r\n\r\n * in an order compliant with the following rule : let u be any\r\n\r\n * vector and v its image by r_inner (i.e. r_inner.apply_to(u) = v), let w be the image\r\n\r\n * of v by r_outer (i.e. r_outer.apply_to(v) = w), then w = comp.apply_to(u), * where comp = apply_to(r_outer, r_inner).\r\n\r\n * @param r1 rotation to apply\r\n\r\n * @param r_inner rotation to apply the rotation to\r\n\r\n * @param <T> the type of the field elements\r\n\r\n * @return a rotation which is the composition of r by the instance\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Rotation<T> apply_to(const Rotation r1, const Field_Rotation<T> r_inner)\r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(r_inner.my_q_0.multiply(r1.get_my_q_0()).subtract(r_inner.my_q_1.multiply(r1.get_my_q_1()).add(r_inner.my_q_2.multiply(r1.get_my_q_2())).add(r_inner.my_q_3.multiply(r1.get_my_q_3()))), r_inner.my_q_1.multiply(r1.get_my_q_0()).add(r_inner.my_q_0.multiply(r1.get_my_q_1())).add(r_inner.my_q_2.multiply(r1.get_my_q_3()).subtract(r_inner.my_q_3.multiply(r1.get_my_q_2()))), r_inner.my_q_2.multiply(r1.get_my_q_0()).add(r_inner.my_q_0.multiply(r1.get_my_q_2())).add(r_inner.my_q_3.multiply(r1.get_my_q_1()).subtract(r_inner.my_q_1.multiply(r1.get_my_q_3()))), r_inner.my_q_3.multiply(r1.get_my_q_0()).add(r_inner.my_q_0.multiply(r1.get_my_q_3())).add(r_inner.my_q_1.multiply(r1.get_my_q_2()).subtract(r_inner.my_q_2.multiply(r1.get_my_q_1()))), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the instance to another rotation.\r\n\r\n     * <p>\r\n\r\n     * Calling this method is equivalent to call\r\n\r\n     * {@link #compose_inverse(Field_Rotation, Rotation_Convention)\r\n\r\n     * compose_inverse(r, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> apply_inverse_to(const Field_Rotation<T>& r)\r\n\r\n    {\r\n\r\n        return compose_inverse(r, Rotation_Convention.VECTOR_OPERATOR);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the inverse of the instance with another rotation.\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#VECTOR_OPERATOR vector operator} convention, * applying the inverse of the instance to a rotation is computing\r\n\r\n     * the composition in an order compliant with the following rule :\r\n\r\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\r\n\r\n     * (i.e. {@code r1.apply_to(u) = v}). Let {@code w} be the inverse image\r\n\r\n     * of {@code v} by {@code r2} (i.e. {@code r2.apply_inverse_to(v) = w}).\r\n\r\n     * Then {@code w = comp.apply_to(u)}, where\r\n\r\n     * {@code comp = r2.compose_inverse(r1)}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#FRAME_TRANSFORM frame transform} convention, * the application order will be reversed, which means it is the\r\n\r\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\r\n\r\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\r\n\r\n     * and  {@code comp} as above, {@code comp} could also be computed as\r\n\r\n     * {@code comp = r1.revert().compose_inverse(r2.revert(), Rotation_Convention.FRAME_TRANSFORM)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_inverse(const Field_Rotation<T>& r, const Rotation_Convention& convention)\r\n\r\n    {\r\n\r\n        return convention == Rotation_Convention.VECTOR_OPERATOR\r\n\r\n            ? compose_inverse_internal(r)\r\n\r\n            : r.compose_internal(revert());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the instance to another rotation.\r\n\r\n * <p>\r\n\r\n * Calling this method is equivalent to call\r\n\r\n * {@link #compose_inverse(Rotation, Rotation_Convention)\r\n\r\n * compose_inverse(r, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n * </p>\r\n\r\n * @param r rotation to apply the rotation to\r\n\r\n * @return a rotation which is the composition of r by the inverse\r\n\r\n * of the instance\r\n\r\n */\r\n\r\n    Field_Rotation<T> apply_inverse_to(const Rotation& r)\r\n\r\n    {\r\n\r\n        return compose_inverse(r, Rotation_Convention.VECTOR_OPERATOR);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the inverse of the instance with another rotation.\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#VECTOR_OPERATOR vector operator} convention, * applying the inverse of the instance to a rotation is computing\r\n\r\n     * the composition in an order compliant with the following rule :\r\n\r\n     * let {@code u} be any vector and {@code v} its image by {@code r1}\r\n\r\n     * (i.e. {@code r1.apply_to(u) = v}). Let {@code w} be the inverse image\r\n\r\n     * of {@code v} by {@code r2} (i.e. {@code r2.apply_inverse_to(v) = w}).\r\n\r\n     * Then {@code w = comp.apply_to(u)}, where\r\n\r\n     * {@code comp = r2.compose_inverse(r1)}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#FRAME_TRANSFORM frame transform} convention, * the application order will be reversed, which means it is the\r\n\r\n     * <em>innermost</em> rotation that will be reversed. So keeping the exact same\r\n\r\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\r\n\r\n     * and  {@code comp} as above, {@code comp} could also be computed as\r\n\r\n     * {@code comp = r1.revert().compose_inverse(r2.revert(), Rotation_Convention.FRAME_TRANSFORM)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_inverse(const Rotation& r, const Rotation_Convention& convention)\r\n\r\n    {\r\n\r\n        return convention == Rotation_Convention.VECTOR_OPERATOR\r\n\r\n            ? compose_inverse_internal(r)\r\n\r\n            : apply_to(r, revert());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of a rotation to another rotation.\r\n\r\n     * Applying the inverse of a rotation to another rotation is computing\r\n\r\n     * the composition in an order compliant with the following rule :\r\n\r\n     * let u be any vector and v its image by r_inner (i.e. r_inner.apply_to(u) = v), * let w be the inverse image of v by r_outer\r\n\r\n     * (i.e. r_outer.apply_inverse_to(v) = w), then w = comp.apply_to(u), where\r\n\r\n     * comp = apply_inverse_to(r_outer, r_inner).\r\n\r\n     * @param r_outer rotation to apply the rotation to\r\n\r\n     * @param r_inner rotation to apply the rotation to\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Rotation<T> apply_inverse_to(const Rotation& r_outer, const Field_Rotation<T>& r_inner)\r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(r_inner.my_q_0.multiply(r_outer.get_my_q_0()).add(r_inner.my_q_1.multiply(r_outer.get_my_q_1()).add(r_inner.my_q_2.multiply(r_outer.get_my_q_2())).add(r_inner.my_q_3.multiply(r_outer.get_my_q_3()))).negate(), r_inner.my_q_0.multiply(r_outer.get_my_q_1()).add(r_inner.my_q_2.multiply(r_outer.get_my_q_3()).subtract(r_inner.my_q_3.multiply(r_outer.get_my_q_2()))).subtract(r_inner.my_q_1.multiply(r_outer.get_my_q_0())), r_inner.my_q_0.multiply(r_outer.get_my_q_2()).add(r_inner.my_q_3.multiply(r_outer.get_my_q_1()).subtract(r_inner.my_q_1.multiply(r_outer.get_my_q_3()))).subtract(r_inner.my_q_2.multiply(r_outer.get_my_q_0())), r_inner.my_q_0.multiply(r_outer.get_my_q_3()).add(r_inner.my_q_1.multiply(r_outer.get_my_q_2()).subtract(r_inner.my_q_2.multiply(r_outer.get_my_q_1()))).subtract(r_inner.my_q_3.multiply(r_outer.get_my_q_0())), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the <i>distance</i> between two rotations.\r\n\r\n     * <p>The <i>distance</i> is intended here as a way to check if two\r\n\r\n     * rotations are almost similar (i.e. they transform vectors the same way)\r\n\r\n     * or very different. It is mathematically defined as the angle of\r\n\r\n     * the rotation r that prepended to one of the rotations gives the other\r\n\r\n     * one:</p>\r\n\r\n     * <pre>\r\n\r\n     *        r<sub>1</sub>(r) = r<sub>2</sub>\r\n\r\n     * </pre>\r\n\r\n     * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\r\n\r\n     * possible upper bound of the angle in radians between r<sub>1</sub>(v)\r\n\r\n     * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\r\n\r\n     * reached for some v. The distance is equal to 0 if and only if the two\r\n\r\n     * rotations are identical.</p>\r\n\r\n     * <p>Comparing two rotations should always be done using this value rather\r\n\r\n     * than for example comparing the components of the quaternions. It is much\r\n\r\n     * more stable, and has a geometric meaning. Also comparing quaternions\r\n\r\n     * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\r\n\r\n     * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\r\n\r\n     * their components are different (they are exact opposites).</p>\r\n\r\n     * @param r1 first rotation\r\n\r\n     * @param r2 second rotation\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return <i>distance</i> between r1 and r2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance(const Field_Rotation<T> r1, const Field_Rotation<T> r2)\r\n\r\n    {\r\n\r\n        return r1.compose_inverse_internal(r2).get_angle();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Revert a rotation.\r\n\r\n     * Build a rotation which reverse the effect of another\r\n\r\n     * rotation. This means that if r(u) = v, then r.revert(v) = u. The\r\n\r\n     * instance is not changed.\r\n\r\n     * @return a rotation whose effect is the reverse of the effect\r\n\r\n     * of the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> revert() \r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(my_q_0.negate(), my_q_1, my_q_2, my_q_3, false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the scalar coordinate of the quaternion.\r\n\r\n     * @return scalar coordinate of the quaternion\r\n\r\n     */\r\n\r\n    T get_my_q_0() const\r\n\r\n    {\r\n\r\n        return my_q_0;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the first coordinate of the vectorial part of the quaternion.\r\n\r\n     * @return first coordinate of the vectorial part of the quaternion\r\n\r\n     */\r\n\r\n    T get_my_q_1() const\r\n\r\n    {\r\n\r\n        return my_q_1;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the second coordinate of the vectorial part of the quaternion.\r\n\r\n     * @return second coordinate of the vectorial part of the quaternion\r\n\r\n     */\r\n\r\n    T get_my_q_2() const\r\n\r\n    {\r\n\r\n        return my_q_2;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the third coordinate of the vectorial part of the quaternion.\r\n\r\n     * @return third coordinate of the vectorial part of the quaternion\r\n\r\n     */\r\n\r\n    T get_my_q_3() const\r\n\r\n    {\r\n\r\n        return my_q_3;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the normalized axis of the rotation.\r\n\r\n     * <p>\r\n\r\n     * Note that as {@link #get_angle()} always returns an angle\r\n\r\n     * between 0 and &pi;, changing the convention changes the\r\n\r\n     * direction of the axis, not the sign of the angle.\r\n\r\n     * </p>\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return normalized axis of the rotation\r\n\r\n     * @see #Field_Rotation(Field_Vector_3D, Calculus_Field_Element, Rotation_Convention)\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> get_axis(const Rotation_Convention convention) \r\n\r\n    {\r\n\r\n        const T squared_sine = my_q_1.multiply(my_q_1).add(my_q_2.multiply(my_q_2)).add(my_q_3.multiply(my_q_3));\r\n\r\n        if (squared_sine.get_real() == 0) \r\n\r\n        {\r\n\r\n            const Field<T> field = squared_sine.get_field();\r\n\r\n            return Field_Vector_3D<T>(convention == Rotation_Convention.VECTOR_OPERATOR ? field.get_one(): field.get_one().negate(), field.get_zero(), field.get_zero());\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            const double sgn = convention == Rotation_Convention.VECTOR_OPERATOR ? +1 : -1;\r\n\r\n            if (my_q_0.get_real() < 0) \r\n\r\n            {\r\n\r\n                T inverse = squared_sine.sqrt().reciprocal().multiply(sgn);\r\n\r\n                return Field_Vector_3D<T>(my_q_1.multiply(inverse), my_q_2.multiply(inverse), my_q_3.multiply(inverse));\r\n\r\n            }\r\n\r\n            const T inverse = squared_sine.sqrt().reciprocal().negate().multiply(sgn);\r\n\r\n            return Field_Vector_3D<T>(my_q_1.multiply(inverse), my_q_2.multiply(inverse), my_q_3.multiply(inverse));\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the angle of the rotation.\r\n\r\n     * @return angle of the rotation (between 0 and &pi;)\r\n\r\n     * @see #Field_Rotation(Field_Vector_3D, Calculus_Field_Element, Rotation_Convention)\r\n\r\n     */\r\n\r\n    T get_angle() \r\n\r\n    {\r\n\r\n        if ((my_q_0.get_real() < -0.1) || (my_q_0.get_real() > 0.1)) \r\n\r\n        {\r\n\r\n            return my_q_1.multiply(my_q_1).add(my_q_2.multiply(my_q_2)).add(my_q_3.multiply(my_q_3)).sqrt().asin().multiply(2);\r\n\r\n        }\r\n\r\n        else if (my_q_0.get_real() < 0) \r\n\r\n        {\r\n\r\n            return my_q_0.negate().acos().multiply(2);\r\n\r\n        }\r\n\r\n        return my_q_0.acos().multiply(2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the Cardan or Euler angles corresponding to the instance.\r\n\r\n\r\n\r\n     * <p>The equations show that each rotation can be defined by two\r\n\r\n     * different values of the Cardan or Euler angles set. For example\r\n\r\n     * if Cardan angles are used, the rotation defined by the angles\r\n\r\n     * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\r\n\r\n     * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\r\n\r\n     * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\r\n\r\n     * the following arbitrary choices:</p>\r\n\r\n     * <ul>\r\n\r\n     *   <li>for Cardan angles, the chosen set is the one for which the\r\n\r\n     *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\r\n\r\n     *   positive),</li>\r\n\r\n     *   <li>for Euler angles, the chosen set is the one for which the\r\n\r\n     *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\r\n\r\n     * </ul>\r\n\r\n\r\n\r\n     * <p>Cardan and Euler angle have a very disappointing drawback: all\r\n\r\n     * of them have singularities. This means that if the instance is\r\n\r\n     * too close to the singularities corresponding to the given\r\n\r\n     * rotation order, it will be impossible to retrieve the angles. For\r\n\r\n     * Cardan angles, this is often called gimbal lock. There is\r\n\r\n     * <em>nothing</em> to do to prevent this, it is an intrinsic problem\r\n\r\n     * with Cardan and Euler representation (but not a problem with the\r\n\r\n     * rotation itself, which is perfectly well defined). For Cardan\r\n\r\n     * angles, singularities occur when the second angle is close to\r\n\r\n     * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\r\n\r\n     * second angle is close to 0 or &pi;, this implies that the identity\r\n\r\n     * rotation is always singular for Euler angles!</p>\r\n\r\n\r\n\r\n     * @param order rotation order to use\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return an array of three angles, in the order specified by the set\r\n\r\n     * @exception Math_Illegal_State_Exception if the rotation is\r\n\r\n     * singular with respect to the angles set specified\r\n\r\n     */\r\n\r\n    std::vector<T> get_angles(const Rotation_Order order, Rotation_Convention convention)\r\n\r\n    {\r\n\r\n        if (convention == Rotation_Convention.VECTOR_OPERATOR) \r\n\r\n        {\r\n\r\n            if (order == Rotation_Order.XYZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+K) coordinates are :\r\n\r\n                //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\r\n\r\n                // (-r) (+I) coordinates are :\r\n\r\n                // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\r\n\r\n                const // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(vector(0, 0, 1));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(1, 0, 0));\r\n\r\n                if  ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_y().negate().atan2(v1.get_z()), v2.get_z().asin(), v2.get_y().negate().atan2(v2.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XZY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+J) coordinates are :\r\n\r\n                // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\r\n\r\n                // (-r) (+I) coordinates are :\r\n\r\n                // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\r\n\r\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 1, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(1, 0, 0));\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_z().atan2(v1.get_y()), v2.get_y().asin().negate(), v2.get_z().atan2(v2.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YXZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+K) coordinates are :\r\n\r\n                //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\r\n\r\n                // (-r) (+J) coordinates are :\r\n\r\n                // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\r\n\r\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 0, 1));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 1, 0));\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_x().atan2(v1.get_z()), v2.get_z().asin().negate(), v2.get_x().atan2(v2.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YZX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+I) coordinates are :\r\n\r\n                // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\r\n\r\n                // (-r) (+J) coordinates are :\r\n\r\n                // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\r\n\r\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(1, 0, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 1, 0));\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_z().negate().atan2(v1.get_x()), v2.get_x().asin(), v2.get_z().negate().atan2(v2.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZXY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+J) coordinates are :\r\n\r\n                // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\r\n\r\n                // (-r) (+K) coordinates are :\r\n\r\n                // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\r\n\r\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 1, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 0, 1));\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_x().negate().atan2(v1.get_y()), v2.get_y().asin(), v2.get_x().negate().atan2(v2.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZYX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+I) coordinates are :\r\n\r\n                //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\r\n\r\n                // (-r) (+K) coordinates are :\r\n\r\n                // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\r\n\r\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(1, 0, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 0, 1));\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_y().atan2(v1.get_x()), v2.get_x().asin().negate(), v2.get_y().atan2(v2.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XYX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+I) coordinates are :\r\n\r\n                //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\r\n\r\n                // (-r) (+I) coordinates are :\r\n\r\n                // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\r\n\r\n                // and we can choose to have theta in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(1, 0, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(1, 0, 0));\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_y().atan2(v1.get_z().negate()), v2.get_x().acos(), v2.get_y().atan2(v2.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XZX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+I) coordinates are :\r\n\r\n                //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\r\n\r\n                // (-r) (+I) coordinates are :\r\n\r\n                // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\r\n\r\n                // and we can choose to have psi in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(1, 0, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(1, 0, 0));\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_z().atan2(v1.get_y()), v2.get_x().acos(), v2.get_z().atan2(v2.get_y().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YXY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+J) coordinates are :\r\n\r\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\r\n\r\n                // (-r) (+J) coordinates are :\r\n\r\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\r\n\r\n                // and we can choose to have phi in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 1, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 1, 0));\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_x().atan2(v1.get_z()), v2.get_y().acos(), v2.get_x().atan2(v2.get_z().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YZY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+J) coordinates are :\r\n\r\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\r\n\r\n                // (-r) (+J) coordinates are :\r\n\r\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\r\n\r\n                // and we can choose to have psi in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 1, 0));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 1, 0));\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_z().atan2(v1.get_x().negate()), v2.get_y().acos(), v2.get_z().atan2(v2.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZXZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (+K) coordinates are :\r\n\r\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\r\n\r\n                // (-r) (+K) coordinates are :\r\n\r\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\r\n\r\n                // and we can choose to have phi in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 0, 1));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 0, 1));\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_x().atan2(v1.get_y().negate()), v2.get_z().acos(), v2.get_x().atan2(v2.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else \r\n\r\n            { // last possibility is ZYZ\r\n\r\n\r\n\r\n                // r (+K) coordinates are :\r\n\r\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\r\n\r\n                // (-r) (+K) coordinates are :\r\n\r\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\r\n\r\n                // and we can choose to have theta in the interval [0 ; PI]\r\n\r\n                const Field_Vector_3D<T> v1 = apply_to(vector(0, 0, 1));\r\n\r\n                const Field_Vector_3D<T> v2 = apply_inverse_to(vector(0, 0, 1));\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v1.get_y().atan2(v1.get_x()), v2.get_z().acos(), v2.get_y().atan2(v2.get_x().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n        else \r\n\r\n        {\r\n\r\n            if (order == Rotation_Order.XYZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_i) coordinates are :\r\n\r\n                //  cos (theta) cos (psi), -cos (theta) sin (psi), sin (theta)\r\n\r\n                // (-r) (Vector_3D.plus_k) coordinates are :\r\n\r\n                // sin (theta), -sin (phi) cos (theta), cos (phi) cos (theta)\r\n\r\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_I);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_K);\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_y().negate().atan2(v2.get_z()), v2.get_x().asin(), v1.get_y().negate().atan2(v1.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XZY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_i) coordinates are :\r\n\r\n                // cos (psi) cos (theta), -sin (psi), cos (psi) sin (theta)\r\n\r\n                // (-r) (Vector_3D.plus_j) coordinates are :\r\n\r\n                // -sin (psi), cos (phi) cos (psi), sin (phi) cos (psi)\r\n\r\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_I);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_J);\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_z().atan2(v2.get_y()), v2.get_x().asin().negate(), v1.get_z().atan2(v1.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YXZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_j) coordinates are :\r\n\r\n                // cos (phi) sin (psi), cos (phi) cos (psi), -sin (phi)\r\n\r\n                // (-r) (Vector_3D.plus_k) coordinates are :\r\n\r\n                // sin (theta) cos (phi), -sin (phi), cos (theta) cos (phi)\r\n\r\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_J);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_K);\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_x().atan2(v2.get_z()), v2.get_y().asin().negate(), v1.get_x().atan2(v1.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YZX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_j) coordinates are :\r\n\r\n                // sin (psi), cos (psi) cos (phi), -cos (psi) sin (phi)\r\n\r\n                // (-r) (Vector_3D.plus_i) coordinates are :\r\n\r\n                // cos (theta) cos (psi), sin (psi), -sin (theta) cos (psi)\r\n\r\n                // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_J);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_I);\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_z().negate().atan2(v2.get_x()), v2.get_y().asin(), v1.get_z().negate().atan2(v1.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZXY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_k) coordinates are :\r\n\r\n                //  -cos (phi) sin (theta), sin (phi), cos (phi) cos (theta)\r\n\r\n                // (-r) (Vector_3D.plus_j) coordinates are :\r\n\r\n                // -sin (psi) cos (phi), cos (psi) cos (phi), sin (phi)\r\n\r\n                // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_K);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_J);\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_x().negate().atan2(v2.get_y()), v2.get_z().asin(), v1.get_x().negate().atan2(v1.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZYX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_k) coordinates are :\r\n\r\n                //  -sin (theta), cos (theta) sin (phi), cos (theta) cos (phi)\r\n\r\n                // (-r) (Vector_3D.plus_i) coordinates are :\r\n\r\n                // cos (psi) cos (theta), sin (psi) cos (theta), -sin (theta)\r\n\r\n                // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_K);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_I);\r\n\r\n                if  ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.CARDAN_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_y().atan2(v2.get_x()), v2.get_z().asin().negate(), v1.get_y().atan2(v1.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XYX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_i) coordinates are :\r\n\r\n                //  cos (theta), sin (phi2) sin (theta), cos (phi2) sin (theta)\r\n\r\n                // (-r) (Vector_3D.plus_i) coordinates are :\r\n\r\n                // cos (theta), sin (theta) sin (phi1), -sin (theta) cos (phi1)\r\n\r\n                // and we can choose to have theta in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_I);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_I);\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_y().atan2(v2.get_z().negate()), v2.get_x().acos(), v1.get_y().atan2(v1.get_z()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.XZX) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_i) coordinates are :\r\n\r\n                //  cos (psi), -cos (phi2) sin (psi), sin (phi2) sin (psi)\r\n\r\n                // (-r) (Vector_3D.plus_i) coordinates are :\r\n\r\n                // cos (psi), sin (psi) cos (phi1), sin (psi) sin (phi1)\r\n\r\n                // and we can choose to have psi in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_I);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_I);\r\n\r\n                if ((v2.get_x().get_real() < -0.9999999999) || (v2.get_x().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_z().atan2(v2.get_y()), v2.get_x().acos(), v1.get_z().atan2(v1.get_y().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YXY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_j) coordinates are :\r\n\r\n                // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\r\n\r\n                // (-r) (Vector_3D.plus_j) coordinates are :\r\n\r\n                //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\r\n\r\n                // and we can choose to have phi in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_J);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_J);\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_x().atan2(v2.get_z()), v2.get_y().acos(), v1.get_x().atan2(v1.get_z().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.YZY) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_j) coordinates are :\r\n\r\n                // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\r\n\r\n                // (-r) (Vector_3D.plus_j) coordinates are :\r\n\r\n                //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\r\n\r\n                // and we can choose to have psi in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_J);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_J);\r\n\r\n                if ((v2.get_y().get_real() < -0.9999999999) || (v2.get_y().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_z().atan2(v2.get_x().negate()), v2.get_y().acos(), v1.get_z().atan2(v1.get_x()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else if (order == Rotation_Order.ZXZ) \r\n\r\n            {\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_k) coordinates are :\r\n\r\n                // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\r\n\r\n                // (-r) (Vector_3D.plus_k) coordinates are :\r\n\r\n                //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\r\n\r\n                // and we can choose to have phi in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_K);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_K);\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_x().atan2(v2.get_y().negate()), v2.get_z().acos(), v1.get_x().atan2(v1.get_y()));\r\n\r\n\r\n\r\n            }\r\n\r\n            else\r\n\r\n            { // last possibility is ZYZ\r\n\r\n\r\n\r\n                // r (Vector_3D.plus_k) coordinates are :\r\n\r\n                // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\r\n\r\n                // (-r) (Vector_3D.plus_k) coordinates are :\r\n\r\n                //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\r\n\r\n                // and we can choose to have theta in the interval [0 ; PI]\r\n\r\n                Field_Vector_3D<T> v1 = apply_to(Vector_3D.PLUS_K);\r\n\r\n                Field_Vector_3D<T> v2 = apply_inverse_to(Vector_3D.PLUS_K);\r\n\r\n                if ((v2.get_z().get_real() < -0.9999999999) || (v2.get_z().get_real() > 0.9999999999)) \r\n\r\n                {\r\n\r\n                    throw Math_Illegal_State_Exception(Localized_Geometry_Formats.EULER_ANGLES_SINGULARITY);\r\n\r\n                }\r\n\r\n                return build_array(v2.get_y().atan2(v2.get_x()), v2.get_z().acos(), v1.get_y().atan2(v1.get_x().negate()));\r\n\r\n\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the 3X3 matrix corresponding to the instance\r\n\r\n     * @return the matrix corresponding to the instance\r\n\r\n     */\r\n\r\n    std::vector<std::vector<T>> get_matrix()\r\n\r\n    {\r\n\r\n        // products\r\n\r\n        const T my_q_0my_q_0 = my_q_0.multiply(my_q_0);\r\n\r\n        const T my_q_0my_q_1 = my_q_0.multiply(my_q_1);\r\n\r\n        const T my_q_0my_q_2 = my_q_0.multiply(my_q_2);\r\n\r\n        const T my_q_0my_q_3 = my_q_0.multiply(my_q_3);\r\n\r\n        const T my_q_1my_q_1 = my_q_1.multiply(my_q_1);\r\n\r\n        const T my_q_1my_q_2 = my_q_1.multiply(my_q_2);\r\n\r\n        const T my_q_1my_q_3 = my_q_1.multiply(my_q_3);\r\n\r\n        const T my_q_2my_q_2 = my_q_2.multiply(my_q_2);\r\n\r\n        const T my_q_2my_q_3 = my_q_2.multiply(my_q_3);\r\n\r\n        const T my_q_3my_q_3 = my_q_3.multiply(my_q_3);\r\n\r\n\r\n\r\n        // create the matrix\r\n\r\n        const std::vector<std::vector<T>> m = Math_Arrays::build_array(my_q_0.get_field(), 3, 3);\r\n\r\n\r\n\r\n        m[0][0] = my_q_0my_q_0.add(my_q_1my_q_1).multiply(2).subtract(1);\r\n\r\n        m[1][0] = my_q_1my_q_2.subtract(my_q_0my_q_3).multiply(2);\r\n\r\n        m[2][0] = my_q_1my_q_3.add(my_q_0my_q_2).multiply(2);\r\n\r\n\r\n\r\n        m[0][1] = my_q_1my_q_2.add(my_q_0my_q_3).multiply(2);\r\n\r\n        m[1][1] = my_q_0my_q_0.add(my_q_2my_q_2).multiply(2).subtract(1);\r\n\r\n        m[2][1] = my_q_2my_q_3.subtract(my_q_0my_q_1).multiply(2);\r\n\r\n\r\n\r\n        m[0][2] = my_q_1my_q_3.subtract(my_q_0my_q_2).multiply(2);\r\n\r\n        m[1][2] = my_q_2my_q_3.add(my_q_0my_q_1).multiply(2);\r\n\r\n        m[2][2] = my_q_0my_q_0.add(my_q_3my_q_3).multiply(2).subtract(1);\r\n\r\n\r\n\r\n        return m;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Convert to a constant vector without derivatives.\r\n\r\n     * @return a constant vector\r\n\r\n     */\r\n\r\n    Rotation to_rotation()\r\n\r\n    {\r\n\r\n        return Rotation(my_q_0.get_real(), my_q_1.get_real(), my_q_2.get_real(), my_q_3.get_real(), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the rotation to a vector.\r\n\r\n     * @param u vector to apply the rotation to\r\n\r\n     * @return a vector which is the image of u by the rotation\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> apply_to(const Field_Vector_3D<T> u)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = u.get_x();\r\n\r\n        const T y = u.get_y();\r\n\r\n        const T z = u.get_z();\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(my_q_0.multiply(x.multiply(my_q_0).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x), my_q_0.multiply(y.multiply(my_q_0).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y), my_q_0.multiply(z.multiply(my_q_0).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the rotation to a vector.\r\n\r\n     * @param u vector to apply the rotation to\r\n\r\n     * @return a vector which is the image of u by the rotation\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> apply_to(const Vector_3D& u)\r\n\r\n    {\r\n\r\n        const double x = u.get_x();\r\n\r\n        const double y = u.get_y();\r\n\r\n        const double z = u.get_z();\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(my_q_0.multiply(my_q_0.multiply(x).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x), my_q_0.multiply(my_q_0.multiply(y).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y), my_q_0.multiply(my_q_0.multiply(z).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the rotation to a vector stored in an array.\r\n\r\n     * @param in an array with three items which stores vector to rotate\r\n\r\n     * @param out an array with three items to put result to (it can be the same\r\n\r\n     * array as in)\r\n\r\n     */\r\n\r\n    void apply_to(const std::vector<T> in, const std::vector<T> out)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = in[0];\r\n\r\n        const T y = in[1];\r\n\r\n        const T z = in[2];\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n\r\n\r\n        out[0] = my_q_0.multiply(x.multiply(my_q_0).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x);\r\n\r\n        out[1] = my_q_0.multiply(y.multiply(my_q_0).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y);\r\n\r\n        out[2] = my_q_0.multiply(z.multiply(my_q_0).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the rotation to a vector stored in an array.\r\n\r\n     * @param in an array with three items which stores vector to rotate\r\n\r\n     * @param out an array with three items to put result to\r\n\r\n     */\r\n\r\n    void apply_to(const std::vector<double> in, const std::vector<T> out)\r\n\r\n    {\r\n\r\n\r\n\r\n        const double x = in[0];\r\n\r\n        const double y = in[1];\r\n\r\n        const double z = in[2];\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n\r\n\r\n        out[0] = my_q_0.multiply(my_q_0.multiply(x).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x);\r\n\r\n        out[1] = my_q_0.multiply(my_q_0.multiply(y).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y);\r\n\r\n        out[2] = my_q_0.multiply(my_q_0.multiply(z).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply a rotation to a vector.\r\n\r\n     * @param r rotation to apply\r\n\r\n     * @param u vector to apply the rotation to\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a vector which is the image of u by the rotation\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> apply_to(const Rotation r, const Field_Vector_3D<T> u)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = u.get_x();\r\n\r\n        const T y = u.get_y();\r\n\r\n        const T z = u.get_z();\r\n\r\n\r\n\r\n        const T s = x.multiply(r.get_my_q_1()).add(y.multiply(r.get_my_q_2())).add(z.multiply(r.get_my_q_3()));\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(x.multiply(r.get_my_q_0()).subtract(z.multiply(r.get_my_q_2()).subtract(y.multiply(r.get_my_q_3()))).multiply(r.get_my_q_0()).add(s.multiply(r.get_my_q_1())).multiply(2).subtract(x), y.multiply(r.get_my_q_0()).subtract(x.multiply(r.get_my_q_3()).subtract(z.multiply(r.get_my_q_1()))).multiply(r.get_my_q_0()).add(s.multiply(r.get_my_q_2())).multiply(2).subtract(y), z.multiply(r.get_my_q_0()).subtract(y.multiply(r.get_my_q_1()).subtract(x.multiply(r.get_my_q_2()))).multiply(r.get_my_q_0()).add(s.multiply(r.get_my_q_3())).multiply(2).subtract(z));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the rotation to a vector.\r\n\r\n     * @param u vector to apply the inverse of the rotation to\r\n\r\n     * @return a vector which such that u is its image by the rotation\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> apply_inverse_to(const Field_Vector_3D<T> u)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = u.get_x();\r\n\r\n        const T y = u.get_y();\r\n\r\n        const T z = u.get_z();\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n        const T m0 = my_q_0.negate();\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(m0.multiply(x.multiply(m0).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x), m0.multiply(y.multiply(m0).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y), m0.multiply(z.multiply(m0).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the rotation to a vector.\r\n\r\n     * @param u vector to apply the inverse of the rotation to\r\n\r\n     * @return a vector which such that u is its image by the rotation\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> apply_inverse_to(const Vector_3D& u)\r\n\r\n    {\r\n\r\n\r\n\r\n        const double x = u.get_x();\r\n\r\n        const double y = u.get_y();\r\n\r\n        const double z = u.get_z();\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n        const T m0 = my_q_0.negate();\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(m0.multiply(m0.multiply(x).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x), m0.multiply(m0.multiply(y).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y), m0.multiply(m0.multiply(z).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z));\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the rotation to a vector stored in an array.\r\n\r\n     * @param in an array with three items which stores vector to rotate\r\n\r\n     * @param out an array with three items to put result to (it can be the same\r\n\r\n     * array as in)\r\n\r\n     */\r\n\r\n    void apply_inverse_to(const std::vector<T> in, const std::vector<T> out)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = in[0];\r\n\r\n        const T y = in[1];\r\n\r\n        const T z = in[2];\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n        const T m0 = my_q_0.negate();\r\n\r\n\r\n\r\n        out[0] = m0.multiply(x.multiply(m0).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x);\r\n\r\n        out[1] = m0.multiply(y.multiply(m0).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y);\r\n\r\n        out[2] = m0.multiply(z.multiply(m0).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of the rotation to a vector stored in an array.\r\n\r\n     * @param in an array with three items which stores vector to rotate\r\n\r\n     * @param out an array with three items to put result to\r\n\r\n     */\r\n\r\n    void apply_inverse_to(const std::vector<double> in, const std::vector<T> out)\r\n\r\n    {\r\n\r\n\r\n\r\n        const double x = in[0];\r\n\r\n        const double y = in[1];\r\n\r\n        const double z = in[2];\r\n\r\n\r\n\r\n        const T s = my_q_1.multiply(x).add(my_q_2.multiply(y)).add(my_q_3.multiply(z));\r\n\r\n        const T m0 = my_q_0.negate();\r\n\r\n\r\n\r\n        out[0] = m0.multiply(m0.multiply(x).subtract(my_q_2.multiply(z).subtract(my_q_3.multiply(y)))).add(s.multiply(my_q_1)).multiply(2).subtract(x);\r\n\r\n        out[1] = m0.multiply(m0.multiply(y).subtract(my_q_3.multiply(x).subtract(my_q_1.multiply(z)))).add(s.multiply(my_q_2)).multiply(2).subtract(y);\r\n\r\n        out[2] = m0.multiply(m0.multiply(z).subtract(my_q_1.multiply(y).subtract(my_q_2.multiply(x)))).add(s.multiply(my_q_3)).multiply(2).subtract(z);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the inverse of a rotation to a vector.\r\n\r\n     * @param r rotation to apply\r\n\r\n     * @param u vector to apply the inverse of the rotation to\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return a vector which such that u is its image by the rotation\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> apply_inverse_to(const Rotation r, const Field_Vector_3D<T> u)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T x = u.get_x();\r\n\r\n        const T y = u.get_y();\r\n\r\n        const T z = u.get_z();\r\n\r\n\r\n\r\n        const T s = x.multiply(r.get_my_q_1()).add(y.multiply(r.get_my_q_2())).add(z.multiply(r.get_my_q_3()));\r\n\r\n        const double m0 = -r.get_my_q_0();\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(x.multiply(m0).subtract(z.multiply(r.get_my_q_2()).subtract(y.multiply(r.get_my_q_3()))).multiply(m0).add(s.multiply(r.get_my_q_1())).multiply(2).subtract(x), y.multiply(m0).subtract(x.multiply(r.get_my_q_3()).subtract(z.multiply(r.get_my_q_1()))).multiply(m0).add(s.multiply(r.get_my_q_2())).multiply(2).subtract(y), z.multiply(m0).subtract(y.multiply(r.get_my_q_1()).subtract(x.multiply(r.get_my_q_2()))).multiply(m0).add(s.multiply(r.get_my_q_3())).multiply(2).subtract(z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Apply the instance to another rotation.\r\n\r\n     * <p>\r\n\r\n     * Calling this method is equivalent to call\r\n\r\n     * {@link #compose(Field_Rotation, Rotation_Convention)\r\n\r\n     * compose(r, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> apply_to(const Field_Rotation<T> r)\r\n\r\n    {\r\n\r\n        return compose(r, Rotation_Convention.VECTOR_OPERATOR);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the instance with another rotation.\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#VECTOR_OPERATOR vector operator} convention, * applying the instance to a rotation is computing the composition\r\n\r\n     * in an order compliant with the following rule : let {@code u} be any\r\n\r\n     * vector and {@code v} its image by {@code r1} (i.e.\r\n\r\n     * {@code r1.apply_to(u) = v}). Let {@code w} be the image of {@code v} by\r\n\r\n     * rotation {@code r2} (i.e. {@code r2.apply_to(v) = w}). Then\r\n\r\n     * {@code w = comp.apply_to(u)}, where\r\n\r\n     * {@code comp = r2.compose(r1, Rotation_Convention.VECTOR_OPERATOR)}.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * If the semantics of the rotations composition corresponds to a\r\n\r\n     * {@link Rotation_Convention#FRAME_TRANSFORM frame transform} convention, * the application order will be reversed. So keeping the exact same\r\n\r\n     * meaning of all {@code r1}, {@code r2}, {@code u}, {@code v}, {@code w}\r\n\r\n     * and  {@code comp} as above, {@code comp} could also be computed as\r\n\r\n     * {@code comp = r1.compose(r2, Rotation_Convention.FRAME_TRANSFORM)}.\r\n\r\n     * </p>\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @param convention convention to use for the semantics of the angle\r\n\r\n     * @return a rotation which is the composition of r by the instance\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose(const Field_Rotation<T> r, const Rotation_Convention convention)\r\n\r\n    {\r\n\r\n        return convention == Rotation_Convention.VECTOR_OPERATOR\r\n\r\n            ? compose_internal(r)\r\n\r\n            : r.compose_internal(this);\r\n\r\n    }\r\n\r\n\r\n\r\nprivate:\r\n\r\n\r\n\r\n    /** Convert an orthogonal rotation matrix to a quaternion.\r\n\r\n     * @param ort orthogonal rotation matrix\r\n\r\n     * @return quaternion corresponding to the matrix\r\n\r\n     */\r\n\r\n    std::vector<T> mat2quat(const std::vector<std::vector<T>> ort)\r\n\r\n    {\r\n\r\n\r\n\r\n        const std::vector<T> quat = Math_Arrays::build_array(ort[0][0].get_field(), 4);\r\n\r\n\r\n\r\n        // There are different ways to compute the quaternions elements\r\n\r\n        // from the matrix. They all involve computing one element from\r\n\r\n        // the diagonal of the matrix, and computing the three other ones\r\n\r\n        // using a formula involving a division by the first element, // which unfortunately can be zero. sin_ce the norm of the\r\n\r\n        // quaternion is 1, we know at least one element has an absolute\r\n\r\n        // value greater or equal to 0.5, so it is always possible to\r\n\r\n        // select the right formula and avoid division by zero and even\r\n\r\n        // numerical inaccuracy. Checking the elements in turn and using\r\n\r\n        // the first one greater than 0.45 is safe (this leads to a simple\r\n\r\n        // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\r\n\r\n        T s = ort[0][0].add(ort[1][1]).add(ort[2][2]);\r\n\r\n        if (s.get_real() > -0.19)\r\n\r\n        {\r\n\r\n            // compute my_q_0 and deduce my_q_1, my_q_2 and my_q_3\r\n\r\n            quat[0] = s.add(1.0).sqrt().multiply(0.5);\r\n\r\n            T inv = quat[0].reciprocal().multiply(0.25);\r\n\r\n            quat[1] = inv.multiply(ort[1][2].subtract(ort[2][1]));\r\n\r\n            quat[2] = inv.multiply(ort[2][0].subtract(ort[0][2]));\r\n\r\n            quat[3] = inv.multiply(ort[0][1].subtract(ort[1][0]));\r\n\r\n        }\r\n\r\n        else\r\n\r\n        {\r\n\r\n            s = ort[0][0].subtract(ort[1][1]).subtract(ort[2][2]);\r\n\r\n            if (s.get_real() > -0.19)\r\n\r\n            {\r\n\r\n                // compute my_q_1 and deduce my_q_0, my_q_2 and my_q_3\r\n\r\n                quat[1] = s.add(1.0).sqrt().multiply(0.5);\r\n\r\n                T inv = quat[1].reciprocal().multiply(0.25);\r\n\r\n                quat[0] = inv.multiply(ort[1][2].subtract(ort[2][1]));\r\n\r\n                quat[2] = inv.multiply(ort[0][1].add(ort[1][0]));\r\n\r\n                quat[3] = inv.multiply(ort[0][2].add(ort[2][0]));\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                s = ort[1][1].subtract(ort[0][0]).subtract(ort[2][2]);\r\n\r\n                if (s.get_real() > -0.19)\r\n\r\n                {\r\n\r\n                    // compute my_q_2 and deduce my_q_0, my_q_1 and my_q_3\r\n\r\n                    quat[2] = s.add(1.0).sqrt().multiply(0.5);\r\n\r\n                    T inv = quat[2].reciprocal().multiply(0.25);\r\n\r\n                    quat[0] = inv.multiply(ort[2][0].subtract(ort[0][2]));\r\n\r\n                    quat[1] = inv.multiply(ort[0][1].add(ort[1][0]));\r\n\r\n                    quat[3] = inv.multiply(ort[2][1].add(ort[1][2]));\r\n\r\n                }\r\n\r\n                else\r\n\r\n                {\r\n\r\n                    // compute my_q_3 and deduce my_q_0, my_q_1 and my_q_2\r\n\r\n                    s = ort[2][2].subtract(ort[0][0]).subtract(ort[1][1]);\r\n\r\n                    quat[3] = s.add(1.0).sqrt().multiply(0.5);\r\n\r\n                    T inv = quat[3].reciprocal().multiply(0.25);\r\n\r\n                    quat[0] = inv.multiply(ort[0][1].subtract(ort[1][0]));\r\n\r\n                    quat[1] = inv.multiply(ort[0][2].add(ort[2][0]));\r\n\r\n                    quat[2] = inv.multiply(ort[2][1].add(ort[1][2]));\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        return quat;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create a dimension 3 array.\r\n\r\n     * @param a0 first array element\r\n\r\n     * @param a1 second array element\r\n\r\n     * @param a2 third array element\r\n\r\n     * @return array\r\n\r\n     */\r\n\r\n    std::vector<T> build_array(const T a0, const T a1, const T a2) \r\n\r\n    {\r\n\r\n        const std::vector<T> array = Math_Arrays::build_array(a0.get_field(), 3);\r\n\r\n        array[0] = a0;\r\n\r\n        array[1] = a1;\r\n\r\n        array[2] = a2;\r\n\r\n        return array;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Create a constant vector.\r\n\r\n     * @param x abscissa\r\n\r\n     * @param y ordinate\r\n\r\n     * @param z height\r\n\r\n     * @return a constant vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> vector(const double& x, const double& y, const double& z) \r\n\r\n    {\r\n\r\n        const T zero = my_q_0.get_field().get_zero();\r\n\r\n        return Field_Vector_3D<T>(zero.add(x), zero.add(y), zero.add(z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the instance with another rotation using vector operator convention.\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the instance\r\n\r\n     * using vector operator convention\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_internal(const Field_Rotation<T> r) \r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(r.my_q_0.multiply(my_q_0).subtract(r.my_q_1.multiply(my_q_1).add(r.my_q_2.multiply(my_q_2)).add(r.my_q_3.multiply(my_q_3))), r.my_q_1.multiply(my_q_0).add(r.my_q_0.multiply(my_q_1)).add(r.my_q_2.multiply(my_q_3).subtract(r.my_q_3.multiply(my_q_2))), r.my_q_2.multiply(my_q_0).add(r.my_q_0.multiply(my_q_2)).add(r.my_q_3.multiply(my_q_1).subtract(r.my_q_1.multiply(my_q_3))), r.my_q_3.multiply(my_q_0).add(r.my_q_0.multiply(my_q_3)).add(r.my_q_1.multiply(my_q_2).subtract(r.my_q_2.multiply(my_q_1))), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the instance with another rotation using vector operator convention.\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the instance\r\n\r\n     * using vector operator convention\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_internal(const Rotation r) \r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(my_q_0.multiply(r.get_my_q_0()).subtract(my_q_1.multiply(r.get_my_q_1()).add(my_q_2.multiply(r.get_my_q_2())).add(my_q_3.multiply(r.get_my_q_3()))), my_q_0.multiply(r.get_my_q_1()).add(my_q_1.multiply(r.get_my_q_0())).add(my_q_3.multiply(r.get_my_q_2()).subtract(my_q_2.multiply(r.get_my_q_3()))), my_q_0.multiply(r.get_my_q_2()).add(my_q_2.multiply(r.get_my_q_0())).add(my_q_1.multiply(r.get_my_q_3()).subtract(my_q_3.multiply(r.get_my_q_1()))), my_q_0.multiply(r.get_my_q_3()).add(my_q_3.multiply(r.get_my_q_0())).add(my_q_2.multiply(r.get_my_q_1()).subtract(my_q_1.multiply(r.get_my_q_2()))), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the inverse of the instance with another rotation\r\n\r\n     * using vector operator convention.\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance using vector operator convention\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_inverse_internal(Field_Rotation<T> r) \r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(r.my_q_0.multiply(my_q_0).add(r.my_q_1.multiply(my_q_1).add(r.my_q_2.multiply(my_q_2)).add(r.my_q_3.multiply(my_q_3))).negate(), r.my_q_0.multiply(my_q_1).add(r.my_q_2.multiply(my_q_3).subtract(r.my_q_3.multiply(my_q_2))).subtract(r.my_q_1.multiply(my_q_0)), r.my_q_0.multiply(my_q_2).add(r.my_q_3.multiply(my_q_1).subtract(r.my_q_1.multiply(my_q_3))).subtract(r.my_q_2.multiply(my_q_0)), r.my_q_0.multiply(my_q_3).add(r.my_q_1.multiply(my_q_2).subtract(r.my_q_2.multiply(my_q_1))).subtract(r.my_q_3.multiply(my_q_0)), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compose the inverse of the instance with another rotation\r\n\r\n     * using vector operator convention.\r\n\r\n     * @param r rotation to apply the rotation to\r\n\r\n     * @return a rotation which is the composition of r by the inverse\r\n\r\n     * of the instance using vector operator convention\r\n\r\n     */\r\n\r\n    Field_Rotation<T> compose_inverse_internal(Rotation& r) \r\n\r\n    {\r\n\r\n        return Field_Rotation<T>(my_q_0.multiply(r.get_my_q_0()).add(my_q_1.multiply(r.get_my_q_1()).add(my_q_2.multiply(r.get_my_q_2())).add(my_q_3.multiply(r.get_my_q_3()))).negate(), my_q_1.multiply(r.get_my_q_0()).add(my_q_3.multiply(r.get_my_q_2()).subtract(my_q_2.multiply(r.get_my_q_3()))).subtract(my_q_0.multiply(r.get_my_q_1())), my_q_2.multiply(r.get_my_q_0()).add(my_q_1.multiply(r.get_my_q_3()).subtract(my_q_3.multiply(r.get_my_q_1()))).subtract(my_q_0.multiply(r.get_my_q_2())), my_q_3.multiply(r.get_my_q_0()).add(my_q_2.multiply(r.get_my_q_1()).subtract(my_q_1.multiply(r.get_my_q_2()))).subtract(my_q_0.multiply(r.get_my_q_3())), false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Perfect orthogonality on a 3X3 matrix.\r\n\r\n     * @param m initial matrix (not exactly orthogonal)\r\n\r\n     * @param threshold convergence threshold for the iterative\r\n\r\n     * orthogonality correction (convergence is reached when the\r\n\r\n     * difference between two steps of the Frobenius norm of the\r\n\r\n     * correction is below this threshold)\r\n\r\n     * @return an orthogonal matrix close to m\r\n\r\n     * @exception  if the matrix cannot be\r\n\r\n     * orthogonalized with the given threshold after 10 iterations\r\n\r\n     */\r\n\r\n    std::vector<std::vector<T>> orthogonalize_matrix(const std::vector<std::vector<T>>& m, const double& threshold)\r\n\r\n    {\r\n\r\n        T x00 = m[0][0];\r\n\r\n        T x01 = m[0][1];\r\n\r\n        T x02 = m[0][2];\r\n\r\n        T x10 = m[1][0];\r\n\r\n        T x11 = m[1][1];\r\n\r\n        T x12 = m[1][2];\r\n\r\n        T x20 = m[2][0];\r\n\r\n        T x21 = m[2][1];\r\n\r\n        T x22 = m[2][2];\r\n\r\n        double fn{};\r\n\r\n        double fn1;\r\n\r\n\r\n\r\n        const std::vector<std::vector<T>> o = Math_Arrays::build_array(m[0][0].get_field(), 3, 3);\r\n\r\n\r\n\r\n        // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\r\n\r\n        int i;\r\n\r\n        for (i = 0; i < 11; ++i) \r\n\r\n        {\r\n\r\n\r\n\r\n            // Mt.Xn\r\n\r\n            const T mx00 = m[0][0].multiply(x00).add(m[1][0].multiply(x10)).add(m[2][0].multiply(x20));\r\n\r\n            const T mx10 = m[0][1].multiply(x00).add(m[1][1].multiply(x10)).add(m[2][1].multiply(x20));\r\n\r\n            const T mx20 = m[0][2].multiply(x00).add(m[1][2].multiply(x10)).add(m[2][2].multiply(x20));\r\n\r\n            const T mx01 = m[0][0].multiply(x01).add(m[1][0].multiply(x11)).add(m[2][0].multiply(x21));\r\n\r\n            const T mx11 = m[0][1].multiply(x01).add(m[1][1].multiply(x11)).add(m[2][1].multiply(x21));\r\n\r\n            const T mx21 = m[0][2].multiply(x01).add(m[1][2].multiply(x11)).add(m[2][2].multiply(x21));\r\n\r\n            const T mx02 = m[0][0].multiply(x02).add(m[1][0].multiply(x12)).add(m[2][0].multiply(x22));\r\n\r\n            const T mx12 = m[0][1].multiply(x02).add(m[1][1].multiply(x12)).add(m[2][1].multiply(x22));\r\n\r\n            const T mx22 = m[0][2].multiply(x02).add(m[1][2].multiply(x12)).add(m[2][2].multiply(x22));\r\n\r\n\r\n\r\n            // Xn+1\r\n\r\n            o[0][0] = x00.subtract(x00.multiply(mx00).add(x01.multiply(mx10)).add(x02.multiply(mx20)).subtract(m[0][0]).multiply(0.5));\r\n\r\n            o[0][1] = x01.subtract(x00.multiply(mx01).add(x01.multiply(mx11)).add(x02.multiply(mx21)).subtract(m[0][1]).multiply(0.5));\r\n\r\n            o[0][2] = x02.subtract(x00.multiply(mx02).add(x01.multiply(mx12)).add(x02.multiply(mx22)).subtract(m[0][2]).multiply(0.5));\r\n\r\n            o[1][0] = x10.subtract(x10.multiply(mx00).add(x11.multiply(mx10)).add(x12.multiply(mx20)).subtract(m[1][0]).multiply(0.5));\r\n\r\n            o[1][1] = x11.subtract(x10.multiply(mx01).add(x11.multiply(mx11)).add(x12.multiply(mx21)).subtract(m[1][1]).multiply(0.5));\r\n\r\n            o[1][2] = x12.subtract(x10.multiply(mx02).add(x11.multiply(mx12)).add(x12.multiply(mx22)).subtract(m[1][2]).multiply(0.5));\r\n\r\n            o[2][0] = x20.subtract(x20.multiply(mx00).add(x21.multiply(mx10)).add(x22.multiply(mx20)).subtract(m[2][0]).multiply(0.5));\r\n\r\n            o[2][1] = x21.subtract(x20.multiply(mx01).add(x21.multiply(mx11)).add(x22.multiply(mx21)).subtract(m[2][1]).multiply(0.5));\r\n\r\n            o[2][2] = x22.subtract(x20.multiply(mx02).add(x21.multiply(mx12)).add(x22.multiply(mx22)).subtract(m[2][2]).multiply(0.5));\r\n\r\n\r\n\r\n            // correction on each elements\r\n\r\n            const double corr00 = o[0][0].get_real() - m[0][0].get_real();\r\n\r\n            const double corr01 = o[0][1].get_real() - m[0][1].get_real();\r\n\r\n            const double corr02 = o[0][2].get_real() - m[0][2].get_real();\r\n\r\n            const double corr10 = o[1][0].get_real() - m[1][0].get_real();\r\n\r\n            const double corr11 = o[1][1].get_real() - m[1][1].get_real();\r\n\r\n            const double corr12 = o[1][2].get_real() - m[1][2].get_real();\r\n\r\n            const double corr20 = o[2][0].get_real() - m[2][0].get_real();\r\n\r\n            const double corr21 = o[2][1].get_real() - m[2][1].get_real();\r\n\r\n            const double corr22 = o[2][2].get_real() - m[2][2].get_real();\r\n\r\n\r\n\r\n            // Frobenius norm of the correction\r\n\r\n            fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\r\n\r\n                  corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\r\n\r\n                  corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\r\n\r\n\r\n\r\n            // convergence test\r\n\r\n            if (std::abs(fn1 - fn) <= threshold) \r\n\r\n            {\r\n\r\n                return o;\r\n\r\n            }\r\n\r\n\r\n\r\n            // prepare next iteration\r\n\r\n            x00 = o[0][0];\r\n\r\n            x01 = o[0][1];\r\n\r\n            x02 = o[0][2];\r\n\r\n            x10 = o[1][0];\r\n\r\n            x11 = o[1][1];\r\n\r\n            x12 = o[1][2];\r\n\r\n            x20 = o[2][0];\r\n\r\n            x21 = o[2][1];\r\n\r\n            x22 = o[2][2];\r\n\r\n            fn  = fn1;\r\n\r\n        }\r\n\r\n        // the algorithm did not converge after 10 iterations\r\n\r\n        throw (Localized_Geometry_Formats.UNABLE_TO_ORTHOGONOLIZE_MATRIX, i - 1);\r\n\r\n    }\r\n\r\n};\r\n