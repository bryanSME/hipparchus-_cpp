/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n\r\n\r\n//package org.hipparchus.geometry.euclidean.threed;\r\n\r\n\r\n\r\n//import java.io.Serializable;\r\n\r\n//import java.text.Number_Format;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.Field;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.exception.Math_Runtime_Exception;\r\n\r\n//import org.hipparchus.geometry.Localized_Geometry_Formats;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Field_Sin_Cos;\r\n\r\n//import org.hipparchus.util.Math_Arrays;\r\n\r\n#include <vector>\r\n\r\n#include <string>\r\n\r\n#include <type_traits>\r\n\r\n#include "../../../core/CalculusFieldElement.h"\r\n\r\n/**\r\n\r\n * This class is a re-implementation of {@link Vector_3D} using {@link Calculus_Field_Element}.\r\n\r\n * <p>Instance of this class are guaranteed to be immutable.</p>\r\n\r\n * @param <T> the type of the field elements\r\n\r\n */\r\n\r\ntemplate<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n\r\nclass Field_Vector_3D\r\n\r\n{\r\n\r\nprivate:\r\n\r\n\r\n\r\n    /** Abscissa. */\r\n\r\n    const T my_x;\r\n\r\n\r\n\r\n    /** Ordinate. */\r\n\r\n    const T my_y;\r\n\r\n\r\n\r\n    /** Height. */\r\n\r\n    const T my_z;\r\n\r\n\r\n\r\npublic:\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a vector from its coordinates\r\n\r\n     * @param x abscissa\r\n\r\n     * @param y ordinate\r\n\r\n     * @param z height\r\n\r\n     * @see #get_x()\r\n\r\n     * @see #get_y()\r\n\r\n     * @see #get_z()\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& x, const T y, const T z) : my_x{ x }, my_y{ y }, my_z{ z }{}\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a vector from its coordinates\r\n\r\n     * @param v coordinates array\r\n\r\n     * @exception  if array does not have 3 elements\r\n\r\n     * @see #to_array()\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const std::vector<T> v)  \r\n\r\n    {\r\n\r\n        if (v.size() != 3) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.DIMENSIONS_MISMATCH, v.size(), 3);\r\n\r\n        }\r\n\r\n        my_x = v[0];\r\n\r\n        my_y = v[1];\r\n\r\n        my_z = v[2];\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Simple constructor.\r\n\r\n     * Build a vector from its azimuthal coordinates\r\n\r\n     * @param alpha azimuth (&alpha;) around Z\r\n\r\n     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\r\n\r\n     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\r\n\r\n     * @see #get_alpha()\r\n\r\n     * @see #get_delta()\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T alpha, const T delta) \r\n\r\n    {\r\n\r\n        Field_Sin_Cos<T> sin_cos_alpha = Sin_Cos(alpha);\r\n\r\n        Field_Sin_Cos<T> sin_cos_delta = Sin_Cos(delta);\r\n\r\n        my_x = sin_cos_alpha.cos().multiply(sin_cos_delta.cos());\r\n\r\n        my_y = sin_cos_alpha.sin().multiply(sin_cos_delta.cos());\r\n\r\n        my_z = sin_cos_delta.sin();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiplicative constructor.\r\n\r\n     * Build a vector from another one and a scale factor.\r\n\r\n     * The vector built will be a * u\r\n\r\n     * @param a scale factor\r\n\r\n     * @param u base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a, const Field_Vector_3D<T>u)\r\n\r\n        :\r\n\r\n        my_x{ a.multiply(u.x) },\r\n\r\n        my_y{ a.multiply(u.y) },\r\n\r\n        my_z{ a.multiply(u.z) }\r\n\r\n    {}\r\n\r\n\r\n\r\n    /** Multiplicative constructor.\r\n\r\n     * Build a vector from another one and a scale factor.\r\n\r\n     * The vector built will be a * u\r\n\r\n     * @param a scale factor\r\n\r\n     * @param u base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a, const Vector_3D u) \r\n\r\n        :\r\n\r\n        my_x{ a.multiply(u.get_x()) },\r\n\r\n        my_y{ a.multiply(u.get_y()) },\r\n\r\n        my_z{ a.multiply(u.get_z()) }\r\n\r\n    {}\r\n\r\n\r\n\r\n    /** Multiplicative constructor.\r\n\r\n     * Build a vector from another one and a scale factor.\r\n\r\n     * The vector built will be a * u\r\n\r\n     * @param a scale factor\r\n\r\n     * @param u base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const double& a, const Field_Vector_3D<T> u) \r\n\r\n        :\r\n\r\n        my_x{ u.x.multiply(a) },\r\n\r\n        my_y{ u.y.multiply(a) },\r\n\r\n        my_z{ u.z.multiply(a) }\r\n\r\n    {}\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from two other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Field_Vector_3D<T>& u1, const T a2, const Field_Vector_3D<T> u2) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from two other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Vector_3D& u1, const T& a2, const Vector_3D& u2) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(u1.get_x(), a1, u2.get_x(), a2);\r\n\r\n        my_y = prototype.linear_combination(u1.get_y(), a1, u2.get_y(), a2);\r\n\r\n        my_z = prototype.linear_combination(u1.get_z(), a1, u2.get_z(), a2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from two other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const double& a1, const Field_Vector_3D<T>& u1, const double& a2, const Field_Vector_3D<T> u2) \r\n\r\n    {\r\n\r\n        const T prototype = u1.get_x();\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from three other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Field_Vector_3D<T>& u1, const T a2, const Field_Vector_3D<T>& u2, const T a3, const Field_Vector_3D<T> u3) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x(), a3, u3.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y(), a3, u3.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z(), a3, u3.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from three other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Vector_3D u1, const T a2, const Vector_3D u2, const T a3, const Vector_3D u3) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(u1.get_x(), a1, u2.get_x(), a2, u3.get_x(), a3);\r\n\r\n        my_y = prototype.linear_combination(u1.get_y(), a1, u2.get_y(), a2, u3.get_y(), a3);\r\n\r\n        my_z = prototype.linear_combination(u1.get_z(), a1, u2.get_z(), a2, u3.get_z(), a3);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from three other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const double& a1, const Field_Vector_3D<T>& u1, const double& a2, const Field_Vector_3D<T>& u2, const double& a3, const Field_Vector_3D<T> u3) \r\n\r\n    {\r\n\r\n        const T prototype = u1.get_x();\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x(), a3, u3.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y(), a3, u3.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z(), a3, u3.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from four other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     * @param a4 fourth scale factor\r\n\r\n     * @param u4 fourth base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Field_Vector_3D<T>& u1, const T a2, const Field_Vector_3D<T>& u2, const T a3, const Field_Vector_3D<T>& u3, const T& a4, const Field_Vector_3D<T>& u4) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x(), a3, u3.get_x(), a4, u4.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y(), a3, u3.get_y(), a4, u4.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z(), a3, u3.get_z(), a4, u4.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from four other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     * @param a4 fourth scale factor\r\n\r\n     * @param u4 fourth base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const T& a1, const Vector_3D u1, const T a2, const Vector_3D u2, const T a3, const Vector_3D u3, const T& a4, const Vector_3D u4) \r\n\r\n    {\r\n\r\n        const T prototype = a1;\r\n\r\n        my_x = prototype.linear_combination(u1.get_x(), a1, u2.get_x(), a2, u3.get_x(), a3, u4.get_x(), a4);\r\n\r\n        my_y = prototype.linear_combination(u1.get_y(), a1, u2.get_y(), a2, u3.get_y(), a3, u4.get_y(), a4);\r\n\r\n        my_z = prototype.linear_combination(u1.get_z(), a1, u2.get_z(), a2, u3.get_z(), a3, u4.get_z(), a4);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Linear constructor.\r\n\r\n     * Build a vector from four other ones and corresponding scale factors.\r\n\r\n     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\r\n\r\n     * @param a1 first scale factor\r\n\r\n     * @param u1 first base (unscaled) vector\r\n\r\n     * @param a2 second scale factor\r\n\r\n     * @param u2 second base (unscaled) vector\r\n\r\n     * @param a3 third scale factor\r\n\r\n     * @param u3 third base (unscaled) vector\r\n\r\n     * @param a4 fourth scale factor\r\n\r\n     * @param u4 fourth base (unscaled) vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const double& a1, const Field_Vector_3D<T>& u1, const double& a2, const Field_Vector_3D<T>& u2, const double& a3, const Field_Vector_3D<T>& u3, const double& a4, const Field_Vector_3D<T>& u4) \r\n\r\n    {\r\n\r\n        const T prototype = u1.get_x();\r\n\r\n        my_x = prototype.linear_combination(a1, u1.get_x(), a2, u2.get_x(), a3, u3.get_x(), a4, u4.get_x());\r\n\r\n        my_y = prototype.linear_combination(a1, u1.get_y(), a2, u2.get_y(), a3, u3.get_y(), a4, u4.get_y());\r\n\r\n        my_z = prototype.linear_combination(a1, u1.get_z(), a2, u2.get_z(), a3, u3.get_z(), a4, u4.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Build a {@link Field_Vector_3D} from a {@link Vector_3D}.\r\n\r\n     * @param field field for the components\r\n\r\n     * @param v vector to convert\r\n\r\n     */\r\n\r\n    Field_Vector_3D(const Field<T> field, const Vector_3D v) \r\n\r\n    {\r\n\r\n        my_x = field.get_zero().add(v.get_x());\r\n\r\n        my_y = field.get_zero().add(v.get_y());\r\n\r\n        my_z = field.get_zero().add(v.get_z());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get null vector (coordinates: 0, 0, 0).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_zero(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.ZERO);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get first canonical vector (coordinates: 1, 0, 0).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_plus_i(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.PLUS_I);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get opposite of the first canonical vector (coordinates: -1, 0, 0).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_minus_i(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.MINUS_I);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get second canonical vector (coordinates: 0, 1, 0).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_plus_j(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.PLUS_J);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get opposite of the second canonical vector (coordinates: 0, -1, 0).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_minus_j(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.MINUS_J);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get third canonical vector (coordinates: 0, 0, 1).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_plus_k(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.PLUS_K);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get opposite of the third canonical vector (coordinates: 0, 0, -1).\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_minus_k(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.MINUS_K);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a vector with all coordinates set to NaN.\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_nan(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.NaN);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a vector with all coordinates set to positive infinity.\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_positive_infinity(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.POSITIVE_INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a vector with all coordinates set to negative infinity.\r\n\r\n     * @param field field for the components\r\n\r\n     * @return a vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> get_negative_infinity(const Field<T> field) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<>(field, Vector_3D.NEGATIVE_INFINITY);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the abscissa of the vector.\r\n\r\n     * @return abscissa of the vector\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    T get_x() \r\n\r\n    {\r\n\r\n        return x;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the ordinate of the vector.\r\n\r\n     * @return ordinate of the vector\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    T get_y() \r\n\r\n    {\r\n\r\n        return y;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the height of the vector.\r\n\r\n     * @return height of the vector\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element, Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    T get_z() \r\n\r\n    {\r\n\r\n        return z;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the vector coordinates as a dimension 3 array.\r\n\r\n     * @return vector coordinates\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element[])\r\n\r\n     */\r\n\r\n    std::vector<T> to_array() \r\n\r\n    {\r\n\r\n        const std::vector<T> array = Math_Arrays::build_array(x.get_field(), 3);\r\n\r\n        array[0] = x;\r\n\r\n        array[1] = y;\r\n\r\n        array[2] = z;\r\n\r\n        return array;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Convert to a constant vector without extra field parts.\r\n\r\n     * @return a constant vector\r\n\r\n     */\r\n\r\n    Vector_3D to_vector_3d() \r\n\r\n    {\r\n\r\n        return Vector_3D(x.get_real(), y.get_real(), z.get_real());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the L<sub>1</sub> norm for the vector.\r\n\r\n     * @return L<sub>1</sub> norm for the vector\r\n\r\n     */\r\n\r\n    T get_norm1() \r\n\r\n    {\r\n\r\n        return x.abs().add(y.abs()).add(z.abs());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the L<sub>2</sub> norm for the vector.\r\n\r\n     * @return Euclidean norm for the vector\r\n\r\n     */\r\n\r\n    T get_norm() \r\n\r\n    {\r\n\r\n        // there are no cancellation problems here, so we use the straightforward formula\r\n\r\n        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the square of the norm for the vector.\r\n\r\n     * @return square of the Euclidean norm for the vector\r\n\r\n     */\r\n\r\n    T get_norm_sq() \r\n\r\n    {\r\n\r\n        // there are no cancellation problems here, so we use the straightforward formula\r\n\r\n        return x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the L<sub>&infin;</sub> norm for the vector.\r\n\r\n     * @return L<sub>&infin;</sub> norm for the vector\r\n\r\n     */\r\n\r\n    T get_norm_inf() \r\n\r\n    {\r\n\r\n        return std::max(std::abs(x), std::max(std::abs(y), std::abs(z)));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the azimuth of the vector.\r\n\r\n     * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    T get_alpha() \r\n\r\n    {\r\n\r\n        return y.atan2(x);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the elevation of the vector.\r\n\r\n     * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\r\n\r\n     * @see #Field_Vector_3D(Calculus_Field_Element, Calculus_Field_Element)\r\n\r\n     */\r\n\r\n    T get_delta() \r\n\r\n    {\r\n\r\n        return z.divide(get_norm()).asin();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a vector to the instance.\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.add(v.x), y.add(v.y), z.add(v.z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a vector to the instance.\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.add(v.get_x()), y.add(v.get_y()), z.add(v.get_z()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a scaled vector to the instance.\r\n\r\n     * @param factor scale factor to apply to v before adding it\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const T factor, const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.get_field().get_one(), this, factor, v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a scaled vector to the instance.\r\n\r\n     * @param factor scale factor to apply to v before adding it\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const T factor, const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.add(factor.multiply(v.get_x())), y.add(factor.multiply(v.get_y())), z.add(factor.multiply(v.get_z())));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a scaled vector to the instance.\r\n\r\n     * @param factor scale factor to apply to v before adding it\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const double factor, const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(1.0, this, factor, v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Add a scaled vector to the instance.\r\n\r\n     * @param factor scale factor to apply to v before adding it\r\n\r\n     * @param v vector to add\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> add(const double factor, const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.add(factor * v.get_x()), y.add(factor * v.get_y()), z.add(factor * v.get_z()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a vector from the instance.\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.subtract(v.x), y.subtract(v.y), z.subtract(v.z));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a vector from the instance.\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.subtract(v.get_x()), y.subtract(v.get_y()), z.subtract(v.get_z()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a scaled vector from the instance.\r\n\r\n     * @param factor scale factor to apply to v before subtracting it\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const T factor, const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.get_field().get_one(), this, factor.negate(), v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a scaled vector from the instance.\r\n\r\n     * @param factor scale factor to apply to v before subtracting it\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const T factor, const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.subtract(factor.multiply(v.get_x())), y.subtract(factor.multiply(v.get_y())), z.subtract(factor.multiply(v.get_z())));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a scaled vector from the instance.\r\n\r\n     * @param factor scale factor to apply to v before subtracting it\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const double factor, const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(1.0, this, -factor, v);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Subtract a scaled vector from the instance.\r\n\r\n     * @param factor scale factor to apply to v before subtracting it\r\n\r\n     * @param v vector to subtract\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> subtract(const double factor, const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.subtract(factor * v.get_x()), y.subtract(factor * v.get_y()), z.subtract(factor * v.get_z()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a normalized vector aligned with the instance.\r\n\r\n     * @return a normalized vector\r\n\r\n     * @exception Math_Runtime_Exception if the norm is zero\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> normalize() Math_Runtime_Exception \r\n\r\n    {\r\n\r\n        const T s = get_norm();\r\n\r\n        if (s.get_real() == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Geometry_Formats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\r\n\r\n        }\r\n\r\n        return scalar_multiply(s.reciprocal());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a vector orthogonal to the instance.\r\n\r\n     * <p>There are an infinite number of normalized vectors orthogonal\r\n\r\n     * to the instance. This method picks up one of them almost\r\n\r\n     * arbitrarily. It is useful when one needs to compute a reference\r\n\r\n     * frame with one of the axes in a predefined direction. The\r\n\r\n     * following example shows how to build a frame having the k axis\r\n\r\n     * aligned with the known vector u :\r\n\r\n     * <pre><code>\r\n\r\n     *   Vector_3D k = u.normalize();\r\n\r\n     *   Vector_3D i = k.orthogonal();\r\n\r\n     *   Vector_3D j = Vector_3D.cross_product(k, i);\r\n\r\n     * </code></pre></p>\r\n\r\n     * @return a normalized vector orthogonal to the instance\r\n\r\n     * @exception Math_Runtime_Exception if the norm of the instance is null\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> orthogonal() Math_Runtime_Exception \r\n\r\n    {\r\n\r\n\r\n\r\n        const double threshold = 0.6 * get_norm().get_real();\r\n\r\n        if (threshold == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n        if (std::abs(x.get_real()) <= threshold) \r\n\r\n        {\r\n\r\n            const T inverse  = y.multiply(y).add(z.multiply(z)).sqrt().reciprocal();\r\n\r\n            return Field_Vector_3D<T>(inverse.get_field().get_zero(), inverse.multiply(z), inverse.multiply(y).negate());\r\n\r\n        }\r\n\r\n        \r\n\r\n        if (std::abs(y.get_real()) <= threshold) \r\n\r\n        {\r\n\r\n            const T inverse  = x.multiply(x).add(z.multiply(z)).sqrt().reciprocal();\r\n\r\n            return Field_Vector_3D<T>(inverse.multiply(z).negate(), inverse.get_field().get_zero(), inverse.multiply(x));\r\n\r\n        }\r\n\r\n\r\n\r\n        const T inverse  = x.multiply(x).add(y.multiply(y)).sqrt().reciprocal();\r\n\r\n        return Field_Vector_3D<T>(inverse.multiply(y), inverse.multiply(x).negate(), inverse.get_field().get_zero());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the angular separation between two vectors.\r\n\r\n     * <p>This method computes the angular separation between two\r\n\r\n     * vectors using the dot product for well separated vectors and the\r\n\r\n     * cross product for almost aligned vectors. This allows to have a\r\n\r\n     * good accuracy in all cases, even for vectors very close to each\r\n\r\n     * other.</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return angular separation between v1 and v2\r\n\r\n     * @exception Math_Runtime_Exception if either vector has a null norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T angle(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2)\r\n\r\n        Math_Runtime_Exception \r\n\r\n        {\r\n\r\n\r\n\r\n        const T norm_product = v1.get_norm().multiply(v2.get_norm());\r\n\r\n        if (norm_product.get_real() == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n        const T dot = dot_product(v1, v2);\r\n\r\n        const double threshold = norm_product.get_real() * 0.9999;\r\n\r\n        if ((dot.get_real() < -threshold) || (dot.get_real() > threshold)) \r\n\r\n        {\r\n\r\n            // the vectors are almost aligned, compute using the sine\r\n\r\n            Field_Vector_3D<T> v3 = cross_product(v1, v2);\r\n\r\n            if (dot.get_real() >= 0) \r\n\r\n            {\r\n\r\n                return v3.get_norm().divide(norm_product).asin();\r\n\r\n            }\r\n\r\n            return v3.get_norm().divide(norm_product).asin().subtract(dot.get_pi()).negate();\r\n\r\n        }\r\n\r\n\r\n\r\n        // the vectors are sufficiently separated to use the cosine\r\n\r\n        return dot.divide(norm_product).acos();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the angular separation between two vectors.\r\n\r\n     * <p>This method computes the angular separation between two\r\n\r\n     * vectors using the dot product for well separated vectors and the\r\n\r\n     * cross product for almost aligned vectors. This allows to have a\r\n\r\n     * good accuracy in all cases, even for vectors very close to each\r\n\r\n     * other.</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return angular separation between v1 and v2\r\n\r\n     * @exception Math_Runtime_Exception if either vector has a null norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T angle(const Field_Vector_3D<T> v1, const Vector_3D v2)\r\n\r\n    {\r\n\r\n\r\n\r\n        const T norm_product = v1.get_norm().multiply(v2.get_norm());\r\n\r\n        if (norm_product.get_real() == 0) \r\n\r\n        {\r\n\r\n            throw Math_Runtime_Exception(Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n\r\n\r\n        const T dot = dot_product(v1, v2);\r\n\r\n        const double threshold = norm_product.get_real() * 0.9999;\r\n\r\n        if ((dot.get_real() < -threshold) || (dot.get_real() > threshold)) \r\n\r\n        {\r\n\r\n            // the vectors are almost aligned, compute using the sine\r\n\r\n            Field_Vector_3D<T> v3 = cross_product(v1, v2);\r\n\r\n            if (dot.get_real() >= 0) \r\n\r\n            {\r\n\r\n                return v3.get_norm().divide(norm_product).asin();\r\n\r\n            }\r\n\r\n            return v3.get_norm().divide(norm_product).asin().subtract(dot.get_pi()).negate();\r\n\r\n        }\r\n\r\n\r\n\r\n        // the vectors are sufficiently separated to use the cosine\r\n\r\n        return dot.divide(norm_product).acos();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the angular separation between two vectors.\r\n\r\n     * <p>This method computes the angular separation between two\r\n\r\n     * vectors using the dot product for well separated vectors and the\r\n\r\n     * cross product for almost aligned vectors. This allows to have a\r\n\r\n     * good accuracy in all cases, even for vectors very close to each\r\n\r\n     * other.</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return angular separation between v1 and v2\r\n\r\n     * @exception Math_Runtime_Exception if either vector has a null norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T angle(const Vector_3D v1, const Field_Vector_3D<T> v2)\r\n\r\n    {\r\n\r\n        return angle(v2, v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the opposite of the instance.\r\n\r\n     * @return a vector which is opposite to the instance\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> negate() \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.negate(), y.negate(), z.negate());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply the instance by a scalar.\r\n\r\n     * @param a scalar\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> scalar_multiply(const T a) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.multiply(a), y.multiply(a), z.multiply(a));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Multiply the instance by a scalar.\r\n\r\n     * @param a scalar\r\n\r\n     * @return a vector\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> scalar_multiply(const double& a) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.multiply(a), y.multiply(a), z.multiply(a));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns true if any coordinate of this vector is NaN; false otherwise\r\n\r\n     * @return  true if any coordinate of this vector is NaN; false otherwise\r\n\r\n     */\r\n\r\n    bool is_nan() \r\n\r\n    {\r\n\r\n        return std::isnan(x.get_real()) || std::isnan(y.get_real()) || std::isnan(z.get_real());\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Returns true if any coordinate of this vector is infinite and none are NaN;\r\n\r\n     * false otherwise\r\n\r\n     * @return  true if any coordinate of this vector is infinite and none are NaN;\r\n\r\n     * false otherwise\r\n\r\n     */\r\n\r\n    bool is_infinite() \r\n\r\n    {\r\n\r\n        return !is_nan() && (std::isinfinite(x.get_real()) || std::isinfinite(y.get_real()) || std::isinfinite(z.get_real()));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Test for the equality of two 3D vectors.\r\n\r\n     * <p>\r\n\r\n     * If all coordinates of two 3D vectors are exactly the same, and none of their\r\n\r\n     * {@link Calculus_Field_Element#get_real() real part} are <code>NaN</code>, the\r\n\r\n     * two 3D vectors are considered to be equal.\r\n\r\n     * </p>\r\n\r\n     * <p>\r\n\r\n     * <code>NaN</code> coordinates are considered to affect globally the vector\r\n\r\n     * and be equals to each other - i.e, if either (or all) real part of the\r\n\r\n     * coordinates of the 3D vector are <code>NaN</code>, the 3D vector is <code>NaN</code>.\r\n\r\n     * </p>\r\n\r\n     *\r\n\r\n     * @param other Object to test for equality to this\r\n\r\n     * @return true if two 3D vector objects are equal, false if\r\n\r\n     *         object is null, not an instance of Field_Vector_3D, or\r\n\r\n     *         not equal to this Field_Vector_3D instance\r\n\r\n     *\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    bool equals(Object other) \r\n\r\n    {\r\n\r\n        if (this == other) \r\n\r\n        {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (other instanceof Field_Vector_3D) \r\n\r\n        {\r\n\r\n            ////@Suppress_Warnings("unchecked")\r\n\r\n            const Field_Vector_3D<T> rhs = (Field_Vector_3D<T>) other;\r\n\r\n            if (rhs.is_nan()) \r\n\r\n            {\r\n\r\n                return this.is_nan();\r\n\r\n            }\r\n\r\n\r\n\r\n            return x.equals(rhs.x) && y.equals(rhs.y) && z.equals(rhs.z);\r\n\r\n\r\n\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Get a hash_code for the 3D vector.\r\n\r\n     * <p>\r\n\r\n     * All NaN values have the same hash code.</p>\r\n\r\n     *\r\n\r\n     * @return a hash code value for this object\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    int hash_code() \r\n\r\n    {\r\n\r\n        if (is_nan()) \r\n\r\n        {\r\n\r\n            return 409;\r\n\r\n        }\r\n\r\n        return 311 * (107 * x.hash_code() + 83 * y.hash_code() +  z.hash_code());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the dot-product of the instance and another vector.\r\n\r\n     * <p>\r\n\r\n     * The implementation uses specific multiplication and addition\r\n\r\n     * algorithms to preserve accuracy and reduce cancellation effects.\r\n\r\n     * It should be very accurate even for nearly orthogonal vectors.\r\n\r\n     * </p>\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double)\r\n\r\n     * @param v second vector\r\n\r\n     * @return the dot product this.v\r\n\r\n     */\r\n\r\n    T dot_product(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return x.linear_combination(x, v.x, y, v.y, z, v.z);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the dot-product of the instance and another vector.\r\n\r\n     * <p>\r\n\r\n     * The implementation uses specific multiplication and addition\r\n\r\n     * algorithms to preserve accuracy and reduce cancellation effects.\r\n\r\n     * It should be very accurate even for nearly orthogonal vectors.\r\n\r\n     * </p>\r\n\r\n     * @see Math_Arrays#linear_combination(double, double, double, double, double, double)\r\n\r\n     * @param v second vector\r\n\r\n     * @return the dot product this.v\r\n\r\n     */\r\n\r\n    T dot_product(const Vector_3D v) \r\n\r\n    {\r\n\r\n        return x.linear_combination(v.get_x(), x, v.get_y(), y, v.get_z(), z);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cross-product of the instance with another vector.\r\n\r\n     * @param v other vector\r\n\r\n     * @return the cross product this ^ v as a Vector_3D\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> cross_product(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.linear_combination(y, v.z, z.negate(), v.y), y.linear_combination(z, v.x, x.negate(), v.z), z.linear_combination(x, v.y, y.negate(), v.x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cross-product of the instance with another vector.\r\n\r\n     * @param v other vector\r\n\r\n     * @return the cross product this ^ v as a Vector_3D\r\n\r\n     */\r\n\r\n    Field_Vector_3D<T> cross_product(const Vector_3D v) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(x.linear_combination(v.get_z(), y, -v.get_y(), z), y.linear_combination(v.get_x(), z, -v.get_z(), x), z.linear_combination(v.get_y(), x, -v.get_x(), y));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm1()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>1</sub> norm\r\n\r\n     */\r\n\r\n    T distance1(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        const T dx = v.x.subtract(x).abs();\r\n\r\n        const T dy = v.y.subtract(y).abs();\r\n\r\n        const T dz = v.z.subtract(z).abs();\r\n\r\n        return dx.add(dy).add(dz);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm1()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>1</sub> norm\r\n\r\n     */\r\n\r\n    T distance1(const Vector_3D v) \r\n\r\n    {\r\n\r\n        const T dx = x.subtract(v.get_x()).abs();\r\n\r\n        const T dy = y.subtract(v.get_y()).abs();\r\n\r\n        const T dz = z.subtract(v.get_z()).abs();\r\n\r\n        return dx.add(dy).add(dz);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>2</sub> norm\r\n\r\n     */\r\n\r\n    T distance(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        const T dx = v.x.subtract(x);\r\n\r\n        const T dy = v.y.subtract(y);\r\n\r\n        const T dz = v.z.subtract(z);\r\n\r\n        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>2</sub> norm\r\n\r\n     */\r\n\r\n    T distance(const Vector_3D v) \r\n\r\n    {\r\n\r\n        const T dx = x.subtract(v.get_x());\r\n\r\n        const T dy = y.subtract(v.get_y());\r\n\r\n        const T dz = z.subtract(v.get_z());\r\n\r\n        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz)).sqrt();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm_inf()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\r\n\r\n     */\r\n\r\n    T distance_inf(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        const T dx = v.x.subtract(x).abs();\r\n\r\n        const T dy = v.y.subtract(y).abs();\r\n\r\n        const T dz = v.z.subtract(z).abs();\r\n\r\n        if (dx.get_real() <= dy.get_real()) \r\n\r\n        {\r\n\r\n            if (dy.get_real() <= dz.get_real()) \r\n\r\n            {\r\n\r\n                return dz;\r\n\r\n            }\r\n\r\n            return dy;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (dx.get_real() <= dz.get_real()) \r\n\r\n        {\r\n\r\n            return dz;\r\n\r\n        }\r\n\r\n        return dx;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm_inf()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\r\n\r\n     */\r\n\r\n    T distance_inf(const Vector_3D v) \r\n\r\n    {\r\n\r\n        const T dx = x.subtract(v.get_x()).abs();\r\n\r\n        const T dy = y.subtract(v.get_y()).abs();\r\n\r\n        const T dz = z.subtract(v.get_z()).abs();\r\n\r\n        if (dx.get_real() <= dy.get_real()) \r\n\r\n        {\r\n\r\n            if (dy.get_real() <= dz.get_real()) \r\n\r\n            {\r\n\r\n                return dz;\r\n\r\n            }\r\n\r\n            return dy;\r\n\r\n        }\r\n\r\n\r\n\r\n        if (dx.get_real() <= dz.get_real()) \r\n\r\n        {\r\n\r\n            return dz;\r\n\r\n        }\r\n\r\n        return dx;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square of the distance between the instance and another vector.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm_sq()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the square of the distance between the instance and p\r\n\r\n     */\r\n\r\n    T distance_sq(const Field_Vector_3D<T> v) \r\n\r\n    {\r\n\r\n        const T dx = v.x.subtract(x);\r\n\r\n        const T dy = v.y.subtract(y);\r\n\r\n        const T dz = v.z.subtract(z);\r\n\r\n        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square of the distance between the instance and another vector.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>q.subtract(p).get_norm_sq()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v second vector\r\n\r\n     * @return the square of the distance between the instance and p\r\n\r\n     */\r\n\r\n    T distance_sq(const Vector_3D v) \r\n\r\n    {\r\n\r\n        const T dx = x.subtract(v.get_x());\r\n\r\n        const T dy = y.subtract(v.get_y());\r\n\r\n        const T dz = z.subtract(v.get_z());\r\n\r\n        return dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the dot-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the dot product v1.v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T dot_product(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.dot_product(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the dot-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the dot product v1.v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T dot_product(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.dot_product(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the dot-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the dot product v1.v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T dot_product(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v2.dot_product(v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cross-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the cross product v1 ^ v2 as a Vector\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> cross_product(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.cross_product(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cross-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the cross product v1 ^ v2 as a Vector\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> cross_product(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.cross_product(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the cross-product of two vectors.\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the cross product v1 ^ v2 as a Vector\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  Field_Vector_3D<T> cross_product(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(v2.x.linear_combination(v1.get_y(), v2.z, -v1.get_z(), v2.y), v2.y.linear_combination(v1.get_z(), v2.x, -v1.get_x(), v2.z), v2.z.linear_combination(v1.get_x(), v2.y, -v1.get_y(), v2.x));\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm1()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance1(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.distance1(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm1()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance1(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.distance1(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm1()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance1(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v2.distance1(v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.distance(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.distance(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v2.distance(v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_inf()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_inf(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.distance_inf(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_inf()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_inf(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.distance_inf(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_inf()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_inf(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v2.distance_inf(v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square of the distance between two vectors.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_sq()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the square of the distance between v1 and v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_sq(const Field_Vector_3D<T> v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v1.distance_sq(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square of the distance between two vectors.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_sq()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the square of the distance between v1 and v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_sq(const Field_Vector_3D<T> v1, const Vector_3D v2) \r\n\r\n    {\r\n\r\n        return v1.distance_sq(v2);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the square of the distance between two vectors.\r\n\r\n     * <p>Calling this method is equivalent to calling:\r\n\r\n     * <code>v1.subtract(v2).get_norm_sq()</code> except that no intermediate\r\n\r\n     * vector is built</p>\r\n\r\n     * @param v1 first vector\r\n\r\n     * @param v2 second vector\r\n\r\n     * @param <T> the type of the field elements\r\n\r\n     * @return the square of the distance between v1 and v2\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\n    static  T distance_sq(const Vector_3D v1, const Field_Vector_3D<T> v2) \r\n\r\n    {\r\n\r\n        return v2.distance_sq(v1);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a string representation of this vector.\r\n\r\n     * @return a string representation of this vector\r\n\r\n     */\r\n\r\n    //override\r\n\r\n    std::string to_string() const \r\n\r\n    {\r\n\r\n        return Vector_3DFormat.get_vector_3d_format().format(to_vector_3d());\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a string representation of this vector.\r\n\r\n     * @param format the custom format for components\r\n\r\n     * @return a string representation of this vector\r\n\r\n     */\r\n\r\n    std::string to_string(const Number_Format format) \r\n\r\n    {\r\n\r\n        return Vector_3DFormat(format).format(to_vector_3d());\r\n\r\n    }\r\n\r\n};\r\n