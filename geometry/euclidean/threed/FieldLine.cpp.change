/*\r\n\r\n * Licensed to the Apache Software Foundation (ASF) under one or more\r\n\r\n * contributor license agreements.  See the NOTICE file distributed with\r\n\r\n * this work for additional information regarding copyright ownership.\r\n\r\n * The ASF licenses this file to You under the Apache License, Version 2.0\r\n\r\n * (the "License"); you may not use this file except in compliance with\r\n\r\n * the License.  You may obtain a copy of the License at\r\n\r\n *\r\n\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n *\r\n\r\n * Unless required by applicable law or agreed to in writing, software\r\n\r\n * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n\r\n * See the License for the specific language governing permissions and\r\n\r\n * limitations under the License.\r\n\r\n */\r\n\r\n\r\n\r\n/*\r\n\r\n * This is not the original file distributed by the Apache Software Foundation\r\n\r\n * It has been modified by the Hipparchus project\r\n\r\n */\r\n\r\n//package org.hipparchus.geometry.euclidean.threed;\r\n\r\n\r\n\r\n//import org.hipparchus.Calculus_Field_Element;\r\n\r\n//import org.hipparchus.exception.Localized_Core_Formats;\r\n\r\n//import org.hipparchus.exception.;\r\n\r\n//import org.hipparchus.util.FastMath;\r\n\r\n//import org.hipparchus.util.Precision;\r\n\r\n\r\n\r\n/** The class represent lines in a three dimensional space.\r\n\r\n\r\n\r\n * <p>Each oriented line is intrinsically associated with an abscissa\r\n\r\n * which is a coordinate on the line. The point at abscissa 0 is the\r\n\r\n * orthogonal projection of the origin on the line, another equivalent\r\n\r\n * way to express this is to say that it is the point of the line\r\n\r\n * which is closest to the origin. Abscissa increases in the line\r\n\r\n * direction.</p>\r\n\r\n * @param <T> the type of the field elements\r\n\r\n    template<typename T, typename std::enable_if<std::is_base_of<Calculus_Field_Element, T>::value>::type* = nullptr>\r\nclass Field_Line \r\n\r\n{\r\n\r\n\r\n\r\n    /** Line direction. */\r\n\r\n    private Field_Vector_3D<T> direction;\r\n\r\n\r\n\r\n    /** Line point closest to the origin. */\r\n\r\n    private Field_Vector_3D<T> zero;\r\n\r\n\r\n\r\n    /** Tolerance below which points are considered identical. */\r\n\r\n    private const double& tolerance;\r\n\r\n\r\n\r\n    /** Build a line from two points.\r\n\r\n     * @param p1 first point belonging to the line (this can be any point)\r\n\r\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\r\n\r\n     * @param tolerance tolerance below which points are considered identical\r\n\r\n     * @exception  if the points are equal\r\n\r\n     */\r\n\r\n    public Field_Line(const Field_Vector_3D<T> p1, const Field_Vector_3D<T> p2, const double& tolerance)\r\n\r\n         \r\n\r\n        {\r\n\r\n        reset(p1, p2);\r\n\r\n        this.tolerance = tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Copy constructor.\r\n\r\n     * <p>The created instance is completely independent from the\r\n\r\n     * original instance, it is a deep copy.</p>\r\n\r\n     * @param line line to copy\r\n\r\n     */\r\n\r\n    public Field_Line(const Field_Line<T> line) \r\n\r\n    {\r\n\r\n        this.direction = line.direction;\r\n\r\n        this.zero      = line.zero;\r\n\r\n        this.tolerance = line.tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Reset the instance as if built from two points.\r\n\r\n     * @param p1 first point belonging to the line (this can be any point)\r\n\r\n     * @param p2 second point belonging to the line (this can be any point, different from p1)\r\n\r\n     * @exception  if the points are equal\r\n\r\n     */\r\n\r\n    public void reset(const Field_Vector_3D<T> p1, const Field_Vector_3D<T> p2)\r\n\r\n         \r\n\r\n        {\r\n\r\n        const Field_Vector_3D<T> delta = p2.subtract(p1);\r\n\r\n        const T norm2 = delta.get_norm_sq();\r\n\r\n        if (norm2.get_real() == 0.0) \r\n\r\n        {\r\n\r\n            throw (Localized_Core_Formats.ZERO_NORM);\r\n\r\n        }\r\n\r\n        this.direction = Field_Vector_3D<>(norm2.sqrt().reciprocal(), delta);\r\n\r\n        zero = Field_Vector_3D<>(norm2.get_field().get_one(), p1, p1.dot_product(delta).negate().divide(norm2), delta);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the tolerance below which points are considered identical.\r\n\r\n     * @return tolerance below which points are considered identical\r\n\r\n     */\r\n\r\n    public double get_tolerance() \r\n\r\n    {\r\n\r\n        return tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get a line with reversed direction.\r\n\r\n     * @return a instance, with reversed direction\r\n\r\n     */\r\n\r\n    public Field_Line<T> revert() \r\n\r\n    {\r\n\r\n        const Field_Line<T> reverted = Field_Line<>(this);\r\n\r\n        reverted.direction = reverted.direction.negate();\r\n\r\n        return reverted;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the normalized direction vector.\r\n\r\n     * @return normalized direction vector\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> get_direction() \r\n\r\n    {\r\n\r\n        return direction;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the line point closest to the origin.\r\n\r\n     * @return line point closest to the origin\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> get_origin() \r\n\r\n    {\r\n\r\n        return zero;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the abscissa of a point with respect to the line.\r\n\r\n     * <p>The abscissa is 0 if the projection of the point and the\r\n\r\n     * projection of the frame origin on the line are the same\r\n\r\n     * point.</p>\r\n\r\n     * @param point point to check\r\n\r\n     * @return abscissa of the point\r\n\r\n     */\r\n\r\n    public T get_abscissa(const Field_Vector_3D<T> point) \r\n\r\n    {\r\n\r\n        return point.subtract(zero).dot_product(direction);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the abscissa of a point with respect to the line.\r\n\r\n     * <p>The abscissa is 0 if the projection of the point and the\r\n\r\n     * projection of the frame origin on the line are the same\r\n\r\n     * point.</p>\r\n\r\n     * @param point point to check\r\n\r\n     * @return abscissa of the point\r\n\r\n     */\r\n\r\n    public T get_abscissa(const Vector_3D point) \r\n\r\n    {\r\n\r\n        return zero.subtract(point).dot_product(direction).negate();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get one point from the line.\r\n\r\n     * @param abscissa desired abscissa for the point\r\n\r\n     * @return one point belonging to the line, at specified abscissa\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> point_at(const T abscissa) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(abscissa.get_field().get_one(), zero, abscissa, direction);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get one point from the line.\r\n\r\n     * @param abscissa desired abscissa for the point\r\n\r\n     * @return one point belonging to the line, at specified abscissa\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> point_at(const double& abscissa) \r\n\r\n    {\r\n\r\n        return Field_Vector_3D<T>(1, zero, abscissa, direction);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check if the instance is similar to another line.\r\n\r\n     * <p>Lines are considered similar if they contain the same\r\n\r\n     * points. This does not mean they are equal since they can have\r\n\r\n     * opposite directions.</p>\r\n\r\n     * @param line line to which instance should be compared\r\n\r\n     * @return true if the lines are similar\r\n\r\n     */\r\n\r\n    public bool is_similar_to(const Field_Line<T> line) \r\n\r\n    {\r\n\r\n        const double& angle = Field_Vector_3D.angle(direction, line.direction).get_real();\r\n\r\n        return ((angle < tolerance) || (angle > (std::numbers::pi - tolerance))) && contains(line.zero);\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check if the instance contains a point.\r\n\r\n     * @param p point to check\r\n\r\n     * @return true if p belongs to the line\r\n\r\n     */\r\n\r\n    public bool contains(const Field_Vector_3D<T> p) \r\n\r\n    {\r\n\r\n        return distance(p).get_real() < tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Check if the instance contains a point.\r\n\r\n     * @param p point to check\r\n\r\n     * @return true if p belongs to the line\r\n\r\n     */\r\n\r\n    public bool contains(const Vector_3D p) \r\n\r\n    {\r\n\r\n        return distance(p).get_real() < tolerance;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and a point.\r\n\r\n     * @param p to check\r\n\r\n     * @return distance between the instance and the point\r\n\r\n     */\r\n\r\n    public T distance(const Field_Vector_3D<T> p) \r\n\r\n    {\r\n\r\n        const Field_Vector_3D<T> d = p.subtract(zero);\r\n\r\n        const Field_Vector_3D<T> n = Field_Vector_3D<>(zero.get_x().get_field().get_one(), d, d.dot_product(direction).negate(), direction);\r\n\r\n        return n.get_norm();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the distance between the instance and a point.\r\n\r\n     * @param p to check\r\n\r\n     * @return distance between the instance and the point\r\n\r\n     */\r\n\r\n    public T distance(const Vector_3D p) \r\n\r\n    {\r\n\r\n        const Field_Vector_3D<T> d = zero.subtract(p).negate();\r\n\r\n        const Field_Vector_3D<T> n = Field_Vector_3D<>(zero.get_x().get_field().get_one(), d, d.dot_product(direction).negate(), direction);\r\n\r\n        return n.get_norm();\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the shortest distance between the instance and another line.\r\n\r\n     * @param line line to check against the instance\r\n\r\n     * @return shortest distance between the instance and the line\r\n\r\n     */\r\n\r\n    public T distance(const Field_Line<T> line) \r\n\r\n    {\r\n\r\n\r\n\r\n        const Field_Vector_3D<T> normal = Field_Vector_3D.cross_product(direction, line.direction);\r\n\r\n        const T n = normal.get_norm();\r\n\r\n        if (n.get_real() < Precision.SAFE_MIN) \r\n\r\n        {\r\n\r\n            // lines are parallel\r\n\r\n            return distance(line.zero);\r\n\r\n        }\r\n\r\n\r\n\r\n        // signed separation of the two parallel planes that contains the lines\r\n\r\n        const T offset = line.zero.subtract(zero).dot_product(normal).divide(n);\r\n\r\n\r\n\r\n        return offset.abs();\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Compute the point of the instance closest to another line.\r\n\r\n     * @param line line to check against the instance\r\n\r\n     * @return point of the instance closest to another line\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> closest_point(const Field_Line<T> line) \r\n\r\n    {\r\n\r\n\r\n\r\n        const T cos = direction.dot_product(line.direction);\r\n\r\n        const T n = cos.multiply(cos).subtract(1).negate();\r\n\r\n        if (n.get_real() < Precision.EPSILON) \r\n\r\n        {\r\n\r\n            // the lines are parallel\r\n\r\n            return zero;\r\n\r\n        }\r\n\r\n\r\n\r\n        const Field_Vector_3D<T> delta0 = line.zero.subtract(zero);\r\n\r\n        const T a                     = delta0.dot_product(direction);\r\n\r\n        const T& b                     = delta0.dot_product(line.direction);\r\n\r\n\r\n\r\n        return Field_Vector_3D<T>(a.get_field().get_one(), zero, a.subtract(b.multiply(cos)).divide(n), direction);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Get the intersection point of the instance and another line.\r\n\r\n     * @param line other line\r\n\r\n     * @return intersection point of the instance and the other line\r\n\r\n     * or null if there are no intersection points\r\n\r\n     */\r\n\r\n    public Field_Vector_3D<T> intersection(const Field_Line<T> line) \r\n\r\n    {\r\n\r\n        const Field_Vector_3D<T> closest = closest_point(line);\r\n\r\n        return line.contains(closest) ? closest : null;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n